diff --git a/src/action.cpp b/src/action.cpp
index 7941530..42cfd6b 100644
--- a/src/action.cpp
+++ b/src/action.cpp
@@ -43,6 +43,8 @@
 #include "scripttabs.h"
 #include "transporter.h"
 #include "mapgrid.h"
+#include <math.h>
+#include "console.h"
 
 /* attack run distance */
 #define	VTOL_ATTACK_LENGTH		1000
@@ -157,7 +159,7 @@ const char* getDroidActionName(DROID_ACTION action)
 /* Check if a target is at correct range to attack */
 static bool actionInAttackRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_slot)
 {
-	SDWORD			dx, dy, radSq, rangeSq, longRange;
+    SDWORD			dx, dy, dz, radSq, rangeSq, longRange, angle, minEle, maxEle;
 	WEAPON_STATS	*psStats;
 	int compIndex;
 
@@ -216,14 +218,26 @@ static bool actionInAttackRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_s
 	/* check max range */
 	if ( radSq <= rangeSq )
 	{
-		/* check min range */
-		rangeSq = psStats->minRange * psStats->minRange;
-		if ( radSq >= rangeSq || !proj_Direct( psStats ) )
-		{
-			return true;
-		}
+        /* check min range */
+        rangeSq = psStats->minRange * psStats->minRange;
+        if ( radSq >= rangeSq || !proj_Direct( psStats ) )
+        {
+            /*check angle */
+            dz = (SDWORD)psObj->pos.z - (SDWORD)psDroid->pos.z;
+            dz = dz*2;
+            angle = atan(dz/sqrt(radSq)) * 180 / M_PI;
+            minEle = psStats->minElevation;
+            maxEle = psStats->maxElevation;
+            if(minEle <= angle && angle <= maxEle) {
+                if(psStats->movementModel != MM_INDIRECT) {
+                    return true;
+                }
+            }
+        }
 	}
 
+
+
 	return false;
 }
 
@@ -231,7 +245,7 @@ static bool actionInAttackRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_s
 // check if a target is within weapon range
 bool actionInRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_slot)
 {
-	SDWORD			dx, dy, radSq, rangeSq, longRange;
+    SDWORD			dx, dy, dz, radSq, rangeSq, longRange, angle, minEle, maxEle;
 	WEAPON_STATS	*psStats;
 	int compIndex;
 
@@ -261,7 +275,17 @@ bool actionInRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_slot)
 		rangeSq = psStats->minRange * psStats->minRange;
 		if ( radSq >= rangeSq || !proj_Direct( psStats ) )
 		{
-			return true;
+            /*check angle */
+            dz = (SDWORD)psObj->pos.z - (SDWORD)psDroid->pos.z;
+            dz = dz*2;
+            angle = atan(dz/sqrt(radSq)) * 180 / M_PI;
+            minEle = psStats->minElevation;
+            maxEle = psStats->maxElevation;
+            if(minEle <= angle && angle <= maxEle) {
+                if(psStats->movementModel != MM_INDIRECT) {
+                    return true;
+                }
+            }
 		}
 	}
 
@@ -1042,7 +1066,7 @@ void actionUpdateDroid(DROID *psDroid)
 					{
 						BASE_OBJECT* psActionTarget = psDroid->psActionTarget[i];
 						// is the turret aligned with the target?
-						if (actionTargetTurret(psDroid, psActionTarget, &psDroid->asWeaps[i]))
+                        if (actionTargetTurret(psDroid, psActionTarget, &psDroid->asWeaps[i]) && actionInAttackRange(psDroid, psActionTarget, i))
 						{
 							// In range - fire !!!
 							combFire(&psDroid->asWeaps[i], psDroid, psActionTarget, i);
@@ -1477,7 +1501,7 @@ void actionUpdateDroid(DROID *psDroid)
 				//unless its a module!
 				if (IsStatExpansionModule(psStructStats))
 				{
-					syncDebug("Reached build target: module");
+                    syncDebug("Reached build target: module");
 					debug( LOG_NEVER, "DACTION_MOVETOBUILD: setUpBuildModule");
 					setUpBuildModule(psDroid);
 				}
diff --git a/src/ai.cpp b/src/ai.cpp
index e46b921..21f732a 100644
--- a/src/ai.cpp
+++ b/src/ai.cpp
@@ -33,6 +33,8 @@
 #include "mapgrid.h"
 #include "map.h"
 #include "projectile.h"
+#include <math.h>
+#include "console.h"
 
 /* Weights used for target selection code,
  * target distance is used as 'common currency'
@@ -107,12 +109,37 @@ static bool aiStructHasRange(STRUCTURE *psStruct, BASE_OBJECT *psTarget, int wea
 	WEAPON_STATS *psWStats = psStruct->asWeaps[weapon_slot].nStat + asWeaponStats;
 
 	int longRange = proj_GetLongRange(psWStats);
+    /*check angle */
+    SDWORD dz, angle, minEle, maxEle;
+    dz = (SDWORD)psTarget->pos.z - (SDWORD)psStruct->pos.z;
+    dz = dz*2;
+    angle = atan(dz/sqrt(objPosDiffSq(psStruct, psTarget))) * 180 / M_PI;
+    minEle = psWStats->minElevation;
+    maxEle = psWStats->maxElevation;
+    if(minEle > angle || angle > maxEle) {
+        if(psWStats->movementModel != MM_INDIRECT) {
+            return false;
+        }
+    }
 	return objPosDiffSq(psStruct, psTarget) < longRange*longRange && lineOfFire(psStruct, psTarget, weapon_slot, true);
 }
 
 static bool aiDroidHasRange(DROID *psDroid, BASE_OBJECT *psTarget, int weapon_slot)
 {
-	int32_t longRange = aiObjRange(psDroid, weapon_slot);
+    WEAPON_STATS *psWStats = psDroid->asWeaps[weapon_slot].nStat + asWeaponStats;
+    int32_t longRange = aiObjRange(psDroid, weapon_slot);
+    /*check angle */
+    SDWORD dz, angle, minEle, maxEle;
+    dz = (SDWORD)psTarget->pos.z - (SDWORD)psDroid->pos.z;
+    dz = dz*2;
+    angle = atan(dz/sqrt(objPosDiffSq(psDroid, psTarget))) * 180 / M_PI;
+    minEle = psWStats->minElevation;
+    maxEle = psWStats->maxElevation;
+    if(minEle > angle || angle > maxEle) {
+        if(psWStats->movementModel != MM_INDIRECT) {
+            return false;
+        }
+    }
 
 	return objPosDiffSq(psDroid, psTarget) < longRange*longRange;
 }
