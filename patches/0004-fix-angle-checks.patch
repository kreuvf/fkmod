diff --git a/src/action.cpp b/src/action.cpp
index 7941530..faf5f40 100644
--- a/src/action.cpp
+++ b/src/action.cpp
@@ -43,6 +43,8 @@
 #include "scripttabs.h"
 #include "transporter.h"
 #include "mapgrid.h"
+#include <math.h>
+#include "console.h"
 
 /* attack run distance */
 #define	VTOL_ATTACK_LENGTH		1000
@@ -157,7 +159,7 @@ const char* getDroidActionName(DROID_ACTION action)
 /* Check if a target is at correct range to attack */
 static bool actionInAttackRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_slot)
 {
-	SDWORD			dx, dy, radSq, rangeSq, longRange;
+	SDWORD			dx, dy, dz, radSq, rangeSq, longRange, angle, minEle, maxEle;
 	WEAPON_STATS	*psStats;
 	int compIndex;
 
@@ -220,10 +222,28 @@ static bool actionInAttackRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_s
 		rangeSq = psStats->minRange * psStats->minRange;
 		if ( radSq >= rangeSq || !proj_Direct( psStats ) )
 		{
-			return true;
+			/* Check angle, if the weapon is NOT firing indirectly */
+			if(psStats->movementModel == MM_INDIRECT)
+			{
+				return true;
+			}
+			else
+			{
+				dz = (SDWORD)psObj->pos.z - (SDWORD)psDroid->pos.z;
+				dz = dz*2;
+				angle = atan(dz/sqrt(radSq)) * 180 / M_PI;
+				minEle = psStats->minElevation;
+				maxEle = psStats->maxElevation;
+				if(minEle <= angle && angle <= maxEle)
+				{
+					return true;
+				}
+			}
 		}
 	}
 
+
+
 	return false;
 }
 
@@ -231,7 +251,7 @@ static bool actionInAttackRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_s
 // check if a target is within weapon range
 bool actionInRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_slot)
 {
-	SDWORD			dx, dy, radSq, rangeSq, longRange;
+	SDWORD			dx, dy, dz, radSq, rangeSq, longRange, angle, minEle, maxEle;
 	WEAPON_STATS	*psStats;
 	int compIndex;
 
@@ -261,7 +281,23 @@ bool actionInRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_slot)
 		rangeSq = psStats->minRange * psStats->minRange;
 		if ( radSq >= rangeSq || !proj_Direct( psStats ) )
 		{
-			return true;
+			/* Check angle, if the weapon is NOT indirectly firing */
+			if(psStats->movementModel == MM_INDIRECT)
+			{
+				return true;
+			}
+			else
+			{
+				dz = (SDWORD)psObj->pos.z - (SDWORD)psDroid->pos.z;
+				dz = dz*2;
+				angle = atan(dz/sqrt(radSq)) * 180 / M_PI;
+				minEle = psStats->minElevation;
+				maxEle = psStats->maxElevation;
+				if(minEle <= angle && angle <= maxEle)
+				{
+					return true;
+				}
+			}
 		}
 	}
 
@@ -1042,7 +1078,7 @@ void actionUpdateDroid(DROID *psDroid)
 					{
 						BASE_OBJECT* psActionTarget = psDroid->psActionTarget[i];
 						// is the turret aligned with the target?
-						if (actionTargetTurret(psDroid, psActionTarget, &psDroid->asWeaps[i]))
+						if (actionTargetTurret(psDroid, psActionTarget, &psDroid->asWeaps[i]) && actionInAttackRange(psDroid, psActionTarget, i))
 						{
 							// In range - fire !!!
 							combFire(&psDroid->asWeaps[i], psDroid, psActionTarget, i);
diff --git a/src/ai.cpp b/src/ai.cpp
index e46b921..e802bdf 100644
--- a/src/ai.cpp
+++ b/src/ai.cpp
@@ -33,6 +33,8 @@
 #include "mapgrid.h"
 #include "map.h"
 #include "projectile.h"
+#include <math.h>
+#include "console.h"
 
 /* Weights used for target selection code,
  * target distance is used as 'common currency'
@@ -107,12 +109,37 @@ static bool aiStructHasRange(STRUCTURE *psStruct, BASE_OBJECT *psTarget, int wea
 	WEAPON_STATS *psWStats = psStruct->asWeaps[weapon_slot].nStat + asWeaponStats;
 
 	int longRange = proj_GetLongRange(psWStats);
+	/*check angle */
+	SDWORD dz, angle, minEle, maxEle;
+	dz = (SDWORD)psTarget->pos.z - (SDWORD)psStruct->pos.z;
+	dz = dz*2;
+	angle = atan(dz/sqrt(objPosDiffSq(psStruct, psTarget))) * 180 / M_PI;
+	minEle = psWStats->minElevation;
+	maxEle = psWStats->maxElevation;
+	if(minEle > angle || angle > maxEle) {
+		if(psWStats->movementModel != MM_INDIRECT) {
+			return false;
+		}
+	}
 	return objPosDiffSq(psStruct, psTarget) < longRange*longRange && lineOfFire(psStruct, psTarget, weapon_slot, true);
 }
 
 static bool aiDroidHasRange(DROID *psDroid, BASE_OBJECT *psTarget, int weapon_slot)
 {
+	WEAPON_STATS *psWStats = psDroid->asWeaps[weapon_slot].nStat + asWeaponStats;
 	int32_t longRange = aiObjRange(psDroid, weapon_slot);
+	/*check angle */
+	SDWORD dz, angle, minEle, maxEle;
+	dz = (SDWORD)psTarget->pos.z - (SDWORD)psDroid->pos.z;
+	dz = dz*2;
+	angle = atan(dz/sqrt(objPosDiffSq(psDroid, psTarget))) * 180 / M_PI;
+	minEle = psWStats->minElevation;
+	maxEle = psWStats->maxElevation;
+	if(minEle > angle || angle > maxEle) {
+		if(psWStats->movementModel != MM_INDIRECT) {
+			return false;
+		}
+	}
 
 	return objPosDiffSq(psDroid, psTarget) < longRange*longRange;
 }
