diff --git a/data/mp/multiplay/skirmish/nb_common/standard_build_order.js b/data/mp/multiplay/skirmish/nb_common/standard_build_order.js
deleted file mode 100644
index 1041762..0000000
--- a/data/mp/multiplay/skirmish/nb_common/standard_build_order.js
+++ /dev/null
@@ -1,45 +0,0 @@
-
-// A fallback build order for the standard ruleset.
-
-function buildOrder_StandardFallback() {
-	var derrickCount = countFinishedStructList(structures.derricks);
-	// might be good for Insane AI, or for rebuilding
-	if (derrickCount > 0)
-		if (buildMinimum(structures.gens, 1)) return true;
-	// lab, factory, gen, cc - the current trivial build order for the 3.2+ starting conditions
-	if (buildMinimum(structures.labs, 1)) return true;
-	if (buildMinimum(structures.factories, 1)) return true;
-	if (buildMinimum(structures.gens, 1)) return true;
-	// make sure trucks go capture some oil at this moment
-	if (buildMinimumDerricks(1)) return true;
-	// what if one of them is being upgraded? will need the other anyway.
-	// also, it looks like the right timing in most cases.
-	if (buildMinimum(structures.gens, 2)) return true;
-	if (buildMinimum(structures.hqs, 1)) return true;
-	// make sure we have at least that much oils by now
-	if (buildMinimumDerricks(5)) return true;
-	// support hover maps
-	var ret = scopeRatings();
-	if (ret.land === 0 && !iHaveHover())
-		if (buildMinimum(structures.labs, 4)) return true;
-	if (ret.land === 0 && ret.sea === 0 && !iHaveVtol())
-		if (buildMinimum(structures.labs, 4)) return true;
-	if (gameTime > 300000) {
-		// build more factories and labs when we have enough income
-		if (buildMinimum(structures.labs, derrickCount / 3)) return true;
-		if (needFastestResearch() === PROPULSIONUSAGE.GROUND) {
-			if (buildMinimum(structures.factories, 2)) return true;
-			if (scopeRatings().land > 0)
-				if (buildMinimum(structures.templateFactories, 1)) return true;
-		}
-		if (buildMinimum(structures.vtolFactories, 1)) return true;
-		return false;
-	}
-	// support hover maps
-	var ret = scopeRatings();
-	if (ret.land === 0 && !iHaveHover())
-		if (buildMinimum(structures.labs, 4)) return true;
-	if (ret.land === 0 && ret.sea === 0 && !iHaveVtol())
-		if (buildMinimum(structures.labs, 4)) return true;
-	return true;
-}
diff --git a/data/mp/multiplay/skirmish/nb_generic.js b/data/mp/multiplay/skirmish/nb_generic.js
deleted file mode 100644
index d365fde..0000000
--- a/data/mp/multiplay/skirmish/nb_generic.js
+++ /dev/null
@@ -1,160 +0,0 @@
-
-/*
- * This file defines a standard AI personality for the base game. 
- * 
- * It relies on ruleset definition in /rulesets/ to provide
- * standard strategy descriptions and necessary game stat information.
- * 
- * Then it passes control to the main code.
- * 
- */
-
-// You can redefine these paths when you make a customized AI
-// for a map or a challenge.
-NB_PATH = "/multiplay/skirmish/";
-NB_INCLUDES = NB_PATH + "nb_includes/";
-NB_RULESETS = NB_PATH + "nb_rulesets/";
-NB_COMMON = NB_PATH + "nb_common/";
-
-// please don't touch this line
-include(NB_INCLUDES + "_head.js");
-
-////////////////////////////////////////////////////////////////////////////////////////////
-// Start the actual personality definition
-
-// the rules in which this personality plays
-include(NB_RULESETS + "standard.js");
-include(NB_COMMON + "standard_build_order.js");
-
-// variables defining the personality
-var subpersonalities = {
-	MR: {
-		chatalias: "mr",
-		weaponPaths: [ // weapons to use; put late-game paths below!
-			weaponStats.rockets_AT, 
-			weaponStats.machineguns, 
-			weaponStats.rockets_AS, 
-			weaponStats.rockets_AA, 
-			weaponStats.rockets_Arty,
-		],
-		earlyResearch: [ // fixed research path for the early game
-			"R-Wpn-MG-Damage01",
-			"R-Defense-Tower01",
-			"R-Vehicle-Prop-Halftracks",
-			"R-Struc-PowerModuleMk1",
-			"R-Wpn-MG-Damage03",
-		],
-		minTanks: 1, // minimal attack force at game start
-		becomeHarder: 3, // how much to increase attack force every 5 minutes
-		maxTanks: 16, // maximum for the minTanks value (since it grows at becomeHarder rate)
-		minTrucks: 2, // minimal number of trucks around
-		minHoverTrucks: 3, // minimal number of hover trucks around
-		maxSensors: 1, // number of mobile sensor cars to produce
-		minMiscTanks: 1, // number of tanks to start harassing enemy
-		maxMiscTanks: 2, // number of tanks used for defense and harass
-		vtolness: 65, // the chance % of not making droids when adaptation mechanism chooses vtols
-		defensiveness: 65, // same thing for defenses; set this to 100 to enable turtle AI specific code
-		maxPower: 700, // build expensive things if we have more than that
-		repairAt: 50, // how much % healthy should droid be to join the attack group instead of repairing
-	},
-	MC: {
-		chatalias: "mc",
-		weaponPaths: [
-			weaponStats.cannons, 
-			weaponStats.machineguns, 
-			weaponStats.mortars,
-			weaponStats.cannons_AA,
-		],
-		earlyResearch: [
-			"R-Wpn-MG-Damage01",
-			"R-Vehicle-Prop-Halftracks",
-			"R-Wpn-Cannon1Mk1",
-			"R-Struc-PowerModuleMk1",
-			"R-Wpn-MG-Damage03",
-		],
-		minTanks: 1, becomeHarder: 3, maxTanks: 16,
-		minTrucks: 3, minHoverTrucks: 4, maxSensors: 1,
-		minMiscTanks: 1, maxMiscTanks: 2,
-		vtolness: 65, defensiveness: 65,
-		maxPower: 700,
-		repairAt: 50,
-	},
-	FR: {
-		chatalias: "fr",
-		weaponPaths: [
-			weaponStats.rockets_AT, 
-			weaponStats.flamers,
-			weaponStats.fireMortars,
-			weaponStats.rockets_AA,
-			weaponStats.lasers,
-		],
-		earlyResearch: [
-			"R-Wpn-Flamer-ROF01",
-			"R-Vehicle-Prop-Halftracks",
-			"R-Struc-PowerModuleMk1",
-		],
-		minTanks: 1, becomeHarder: 3, maxTanks: 16,
-		minTrucks: 3, minHoverTrucks: 4, maxSensors: 1,
-		minMiscTanks: 1, maxMiscTanks: 2,
-		vtolness: 65, defensiveness: 65,
-		maxPower: 700,
-		repairAt: 50,
-	},
-	FC: {
-		chatalias: "fc",
-		weaponPaths: [
-			weaponStats.cannons, 
-			weaponStats.flamers, 
-			weaponStats.fireMortars,
-			weaponStats.cannons_AA,
-			weaponStats.lasers,
-		],
-		earlyResearch: [
-			"R-Wpn-Flamer-ROF01",
-			"R-Vehicle-Prop-Halftracks",
-			"R-Wpn-Cannon1Mk1",
-			"R-Struc-PowerModuleMk1",
-		],
-		minTanks: 1, becomeHarder: 3, maxTanks: 16,
-		minTrucks: 3, minHoverTrucks: 4, maxSensors: 1,
-		minMiscTanks: 1, maxMiscTanks: 2,
-		vtolness: 65, defensiveness: 65,
-		maxPower: 700,
-		repairAt: 50,
-	},
-};
-
-// this function describes the early build order
-// you can rely on personality.chatalias for choosing different build orders for
-// different subpersonalities
-function buildOrder() {
-	// Only use this build order in early game, on standard difficulty, in T1 no bases.
-	// Otherwise, fall back to the safe build order.
-	if (gameTime > 300000 || difficulty === INSANE
-	                      || isStructureAvailable("A0ComDroidControl") || baseType !== CAMP_CLEAN)
-		return buildOrder_StandardFallback();
-	if (personality.chatalias === "fc" || personality.chatalias == "fr") {
-		if (buildMinimum(structures.labs, 1)) return true;
-		if (buildMinimum(structures.factories, 1)) return true;
-		if (buildMinimum(structures.labs, 2)) return true;
-		if (buildMinimum(structures.factories, 2)) return true;
-		if (buildMinimumDerricks(2)) return true;
-		if (buildMinimum(structures.hqs, 1)) return true;
-		if (buildMinimum(structures.gens, 2)) return true;
-	} else {
-		if (buildMinimum(structures.factories, 2)) return true;
-		if (buildMinimumDerricks(1)) return true;
-		if (buildMinimum(structures.labs, 1)) return true;
-		if (buildMinimum(structures.hqs, 1)) return true;
-		if (buildMinimum(structures.factories, 3)) return true;
-		if (buildMinimum(structures.gens, 2)) return true;
-	}
-	return captureSomeOil();
-}
-
-
-
-////////////////////////////////////////////////////////////////////////////////////////////
-// Proceed with the main code
-
-include(NB_INCLUDES + "_main.js");
diff --git a/data/mp/multiplay/skirmish/nb_generic.json b/data/mp/multiplay/skirmish/nb_generic.json
deleted file mode 100644
index c3c5636..0000000
--- a/data/mp/multiplay/skirmish/nb_generic.json
+++ /dev/null
@@ -1,7 +0,0 @@
-{
-    "AI": {
-        "js": "nb_generic.js",
-        "name": "NullBot",
-        "tip": "NullBot - an adaptive skirmish AI"
-    }
-}
diff --git a/data/mp/multiplay/skirmish/nb_hover.js b/data/mp/multiplay/skirmish/nb_hover.js
deleted file mode 100644
index 1c0c4c3..0000000
--- a/data/mp/multiplay/skirmish/nb_hover.js
+++ /dev/null
@@ -1,103 +0,0 @@
-
-/*
- * This file defines a standard AI personality for the base game. 
- * 
- * It relies on ruleset definition in /rulesets/ to provide
- * standard strategy descriptions and necessary game stat information.
- * 
- * Then it passes control to the main code.
- * 
- */
-
-// You can redefine these paths when you make a customized AI
-// for a map or a challenge.
-NB_PATH = "/multiplay/skirmish/";
-NB_INCLUDES = NB_PATH + "nb_includes/";
-NB_RULESETS = NB_PATH + "nb_rulesets/";
-NB_COMMON = NB_PATH + "nb_common/";
-
-// please don't touch this line
-include(NB_INCLUDES + "_head.js");
-
-////////////////////////////////////////////////////////////////////////////////////////////
-// Start the actual personality definition
-
-// the rules in which this personality plays
-include(NB_RULESETS + "standard.js");
-include(NB_COMMON + "standard_build_order.js");
-
-// variables defining the personality
-var subpersonalities = {
-	R: {
-		chatalias: "r",
-		weaponPaths: [ // weapons to use; put late-game paths below!
-			weaponStats.rockets_AT,
-			weaponStats.rockets_AS,
-			weaponStats.rockets_AA,
-			weaponStats.rockets_Arty,
-		],
-		earlyResearch: [ // fixed research path for the early game
-			"R-Sys-Engineering01",
-			"R-Struc-Research-Module",
-			"R-Wpn-Rocket05-MiniPod",
-			"R-Vehicle-Prop-Hover",
-			"R-Wpn-Rocket02-MRL",
-			"R-Vehicle-Body05",
-			"R-Vehicle-Prop-Halftracks",
-			"R-Wpn-Rocket-ROF01",
-			"R-Struc-RepairFacility",
-			"R-Defense-MRL",
-			"R-Defense-Pillbox06",
-			"R-Vehicle-Body11",
-			"R-Wpn-Rocket-ROF02",
-			"R-Struc-RprFac-Upgrade01",
-			"R-Defense-WallTower06",
-		],
-		minTanks: 5, // minimal attack force at game start
-		becomeHarder: 2, // how much to increase attack force every 5 minutes
-		maxTanks: 16, // maximum for the minTanks value (since it grows at becomeHarder rate)
-		minTrucks: 1, // minimal number of trucks around
-		minHoverTrucks: 4, // minimal number of hover trucks around
-		maxSensors: 1, // number of mobile sensor cars to produce
-		minMiscTanks: 1, // number of tanks to start harassing enemy
-		maxMiscTanks: 3, // number of tanks used for defense and harass
-		vtolness: 75, // the chance % of not making droids when adaptation mechanism chooses vtols
-		defensiveness: 75, // same thing for defenses; set this to 100 to enable turtle AI specific code
-		maxPower: 2500, // build expensive things if we have more than that
-		repairAt: 60, // how much % healthy should droid be to join the attack group instead of repairing
-	},
-};
-
-// this function describes the early build order
-// you can rely on personality.chatalias for choosing different build orders for
-// different subpersonalities
-function buildOrder() {
-	// HACK: Tweak the rocket path a bit.
-	personality.weaponPaths[0].weapons = [
-		{ res: "R-Wpn-Rocket02-MRL", stat: "Rocket-MRL", weight: WEIGHT.MEDIUM }, // mra
-		{ res: "R-Wpn-Rocket01-LtAT", stat: "Rocket-LtA-T", weight: WEIGHT.MEDIUM }, // lancer
-		{ res: "R-Wpn-Rocket07-Tank-Killer", stat: "Rocket-HvyA-T", weight: WEIGHT.MEDIUM }, // tk
-		{ res: "R-Wpn-Missile2A-T", stat: "Missile-A-T", weight: WEIGHT.MEDIUM }, // scourge
-		{ res: "R-Wpn-MdArtMissile", stat: "Missile-MdArt", weight: WEIGHT.HEAVY }, // seraph
-	];
-	// Only use this build order in early game, on standard difficulty, in T1 no bases.
-	// Otherwise, fall back to the safe build order.
-	if (gameTime > 720000 || difficulty === INSANE
-	                      || isStructureAvailable("A0ComDroidControl") || baseType !== CAMP_CLEAN)
-		return buildOrder_StandardFallback();
-	if (buildMinimum(structures.labs, 2)) return true;
-	if (buildMinimum(structures.factories, 1)) return true;
-	if (buildMinimum(structures.labs, 3)) return true;
-	if (buildMinimum(structures.gens, 1)) return true;
-	if (buildMinimumDerricks(2)) return true;
-	if (buildMinimum(structures.labs, 4)) return true;
-	if (buildMinimum(structures.hqs, 1)) return true;
-	return captureSomeOil();
-}
-
-
-
-////////////////////////////////////////////////////////////////////////////////////////////
-// Proceed with the main code
-
-include(NB_INCLUDES + "_main.js");
diff --git a/data/mp/multiplay/skirmish/nb_hover.json b/data/mp/multiplay/skirmish/nb_hover.json
deleted file mode 100644
index a8db85f..0000000
--- a/data/mp/multiplay/skirmish/nb_hover.json
+++ /dev/null
@@ -1,7 +0,0 @@
-{
-    "AI": {
-        "js": "nb_hover.js",
-        "name": "Hover AI",
-        "tip": "An AI specially tweaked for sea maps, based on NullBot"
-    }
-}
diff --git a/data/mp/multiplay/skirmish/nb_includes/_events.js b/data/mp/multiplay/skirmish/nb_includes/_events.js
deleted file mode 100644
index 156a655..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/_events.js
+++ /dev/null
@@ -1,105 +0,0 @@
-
-/*
- * This file includes event definitions only.
- * 
- */
-
-function eventStartLevel() {
-	queue("setTimers", me * 100);
-	if (alliancesType === ALLIANCES_TEAMS) {
-		// initialize subpersonality pseudo-randomly here
-		// to make sure teammates have the same personality
-		var j = 1, s = 0;
-		for (var i = 0; i < maxPlayers; ++i) {
-			if (allianceExistsBetween(me, i))
-				s += j;
-			j *= 2;
-		}
-		// the random "s" number obtained here is the same for all players in any team
-		var s = s + (new Date()).getMinutes();
-		j = 0;
-		for (var i in subpersonalities) // count the amount of subpersonalities
-			++j;
-		s = s % j;
-		j = 0;
-		for (var i in subpersonalities) {
-			if (j === s)
-				personality = subpersonalities[i];
-			++j;
-		}
-	} else {
-		// if teams are not sharing research, or there are no teams at all,
-		// initialize the subpersonality randomly and don't care
-		personality = randomItem(subpersonalities);
-	}
-	// the following code is necessary to avoid some strange game bug when droids that 
-	// are initially buried into the ground fail to move out of the way when a building 
-	// is being placed right above them
-	enumTrucks().forEach(function(droid) {
-		orderDroidLoc(droid, DORDER_MOVE, droid.x + random(3) - 1, droid.y + random(3) - 1);
-	});
-}
-
-function eventDroidBuilt(droid, structure) {
-	groupDroid(droid);
-}
-
-function eventStructureBuilt(structure) {
-	queue("checkConstruction");
-}
-
-function eventAttacked(victim, attacker) {
-	if (attacker === null)
-		return; // no idea why it happens sometimes
-	if (isAlly(attacker.player))
-		return; // don't respond to accidental friendly fire
-	if (victim.type === DROID) {
-		if (!isVTOL(victim) && defined(victim.group)) {
-			fallBack(victim, attacker);
-			setTarget(attacker, victim.group);
-			touchGroup(victim.group);
-		} else if (isVTOL(victim) && victim.player == me && !throttled(5000, victim.id)) {
-			orderDroidObj(victim, DORDER_ATTACK, attacker);
-			pushVtols(attacker);
-		}
-	} else if (victim.type === STRUCTURE) {
-		if (throttled(5000) && victim.player != me)
-			return;
-		if (inPanic())
-			for (var i = 0; i < MAX_GROUPS; ++i)
-				if (groupSize(i) > 0)
-					setTarget(attacker, i);
-		setTarget(attacker, miscGroup);
-		setTarget(attacker);
-	}
-}
-
-function eventStructureReady(structure) {
-	fireLassat(structure);
-}
-
-function eventChat(from, to, message) {
-	// we are not case-sensitive
-	message = message.toLowerCase();
-    handleChatMessage(from, to, message)
-}
-
-function eventObjectTransfer(object, from) {
-	if (object.player !== me)
-		return; // object was transferred from me, not to me
-	if (object.type === DROID)
-		groupDroid(object);
-}
-
-function eventBeacon(x, y, from, to) {
-	noticeBeacon(x, y, from);
-}
-
-function eventBeaconRemoved(from, to) {
-	unnoticeBeacon(from);
-}
-
-function eventDestroyed(object) {
-	if (isEnemy(object.player))
-		pushVtols(object);
-}
diff --git a/data/mp/multiplay/skirmish/nb_includes/_head.js b/data/mp/multiplay/skirmish/nb_includes/_head.js
deleted file mode 100644
index 75df8ef..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/_head.js
+++ /dev/null
@@ -1,107 +0,0 @@
-
-/*
- * This file defines generic things that should be defined
- * prior to defining a ruleset. 
- * 
- * NOTE: This file is not included from main.js .
- * 
- */
-
-// weapon path role
-const ROLE = {
-	AT: 0, 
-	AP: 1, 
-	AS: 2, 
-	AA: 3,
-	LENGTH: 4, // number of items in this enum
-}
-
-// something dual to the previous enum
-const OBJTYPE = {
-	TANK: 0,
-	BORG: 1,
-	DEFS: 2,
-	VTOL: 3,
-	LENGTH: 4, // number of items in this enum; should be equal to ROLE.LENGTH
-}
-
-// this controls body and weapon compatibility.
-// A little explanation:
-// w \ b | L | M | H  bodies can't be "ultra-", 
-//    UL | + | - | -  ultra-light weapons are for light bodies only,
-//     L | + | + | -  light weapons are for light or medium bodies,
-//     M | + | + | +  medium weapons are for all bodies,
-//     H | - | + | +  heavy weapons are for medium or heavy bodies,
-//    UH | - | - | +  ultra-heavy weapons are for heavy bodies only.
-const WEIGHT = {
-	ULTRALIGHT: 0,
-	LIGHT: 1, 
-	MEDIUM: 2, 
-	HEAVY: 3, 
-	ULTRAHEAVY: 4,
-}
-
-// what to use this defensive structure for
-const DEFROLE = {
-	STANDALONE: 0,
-	GATEWAY: 1,
-	ARTY: 2,
-	ANTIAIR: 3,
-	FORTRESS: 4,
-}
-
-// return values of build order calls
-const BUILDRET = {
-	SUCCESS: 0,
-	UNAVAILABLE: 1,
-	FAILURE: 2,
-}
-
-// should we execute a build call in an unsafe location?
-const IMPORTANCE = {
-	PEACETIME: 0,
-	MANDATORY: 1,
-}
-
-// aspects of every research path
-const RESASPECTS = {
-	WEAPONS: 0,
-	DEFENSES: 1,
-	VTOLS: 2,
-	EXTRAS: 3,
-	LENGTH: 4, // number of items in this enum
-}
-
-const PROPULSIONUSAGE = {
-    GROUND : 1,
-    HOVER: 2,
-    VTOL: 4
-}
-
-// what to use this body for? (bit field)
-const BODYUSAGE = {
-	GROUND: 1, // for tanks
-	AIR: 2, // for VTOLs
-	COMBAT: 3, // GROUND | AIR
-	TRUCK: 4, // trucks, sensors and repair droids
-	UNIVERSAL: 7, // COMBAT | TRUCK
-}
-
-// what sort of weapons this body is resistant to?
-const BODYCLASS = {
-	KINETIC: 1,
-	THERMAL: 2,
-}
-
-// should this module be prioritized when not having enough power?
-const MODULECOST = {
-	CHEAP: 0,
-	EXPENSIVE: 1,
-}
-
-// how to micromanage tanks with this sort of weapon
-const MICRO = {
-	RANGED: 0, // normal weapons, such as cannons
-	MELEE: 1, // weapons that need to get very close to the enemy, such as flamers
-	DUMB: 2, // weapons that can't fire while moving
-}
diff --git a/data/mp/multiplay/skirmish/nb_includes/_main.js b/data/mp/multiplay/skirmish/nb_includes/_main.js
deleted file mode 100644
index e7efbbd..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/_main.js
+++ /dev/null
@@ -1,26 +0,0 @@
-
-/*
- * This file connects all remaining pieces of AI code together.
- * It shouldn't contain any code itself.
- * 
- * NOTE: order matters!
- * 
- */
-
-var personality;
-
-include(NB_INCLUDES + "math.js");
-include(NB_INCLUDES + "intensity.js");
-include(NB_INCLUDES + "misc.js");
-include(NB_INCLUDES + "stats.js");
-
-include(NB_INCLUDES + "adapt.js");
-include(NB_INCLUDES + "build.js");
-include(NB_INCLUDES + "research.js");
-include(NB_INCLUDES + "produce.js");
-include(NB_INCLUDES + "tactics.js");
-include(NB_INCLUDES + "lassat.js");
-include(NB_INCLUDES + "chat.js");
-
-include(NB_INCLUDES + "timers.js");
-include(NB_INCLUDES + "_events.js");
diff --git a/data/mp/multiplay/skirmish/nb_includes/adapt.js b/data/mp/multiplay/skirmish/nb_includes/adapt.js
deleted file mode 100644
index 3c05501..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/adapt.js
+++ /dev/null
@@ -1,484 +0,0 @@
-
-/*
- * This file is responsible for the adaptation system. It gathers statistics about 
- * player choices and regulates the AI's choices accordingly.
- * 
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-function adaptVote(our, their, verbose) {
-	if (!defined(verbose))
-		verbose = false;
-	var l = our.length;
-	var ourTotal = our.reduce(function(prev, curr) { return prev + curr; });
-	var theirTotal = their.reduce(function(prev, curr) { return prev + curr; });
-	if (theirTotal === 0)
-		return verbose ? randomUnitArray(l) : random(l);
-	var rating = [];
-	for (var i = 0; i < l; ++i)
-		rating[i] = their[i] / theirTotal;
-	if (ourTotal > 0)
-		for (var i = 0; i < l; ++i)
-			rating[i] -= our[i] / ourTotal;
-	if (verbose)
-		return rating.map(function(val) { return (val + 1) / 2; });
-	var maxRating = -Infinity;
-	var maxIdx = 0;
-	for (var i = 0; i < l; ++i) 
-		if (rating[i] > maxRating) {
-			maxRating = rating[i];
-			maxIdx = i;
-		}
-	return maxIdx;
-}
-
-//
-// here be functions for gathering player statistics
-//
-
-function SimpleStat() {
-	// propulsion classes used by the player
-	this.obj = zeroArray(ROLE.LENGTH);
-	// weapon-propulsion classes used by the player
-	this.role = zeroArray(ROLE.LENGTH);
-	// armor used by the player
-	this.kbody = 0;
-	this.tbody = 0;
-	// weapon-armor classes used by the player
-	this.kweapon = 0;
-	this.tweapon = 0;
-}
-
-function addStat(to, what, weight) {
-	if (!defined(weight))
-		weight = 1;
-	for (var prop in to) {
-		if (to[prop].constructor === Array)
-			for (var i = 0; i < to[prop].length; ++i) 
-				to[prop][i] += what[prop][i] * weight;
-		else
-			to[prop] += what[prop] * weight;
-	}
-}
-
-const SCOPES = {
-	land: 0,
-	sea: 0,
-	air: 0,
-}
-
-function ScopeStat() {
-	// simple stats by scopes
-	this.land = new SimpleStat();
-	this.sea = new SimpleStat();
-	this.air = new SimpleStat();
-	// a function to convert this sort of stat to a SimpleStat
-	this.collapse = function() {
-		var ret = new SimpleStat();
-		for (var i in SCOPES)
-			addStat(ret, this[i]);
-		return ret;
-	}
-}
-
-function EnemyStat() {
-	// separate stats for defense and offense
-	this.defense = new ScopeStat();
-	this.offense = new SimpleStat();
-	// a function to convert this sort of stat to a SimpleStat
-	this.collapse = function() {
-		var ret = new SimpleStat();
-		addStat(ret, this.defense.collapse());
-		addStat(ret, this.offense);
-		return ret;
-	}
-}
-
-function MyStat() {
-	// separate stats for defense and offense
-	this.defense = new SimpleStat();
-	this.offense = new ScopeStat();
-	// a function to convert this sort of stat to a SimpleStat
-	this.collapse = function() {
-		var ret = new SimpleStat();
-		addStat(ret, this.defense);
-		addStat(ret, this.offense.collapse());
-		return ret;
-	}
-}
-
-var enemyStats = [], enemyStatsTemp = [];
-for (var i = 0; i < maxPlayers; ++i) {
-	enemyStats[i] = new EnemyStat;
-	enemyStatsTemp[i] = new EnemyStat;
-}
-
-var myStats = new MyStat;
-var myStatsTemp = new MyStat;
-
-var stack = [];
-var MAX_PER_CYCLE = 20;
-
-function canReachBy(scope, location) {
-	switch (scope) {
-		case "land":
-			return canReachFromBase(getPropulsionStatsComponents(PROPULSIONUSAGE.GROUND).last(), location);
-		case "sea":
-			return canReachFromBase(getPropulsionStatsComponents(PROPULSIONUSAGE.HOVER).last(), location);
-		case "air":
-			return canReachFromBase(getPropulsionStatsComponents(PROPULSIONUSAGE.AIR).last(), location);
-	}
-}
-
-// works with stored droid objects too!
-function threatensBase(droid) {
-	if (isAlly(droid.player))
-		return false;
-	return canReachFromBase(droid.propulsion, droid.x, droid.y);
-}
-
-// count target structures reachable by land
-function countLandTargets(player) {
-	function uncached() {
-		var currProp = getPropulsionStatsComponents(PROPULSIONUSAGE.GROUND).last();
-		if (!defined(currProp)) 
-			return 0;
-		var list = enumStructList(targets, player);
-		return list.filter(function(struct) {
-			return canReachFromBase(currProp, struct);
-		}).length;
-	}
-	return cached(uncached, 5000, player);
-}
-
-// count target structures reachable by sea but not by land
-function countSeaTargets(player) {
-	function uncached() {
-		var currProp = getPropulsionStatsComponents(PROPULSIONUSAGE.HOVER)[0];
-		if (!defined(currProp)) 
-			return 0;
-        var prevProp = getPropulsionStatsComponents(PROPULSIONUSAGE.GROUND)[0];
-		return enumStructList(targets, player).filter(function(struct) {
-			return (!defined(prevProp) || !canReachFromBase(prevProp, struct)) && canReachFromBase(currProp, struct);
-		}).length;
-	}
-	return cached(uncached, 5000, player);
-}
-
-// count target structures reachable by air but not by land or by sea
-function countAirTargets(player) {
-	function uncached() {
-		var currProp = getPropulsionStatsComponents(PROPULSIONUSAGE.VTOL)[0];
-		if (!defined(currProp)) 
-			return 0;
-		var prevProp = getPropulsionStatsComponents(PROPULSIONUSAGE.GROUND|PROPULSIONUSAGE.HOVER)[0];
-		return enumStructList(targets, player).filter(function(struct) {
-			return (!defined(prevProp) || !canReachFromBase(prevProp, struct)) && canReachFromBase(currProp, struct);
-		}).length;
-	}
-	return cached(uncached, 5000, player);
-}
-
-// TODO: this function needs to be updated once more object properties
-// become available for the API to use.
-function classifyObject(obj) {
-	var ret = new SimpleStat();
-	if (obj.type === STRUCTURE && obj.stattype !== DEFENSE)
-		return ret;
-	if (obj.type === DROID && obj.droidType !== DROID_WEAPON && obj.droidType !== DROID_CYBORG)
-		return ret;
-	if (obj.type === FEATURE)
-		return ret;
-	for (var i = 0; i < obj.weapons.length; ++i) {
-		var roles = guessWeaponRole(obj.weapons[i].name); {
-			if (!defined(roles)) {
-				if (obj.canHitAir && obj.canHitGround)
-					ret.role.addArray([1/4, 1/4, 1/4, 1/4]);
-				else if (obj.canHitAir && !obj.canHitGround)
-					ret.role.addArray([0, 0, 0, 1]);
-				else
-					ret.role.addArray([1/3, 1/3, 1/3, 0]);
-			} else
-				ret.role.addArray(roles);
-		}
-	}
-	for (var i = 0; i < obj.weapons.length; ++i) {
-		if (getWeaponInfo(obj.weapons[i].name).impactClass === "KINETIC")
-			ret.kweapon += 1;
-		else
-			ret.tweapon += 1;
-	}
-	if (obj.type === STRUCTURE || (obj.type === DROID && safeIsVtol(obj)))
-		ret.tbody += 1;
-	else if (obj.type === DROID && obj.droidType === DROID_CYBORG)
-		ret.kbody += 1;
-	else {
-		switch (guessBodyArmor(obj.body)) {
-			case BODYCLASS.KINETIC:
-				ret.kbody += 1;
-				break;
-			case BODYCLASS.THERMAL:
-				ret.tbody += 1;
-				break;
-			default:
-				ret.tbody += 1 / 2;
-				ret.kbody += 1 / 2;
-		}
-	}
-	if (obj.type === STRUCTURE)
-		ret.obj[OBJTYPE.DEFS] += 1;
-	if (obj.type === DROID) {
-		if (safeIsVtol(obj))
-			ret.obj[OBJTYPE.VTOL] += 1;
-		else if (obj.droidType === DROID_CYBORG)
-			ret.obj[OBJTYPE.BORG] += 1;
-		else 
-			ret.obj[OBJTYPE.TANK] += 1;
-	}
-	return ret;
-}
-
-function summUpEnemyObject(obj, stat) {
-	var ret = classifyObject(obj);
-	var w = obj.cost;
-	if (obj.type === STRUCTURE) {
-		for (var scope in SCOPES)
-			if (canReachBy(scope, obj)) // structures don't move, so they are usually counted as defense
-				addStat(stat.defense[scope], ret, w);
-		if (obj.range > baseScale * 2) // unless they're covering the whole map with their range
-			addStat(stat.offense, ret, w);
-	}
-	if (obj.type === DROID) {
-		for (var scope in SCOPES) 
-			if (canReachBy(scope, obj)) // if the droid can't reach your base, we count it as defense only
-				addStat(stat.defense[scope], ret, w);
-		if (threatensBase(obj)) // otherwise count them as offense as well
-			addStat(stat.offense, ret, w);
-	}
-}
-
-function summUpMyObject(obj, stat) {
-	var ret = classifyObject(obj);
-	var w = obj.cost;
-	if (obj.type === STRUCTURE) {
-		addStat(stat.defense, ret, w);
-		if (obj.range > baseScale * 2) 
-			for (var scope in SCOPES)
-				addStat(stat.offense[scope], ret, w);
-	}
-	if (obj.type === DROID) {
-		if (obj.group === miscGroup)
-			addStat(stat.defense, ret, w);
-		var list = enumLivingPlayers();
-		list.forEach(function(p) {
-			if (isEnemy(p)) {
-				if (countLandTargets(p) > 0)
-					addStat(stat.offense.land, ret, w / list.length);
-				if (countSeaTargets(p) > 0)
-					addStat(stat.offense.sea, ret, w / list.length);
-				if (countAirTargets(p) > 0)
-					addStat(stat.offense.air, ret, w / list.length);
-			}
-		});
-	}
-}
-
-_global.adaptCycle = function() {
-	if (!defined(adaptCycle.player))
-		adaptCycle.player = me;
-	if (!defined(adaptCycle.phase))
-		adaptCycle.phase = 0;
-	if (stack.length > 0) {
-		var items = MAX_PER_CYCLE;
-		if (items > stack.length)
-			items = stack.length;
-		for (var i = 0; i < items; ++i) {
-			var obj = stack.pop();
-			if (isEnemy(adaptCycle.player))
-				summUpEnemyObject(obj, enemyStatsTemp[adaptCycle.player]);
-			else if (adaptCycle.player === me)
-				summUpMyObject(obj, myStatsTemp);
-		}
-		return;
-	}
-	++adaptCycle.phase;
-	switch(adaptCycle.phase) {
-		case 1:
-			stack = enumStruct(adaptCycle.player, DEFENSE);
-			return;
-		case 2:
-			stack = enumDroid(adaptCycle.player, DROID_WEAPON);
-			return;
-		case 3:
-			stack = enumDroid(adaptCycle.player, DROID_CYBORG);
-			return;
-	}
-	if (adaptCycle.player === me) {
-		myStats = myStatsTemp;
-		myStatsTemp = new MyStat;
-	} else {
-		enemyStats[adaptCycle.player] = enemyStatsTemp[adaptCycle.player];
-		enemyStatsTemp[adaptCycle.player] = new EnemyStat;
-	}
-	do {
-		++adaptCycle.player;
-		if (adaptCycle.player >= maxPlayers)
-			adaptCycle.player = 0;
-	} while (adaptCycle.player !== me && !isEnemy(adaptCycle.player));
-	adaptCycle.phase = 0;
-}
-
-function getMyGroupInfo(gr) {
-	var ret = new MyStat();
-	enumGroup(gr).forEach(function(obj) { summUpMyObject(obj, ret); });
-	return ret;
-}
-
-//
-// here be functions for querying statistics gathered above
-// and making adaptive decisions
-//
-
-function groupOurs(gr) {
-	function uncached() {
-		if (defined(gr))
-			return getMyGroupInfo(gr).collapse();
-		else
-			return myStats.collapse();
-	}
-	return cached(uncached, 500, gr);
-}
-
-function groupAttackOurs(gr) {
-	function uncached() {
-		if (defined(gr))
-			return getMyGroupInfo(gr).collapse();
-		else
-			return myStats.offense.collapse();
-	}
-	return cached(uncached, 500, gr);
-}
-
-function enemyOffense() {
-	var theirs = new SimpleStat();
-	enumLivingPlayers().filter(isEnemy).forEach(function(p) {
-		addStat(theirs, enemyStats[p].offense);
-	});
-	return theirs;
-}
-
-function groupTheirs(gr) {
-	function uncached() {
-		if (defined(gr)) {
-			if (gr === miscGroup)
-				return enemyOffense();
-			else
-				return enemyStats[gr].collapse();
-		} else {
-			var theirs = new SimpleStat();
-			enumLivingPlayers().filter(isEnemy).forEach(function(p) {
-				addStat(theirs, enemyStats[p].collapse());
-			});
-			return theirs;
-		}
-	}
-	return cached(uncached, 500, gr);
-}
-
-// use this for research; 15% smooth
-_global.chooseWeaponRole = function(gr) {
-	function uncached() {
-		if (withChance(20))
-			return randomUnitArray(4);
-		return adaptVote(groupOurs(gr).role, groupTheirs(gr).obj, true);
-	}
-	return cached(uncached, 5000, gr);
-}
-
-// use this for droids and long-range arty emplacements
-_global.chooseAttackWeaponRole = function(gr) {
-	function uncached() {
-		return adaptVote(groupAttackOurs(gr).role, groupTheirs(gr).obj, true);
-	}
-	return cached(uncached, 5000, gr);
-}
-
-// use this for defenses; 15% smooth
-_global.chooseDefendWeaponRole = function() {
-	function uncached() {
-		if (withChance(20))
-			return randomUnitArray(4);
-		return adaptVote(myStats.defense.role, enemyOffense().obj, true);
-	}
-	return cached(uncached, 5000);
-}
-
-_global.chooseBodyClass = function(gr) {
-	function uncached() {
-		var our = groupAttackOurs(gr), their = groupTheirs(gr);
-		return adaptVote(
-			[ our.kbody, our.tbody ],
-			[ their.kweapon, their.tweapon ]
-		) ? BODYCLASS.THERMAL : BODYCLASS.KINETIC;
-	}
-	return cached(uncached, 5000, gr);
-}
-
-_global.chooseObjectType = function() {
-	function uncached() {
-		var our = groupOurs(), their = groupTheirs();
-		// behaviour specific for a turtle AI
-		if (personality.defensiveness === 100)
-			if (iHaveVtol() && withChance(personality.vtolness) && adaptVote(
-				[ our.obj[OBJTYPE.DEFS], our.obj[OBJTYPE.VTOL] ],
-				[ their.role[ROLE.AA], their.role[ROLE.AT] + their.role[ROLE.AP] + 2 * their.role[ROLE.AS] ]
-			) === 1)
-			return OBJTYPE.VTOL;
-		else
-			return OBJTYPE.DEFS;
-		// behaviour of a generic AI
-		if (withChance(personality.defensiveness) && adaptVote(
-				[ our.obj[OBJTYPE.TANK] + our.obj[OBJTYPE.BORG] + our.obj[OBJTYPE.VTOL], our.obj[OBJTYPE.DEFS] ],
-				[ their.role[ROLE.AS], their.role[ROLE.AT] + their.role[ROLE.AP] + their.role[ROLE.AA] ]
-			) === 1)
-			return OBJTYPE.DEFS;
-		if (iHaveVtol() && withChance(personality.vtolness) && adaptVote(
-				[ our.obj[OBJTYPE.TANK] + our.obj[OBJTYPE.BORG] + our.obj[OBJTYPE.DEFS], our.obj[OBJTYPE.VTOL] ],
-				[ their.role[ROLE.AA], their.role[ROLE.AT] + their.role[ROLE.AP] + their.role[ROLE.AS] ]
-			) === 1)
-			return OBJTYPE.VTOL;
-		return adaptVote(
-			[ our.obj[OBJTYPE.TANK], our.obj[OBJTYPE.BORG] ],
-			[ their.role[ROLE.AP], their.role[ROLE.AT] ]
-		) ? OBJTYPE.BORG : OBJTYPE.TANK;
-	}
-	return cached(uncached, 5000);
-}
-
-_global.scopeRatings = function() {
-	function uncached() {
-		var ret = { land: 0, sea: 0, air: 0 };
-		enumLivingPlayers().filter(isEnemy).forEach(function(player) {
-			ret.land += countLandTargets(player);
-			ret.sea += countSeaTargets(player);
-			ret.air += countAirTargets(player);
-		});
-		return ret;
-	}
-	return cached(uncached, 5000);
-}
-
-_global.spendMoney = function() {
-	queue("checkResearch", 100);
-	if (checkTruckProduction())
-		return; // will proceed on the next cycle
-	if (chooseObjectType() == OBJTYPE.DEFS)
-		queue("checkConstruction", 200);
-	else
-		queue("checkProduction", 300);
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_includes/build.js b/data/mp/multiplay/skirmish/nb_includes/build.js
deleted file mode 100644
index 26e750c..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/build.js
+++ /dev/null
@@ -1,376 +0,0 @@
-
-/*
- * This file describes building construction procedures.
- * 
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-function randomLocation() {
-	var x = baseLocation.x + random(baseScale) - baseScale / 2;
-	var y = baseLocation.y + random(baseScale) - baseScale / 2;
-	if (x < 3 || y < 3 || x > mapWidth - 4 || y > mapHeight - 4)
-		return baseLocation;
-	return {x: x, y: y};
-	
-}
-
-// a function for checking the presence of enemy units at the construction site
-function safeSpot(x, y) {
-	return dangerLevel({x: x, y: y}) <= 0;
-}
-
-function truckFree(truck) {
-	if (truck.droidType !== DROID_CONSTRUCT)
-		return false;
-	if (truck.order === DORDER_BUILD)
-		return false;
-	if (truck.order === DORDER_HELPBUILD)
-		return false;
-	if (truck.order === DORDER_LINEBUILD)
-		return false;
-	if (truck.order === DORDER_DEMOLISH)
-		return false;
-	return true;
-}
-
-// returns one or two free trucks
-function getTwoFreeTrucks() {
-	var trucks = enumTrucks().filter(truckFree);
-	if (trucks.length > 2) {
-		var ret = naiveFindClusters(trucks, baseScale / 2);
-		if (ret.maxCount >= 2)
-			trucks = ret.clusters[ret.maxIdx];
-	}
-	if (trucks.length > 2)
-		trucks.length = 2;
-	return trucks;
-}
-
-function getFreeTruckAround(x, y) {
-	var list = enumTrucks().filter(truckFree).filter(function(droid) { 
-		return droidCanReach(droid, x, y); 
-	}).sort(function(one, two) {
-		return distance(one, x, y) - distance(two, x, y);
-	});
-	if (list.length > 0)
-		return list[0];
-}
-
-function buildModule(struct) {
-	trucks = getTwoFreeTrucks();
-	if (trucks.length <= 0)
-		return BUILDRET.FAILURE;
-	var moduleInfo = modules.filter(function(item) { return isAvailable(item.module) && item.base === struct.stattype; }).last();
-	if (!defined(moduleInfo))
-		return BUILDRET.UNAVAILABLE;
-	if (struct.modules >= moduleInfo.count)
-		return BUILDRET.UNAVAILABLE;
-	var success = false;
-	for (var i = 0; i < trucks.length; ++i) 
-		success = orderDroidBuild(trucks[i], DORDER_BUILD, moduleInfo.module, struct.x, struct.y) || success;
-	if (success)
-		return BUILDRET.SUCCESS;
-	return BUILDRET.FAILURE;
-}
-
-function buildBasicStructure(statlist, importance) {
-	if (throttled(5000, statlist[0])) return BUILDRET.FAILURE;
-	// by default, don't try building things in dangerous locations
-	if (!defined(importance))
-		importance = IMPORTANCE.MANDATORY;
-	trucks = getTwoFreeTrucks();
-	if (trucks.length <= 0)
-		return BUILDRET.FAILURE;
-	// choose structure type (out of the statlist), 
-	// together with suitable location
-	var idx, loc, avail = false;
-	for (var i = 0; i < statlist.length; ++i)
-		if (isAvailable(statlist[i])) {
-			avail = true;
-			if (distanceToBase(trucks[0]) <= baseScale)
-				loc = pickStructLocation(trucks[0], statlist[i], trucks[0].x, trucks[0].y);
-			else {
-				var rndLoc = randomLocation();
-				loc = pickStructLocation(trucks[0], statlist[i],rndLoc.x, rndLoc.y);
-			}
-			idx = i;
-			break;
-		}
-	if (!avail)
-		return BUILDRET.UNAVAILABLE;
-	if (!defined(loc))
-		return BUILDRET.FAILURE;
-	if (importance === IMPORTANCE.PEACETIME && !safeSpot(loc.x, loc.y))
-		return BUILDRET.FAILURE;
-	// now actually build
-	var success = false;
-	for (var i = 0; i < trucks.length; ++i) 
-		success = orderDroidBuild(trucks[i], DORDER_BUILD, statlist[idx], loc.x, loc.y) || success;
-	if (success)
-		return BUILDRET.SUCCESS;
-	return BUILDRET.FAILURE;
-}
-
-function finishStructures() {
-	var success = false;
-	var list = enumStruct(me).filterProperty("status", BEING_BUILT);
-	for (var i = 0; i < list.length; ++i) {
-		if (success)
-			return;
-		if (throttled(10000, list[i].id))
-			return;
-		if (list[i].stattype === RESOURCE_EXTRACTOR)
-			return;
-		var truck = getFreeTruckAround(list[i].x, list[i].y);
-		if (!defined(truck))
-			return;
-		if (orderDroidObj(truck, DORDER_HELPBUILD, list[i]))
-			success = true;
-	};
-	return success;
-}
-
-function buildStructureAround(statlist, loc, unique) {
-	if (!defined(statlist))
-		return BUILDRET.UNAVAILABLE;
-	var truck = getFreeTruckAround(loc.x, loc.y);
-	if (!defined(truck))
-		return BUILDRET.FAILURE;
-	var stat = statlist.filter(isAvailable).filter(function(s) {
-		if (unique !== true)
-			return true;
-		var list = enumStruct(me, s);
-		for (var i = 0; i < list.length; ++i)
-			if (distance(list[i], loc) < baseScale / 2)
-				return false;
-		return true;
-	}).last();
-	if (!defined(stat))
-		return BUILDRET.UNAVAILABLE;
-	var loc2 = pickStructLocation(truck, stat, loc.x, loc.y);
-	if (!defined(loc2))
-		return BUILDRET.FAILURE;
-	// if we're not into turtling, don't build too many towers
-	if (personality.defensiveness < 100 && distance(loc2, loc) > baseScale / 5)
-		return BUILDRET.FAILURE;
-	if (orderDroidBuild(truck, DORDER_BUILD, stat, loc2.x, loc2.y)) 
-		return BUILDRET.SUCCESS;
-	return BUILDRET.FAILURE;
-}
-
-function captureOil(oil) {
-	if (!defined(oil))
-		return BUILDRET.FAILURE;
-	var truck = getFreeTruckAround(oil.x, oil.y);
-	if (!defined(truck))
-		return BUILDRET.FAILURE;
-	var stat = structures.derricks.filter(isAvailable).last();
-	if (!defined(stat))
-		return BUILDRET.UNAVAILABLE;
-	if (throttled(90000, oil.y * mapWidth + oil.x))
-		return BUILDRET.FAILURE;
-	if (orderDroidBuild(truck, DORDER_BUILD, stat, oil.x, oil.y)) 
-		return BUILDRET.SUCCESS;
-	return BUILDRET.FAILURE;
-}
-
-function chooseDefense(defrole) {
-	return weaponStatsToDefenses(chooseAvailableWeaponPathByRoleRatings(getProductionPaths(), chooseDefendWeaponRole(), 2, defrole), defrole);
-}
-
-function buildTowers() {
-	var oils = enumStructList(structures.derricks);
-	if (oils.length === 0)
-		return false;
-	if (withChance(70))
-		return buildStructureAround(chooseDefense(DEFROLE.STANDALONE), oils.random()) !== BUILDRET.UNAVAILABLE;
-	return buildStructureAround(chooseDefense(DEFROLE.FORTRESS).concat(structures.sensors), oils.random(), true) !== BUILDRET.UNAVAILABLE;
-}
-
-function buildGateways() {
-	var oils = countStructList(structures.derricks);
-	if (oils <= 0)
-		return BUILDRET.FAILURE;
-	var gates = enumGateways().filter(function(gate) {
-		var l = gate.x1 - gate.x2 + gate.y1 - gate.y2;
-		if (l < 0)
-			l = -l;
-		var cnt = enumRange(gate.x1, gate.y1, l, ALLIES).filterProperty("stattype", DEFENSE).length;
-		cnt    += enumRange(gate.x2, gate.y2, l, ALLIES).filterProperty("stattype", DEFENSE).length;
-		cnt    -= enumRange(gate.x1, gate.y1, l, ENEMIES).filterProperty("stattype", DEFENSE).length;
-		cnt    -= enumRange(gate.x2, gate.y2, l, ENEMIES).filterProperty("stattype", DEFENSE).length;
-		return cnt >= 0 && (cnt < l || (personality.defensiveness === 100 && withChance(70))); // turtle AI needs to keep building towers
-	}).sort(function(one, two) { return distanceToBase({x: one.x1, y: one.y1}) - distanceToBase({x: two.x1, y: two.y1}); });
-	if (gates.length === 0)
-		return;
-	if (withChance(50))
-		return buildStructureAround(chooseDefense(DEFROLE.GATEWAY), {x: gates[0].x1, y: gates[0].y1}) !== BUILDRET.UNAVAILABLE;
-	else
-		return buildStructureAround(chooseDefense(DEFROLE.GATEWAY), {x: gates[0].x2, y: gates[0].y2}) !== BUILDRET.UNAVAILABLE;
-}
-
-function buildArty() {
-	return buildBasicStructure(chooseDefense(DEFROLE.ARTY), IMPORTANCE.PEACETIME);
-}
-
-_global.buildMinimum = function(statlist, count, importance) {
-	if (countStructList(statlist) < count)
-		if (buildBasicStructure(statlist, importance) !== BUILDRET.UNAVAILABLE)
-			return true;
-	return false;
-}
-
-_global.captureSomeOil = function() {
-	if (throttled(500))
-		return true;
-	function getOilList() {
-		var oils = [];
-		oilResources.forEach(function(stat) { oils = oils.concat(enumFeature(-1, stat)); });
-		oils = oils.concat(enumStructList(structures.derricks).filterProperty("status", BEING_BUILT));
-		oils = oils.sort(function(one, two) {
-			return distanceToBase(one) - distanceToBase(two);
-		});
-		if (oils.length > 10)
-			oils.length = 10;
-		return oils;
-	}
-	var oils = cached(getOilList, 5000);
-	if (countFinishedStructList(structures.derricks) >= 4 * structListLimit(structures.gens))
-		return false;
-	for (var i = 0; i < oils.length; ++i)
-		if (captureOil(oils[i]) === BUILDRET.SUCCESS)
-			return true;
-	return false;
-}
-
-_global.buildMinimumDerricks = function(count) {
-	if (countFinishedStructList(structures.derricks) < count)
-		if (captureSomeOil())
-			return true;
-	return false;
-}
-
-function buildExpand() {
-	if (myPower() > personality.maxPower) {
-		switch (chooseObjectType()) {
-			case 0:
-				if (needFastestResearch() === PROPULSIONUSAGE.GROUND)
-					if (buildMinimum(structures.factories, Infinity, IMPORTANCE.PEACETIME))
-						return true;
-				// fall-through
-			case 1:
-				if (needFastestResearch() === PROPULSIONUSAGE.GROUND)
-					if (buildMinimum(structures.templateFactories, Infinity, IMPORTANCE.PEACETIME))
-						return true;
-				// fall-through
-			case 3:
-				if (buildMinimum(structures.vtolFactories, Infinity, IMPORTANCE.PEACETIME))
-					return true;
-		}
-	}
-	return false;
-}
-
-function buildEnergy() {
-	var oils = countFinishedStructList(structures.derricks);
-	var gens = countStructList(structures.gens);
-	if (oils > 4 * gens)
-		if (buildBasicStructure(structures.gens, IMPORTANCE.PEACETIME) !== BUILDRET.UNAVAILABLE)
-			return true;
-	if (withChance(50))
-		if (captureSomeOil())
-			return true;
-	return false;
-}
-
-function buildModules() {
-	var str = [];
-	for (var i = 0; i < modules.length; ++i) {
-		if (modules[i].base === FACTORY && needFastestResearch() !== PROPULSIONUSAGE.GROUND)
-			continue;
-		str = enumStruct(me, modules[i].base);
-		for (var j = 0; j < str.length; ++j)
-			if (buildModule(str[j]) !== BUILDRET.UNAVAILABLE)
-				return true;
-	}
-	return false;
-}
-
-_global.buildVtols = function() {
-	if (buildMinimum(structures.vtolPads, enumDroid(me, DROID_WEAPON).filter(isVTOL).length / 2), IMPORTANCE.PEACETIME)
-		return true;
-	return false;
-}
-
-function buildExtras() {
-	if (throttled(180000))
-		return false;
-	if (buildBasicStructure(structures.extras, IMPORTANCE.PEACETIME) !== BUILDRET.UNAVAILABLE)
-		return true;
-	return false;
-}
-
-_global.buildDefenses = function() {
-	if (chooseObjectType() !== 2)
-		return false;
-	if (withChance(33)) {
-		if (buildTowers()) // includes sensor towers and forts
-			return true;
-	} else if (withChance(50)) {
-		if (buildGateways())
-			return true;
-	} else
-		if (buildArty())
-			return true;
-	return false;
-}
-
-function listOutdatedDefenses() {
-	for (var path in weaponStats) {
-		for (var role in DEFROLE) {
-			var list = weaponStatsToDefenses(weaponStats[path], DEFROLE[role]);
-			for (var i = 0; i < list.length - 2; ++i)
-				if (isAvailable(list[i + 2])) {
-					if (countStruct(list[i]) > 0)
-						return enumStruct(me, list[i]);
-				}
-		}
-	};
-	return [];
-}
-
-function recycleDefenses() {
-	var trucks = enumTrucks().filter(truckFree);
-	if (trucks.length <= 0)
-		return false;
-	var list = listOutdatedDefenses();
-	for (var i = 0; i < list.length; ++i)
-		for (var j = 0; j < trucks.length; ++j)
-			if (droidCanReach(trucks[j], list[i].x, list[i].y)) {
-				orderDroidObj(trucks[j], DORDER_DEMOLISH, list[i]);
-				return true;
-			}
-	return false;
-}
-
-_global.checkConstruction = function() {
-	if (enumTrucks().filter(truckFree).length === 0)
-		return;
-	if (functionSeries("construction", [
-		finishStructures,
-		buildOrder,
-		buildExpand,
-		buildEnergy,
-		buildModules,
-		buildVtols,
-		buildExtras,
-		recycleDefenses,
-		buildDefenses,
-	]))
-		queue("checkConstruction");
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_includes/chat.js b/data/mp/multiplay/skirmish/nb_includes/chat.js
deleted file mode 100644
index 31ea721..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/chat.js
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * This file is responsible for chat listening. It contains handler functions for different chat
- * messages; each such function takes message and player as a parameter and returns a reply string. 
- * All chat talking (such as calling for help) is coded in other places, not here.
- * 
- * Messages are marked as translatable when necessary. 
- * 
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-var prefix = '!nb';
-
-// key: name in chat, value: function that will be executed
-// function gets two params: sender and argument
-var commandMap = {
-    set: chatSet,
-    res: chatRes,
-    truck: chatTruck,
-    power: chatMoney,
-    money: chatMoney, // alias for "power"
-	help: chatHelp,
-	go: chatHelp, // alias for "help"
-	tx: chatUnhelp, 
-}
-
-var beaconInfo = [];
-
-_global.noticeBeacon = function(x, y, from) {
-	beaconInfo[from] = {
-		x: x,
-		y: y,
-		exists: 1,
-	};
-}
-
-_global.unnoticeBeacon = function(from) {
-	beaconInfo[from].exists = 0;
-}
-
-_global.findBeaconPlayer = function(x, y) {
-	for (var i = 0; i < beaconInfo.length; ++i)
-		if (defined(beaconInfo[i]) && beaconInfo[i].x === x && beaconInfo[i].y === y)
-			return i;
-}
-
-_global.handleChatMessage = function(sender, receiver, message) {
-	// don't reply on any other message coming sender enemies
-	if (message ===  "!nb who") {
-		chat(sender, chatWho(sender));
-		return;
-	}
-	if (!isAlly(sender))
-		return;
-	if (message === "help me!!") { // Try to understand Nexus AI's way of calling for help
-		chatHelp(sender);
-		return;
-	}
-	var result = message.split(/ +/);
-	if (result[0] !== prefix)
-		return;
-	var command = result[1];
-	var argument = result[2];
-	if (defined(commandMap[command]))
-		chat(sender, commandMap[command](sender, argument));
-}
-
-function chatWho(sender, argument) {
-	var str = "NullBot3 (" + scriptName + ") ";
-	switch(difficulty) {
-		case EASY: str += _("EASY"); break;
-		case MEDIUM: str=str + _("MEDIUM"); break;
-		case HARD: str=str + _("HARD"); break;
-		case INSANE: str=str + _("INSANE"); break;
-	}
-	if (isAlly(sender))
-		str += (" ~" + personality.chatalias + "~");
-	return str;
-}
-
-function chatSet(sender, argument) {
-	var str = "";
-	for (var i in subpersonalities) {
-		if (subpersonalities[i].chatalias === argument) {
-			personality = subpersonalities[i];
-			return _("Personality change successful.");
-		}
-		str = str + " " + subpersonalities[i].chatalias;
-	}
-	return _("No such personality! Try one of these:") + str;
-}
-
-function chatRes(sender, argument) {
-	if (argument === "cl") {
-		setForcedResearch(); // clear
-		return _("Forced research cleared, will research anything I want now.");
-	}
-	if (argument === "no") {
-		setForcedResearch(null); // clear
-		return _("Research blocked, will research nothing now.");
-	}
-	if (argument === "fn") {
-		setForcedResearch(fundamentalResearch);
-		return _("Researching fundamental technology.");
-	}
-	var str = " cl no fn";
-	for (var i in weaponStats) {
-		if (weaponStats[i].chatalias === argument) {
-			setForcedResearch(weaponStatsToResList(weaponStats[i]));
-			return _("Researching ") + weaponStats[i].chatalias;
-		}
-		if (weaponStats[i].chatalias.indexOf("useless") < 0)
-			str = str + " " + weaponStats[i].chatalias;
-	}
-	return _("No such research path! Try one of these:") + str;
-}
-
-function chatTruck(sender, argument) {
-	var droid = enumTrucks().random();
-	if (!defined(droid))
-		return _("Sorry, I have no trucks.");
-	if (donateObject(droid, sender)) {
-		addBeacon(droid.x, droid.y, sender);
-		return _("You can use this one.");
-	} 
-	return _("Sorry, droid transfer failed.");
-}
-
-function chatMoney(sender, argument) {
-	var power = Math.round(myPower()/3);
-	donatePower(power, sender);
-	return _("Power transferred.");
-}
-
-function chatHelp(sender, argument) {
-	if (!defined(beaconInfo[sender]) || !beaconInfo[sender].exists)
-		return _("Please put a beacon!");
-	if (setTarget({ x: beaconInfo[sender].x, y: beaconInfo[sender].y, type: POSITION }))
-		return _("Coming!");
-	else
-		return _("Sorry, I don't have any free forces to send for help!");
-}
-
-function chatUnhelp(sender, argument) {
-	unsetTarget(sender);
-	return _("Any time, big boss!");
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_includes/intensity.js b/data/mp/multiplay/skirmish/nb_includes/intensity.js
deleted file mode 100644
index 41241b7..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/intensity.js
+++ /dev/null
@@ -1,95 +0,0 @@
-
-/*
- * This file includes generic functions for improving CPU intensity,
- * like caching and throttling mechanisms.
- * 
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-// to make sure some function is not called more often than every 2 seconds, 
-// put something like that at start the of its body:
-//		if (throttled(2000)) return;
-// if your function requires several throttling cases, you can use the optional
-// notes value:
-//		if (throttled(60000, player)) return;
-// NOTE: it won't work if the function repeatedly dies and gets created again, eg.
-// a function defined inside forEach(function(...){...}) can't be throttled
-_global.throttled = function(interval, notes) {
-	if (!defined(arguments.callee.caller.throttleTimes))
-		arguments.callee.caller.throttleTimes = {};
-	if (!defined(arguments.callee.caller.throttleTimes[notes])) {
-		arguments.callee.caller.throttleTimes[notes] = gameTime;
-		return false;
-	}
-	if (gameTime - arguments.callee.caller.throttleTimes[notes] < interval)
-		return true;
-	arguments.callee.caller.throttleTimes[notes] = gameTime;
-	return false;
-}
-
-// to cache a function's output value and make sure it's not re-calculated too often,
-// use the following trick:
-//		function calculateValue(params) {
-//			function uncached(params) {
-//				// do heavy calculations
-//			}
-//			return cached(uncached, 10000);
-//		}
-// add necessary notes to the cached() call if necessary, similar to how you do it
-// for throttled().
-// NOTE: it won't work if the function repeatedly dies and gets created again, eg.
-// a function defined inside forEach(function(...){...}) can't have caching inside
-_global.cached = function(whatToCall, interval, notes) {
-	if (!defined(arguments.callee.caller.cachedTimes)) {
-		arguments.callee.caller.cachedTimes = {};
-		arguments.callee.caller.cachedValues = {};
-	}
-	var t = arguments.callee.caller.cachedTimes[notes];
-	if (!defined(t) || gameTime - t >= interval) {
-		arguments.callee.caller.cachedValues[notes] = whatToCall();
-		arguments.callee.caller.cachedTimes[notes] = gameTime;
-	}
-	return arguments.callee.caller.cachedValues[notes];
-}
-
-// if you actually want your script to send debug messages, consider using this function.
-// it will only output each message only once, so your debug log will be readable.
-_global.niceDebug = function() {
-	var msg = me + ": " + Array.prototype.join.call(arguments, " ");
-	if (throttled(Infinity, msg))
-		return;
-	debug(msg);
-}
-
-// use this if you want to split a certain void function into parts.
-// example:
-//		function first()  { return random(2); }
-//		function second() { return random(2); }
-//		function third()  { return random(2); }
-//		function doManyThings() {
-//			if (functionSeries("doStuff", [ first, second, third ]))
-//				queue("doManyThings");
-//		}
-// NOTE: in this example functions of the list don't need to be global, but
-// doManyThings does, otherwise the queue call will fail.
-_global.functionSeries = function(id, list) {
-	if (!defined(functionSeries.last))
-		functionSeries.last = {};
-	if (!defined(functionSeries.last[id]))
-		functionSeries.last[id] = 0;
-	else
-		++functionSeries.last[id];
-	if (functionSeries.last[id] >= list.length) {
-		functionSeries.last[id] = 0;
-		return false; // all functions in the list were called, none succeeded
-	}
-	if (!list[functionSeries.last[id]]())
-		return true; // none of the function succeeded yet, telling to call us again next time
-	functionSeries.last[id] = undefined;
-	return false; // one of the functions succeeded, no need to call us anymore
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_includes/lassat.js b/data/mp/multiplay/skirmish/nb_includes/lassat.js
deleted file mode 100644
index 6e5b015..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/lassat.js
+++ /dev/null
@@ -1,30 +0,0 @@
-
-/*
- * This file is responsible for incoming laser satellite strikes.
- * Relies on lassatSplash variable of the ruleset to figure out
- * the radius of lassat.
- * 
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-// pick a target and fire
-_global.fireLassat = function(structure) {
-	list = [];
-	enumLivingPlayers().filter(isEnemy).forEach(function(i) {
-		list = list.concat(enumStruct(i), enumDroid(i));
-	});
-	var maxIdx, maxPrice = 0;
-	list.forEach(function(obj, idx) {
-		var price = enumRange(obj.x, obj.y, lassatSplash / 2, ENEMIES, false).reduce(function(prev, curr) { return prev + curr.cost; }, 0);
-		if (price > maxPrice) {
-			maxPrice = price;
-			maxIdx = idx;
-		}
-	});
-	activateStructure(structure, list[maxIdx]);
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_includes/math.js b/data/mp/multiplay/skirmish/nb_includes/math.js
deleted file mode 100644
index 169398e..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/math.js
+++ /dev/null
@@ -1,149 +0,0 @@
-
-/*
- * This file includes routines and algorithms completely unrelated to Warzone 2100.
- * 
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-// return random true or false in certain chance
-// 0 will return true with chance 0% 
-// 50 will return true with chance 50%
-// 100 will return true with chance 100%
-_global.withChance = function distance(chancePercent) {
-	return 1 + random(100) <= chancePercent;
-}
-
-// Get distance between two points
-// acceptable arguments:
-//		distance(obj, obj)
-//		distance(x,y, obj)
-//		distance(obj,x,y)
-_global.distance = function distance(obj1, obj2, obj3, obj4) {
-	var x1, x2, y1, y2;
-	if (defined(obj1.x)) {
-		x1 = obj1.x;
-		y1 = obj1.y;
-		if (defined(obj2.x)) {
-			x2 = obj2.x;
-			y2 = obj2.y;
-		} else {
-			x2 = obj2;
-			y2 = obj3;
-		}
-	} else {
-		x1 = obj1;
-		y1 = obj2;
-		if (defined(obj3.x)) {
-			x2 = obj3.x;
-			y2 = obj3.y;
-		} else {
-			x2 = obj3;
-			y2 = obj4;
-		}
-	}
-	return distBetweenTwoPoints(x1, y1, x2, y2);
-}
-
-_global.defined = function(variable) {
-	return typeof(variable) !== "undefined";
-}
-
-// returns a random number between 0 and max-1 inclusively
-_global.random = function(max) {
-	if (max > 0)
-		return Math.floor(Math.random() * max);
-}
-
-// some useful array functions
-Array.prototype.random = function() {
-	if (this.length > 0)
-		return this[random(this.length)];
-}
-
-Array.prototype.last = function() {
-	if (this.length > 0)
-		return this[this.length - 1];
-}
-
-Array.prototype.filterProperty = function(property, value) {
-	return this.filter(function(element) {
-		return element[property] === value;
-	});
-}
-
-Array.prototype.someProperty = function(property, value) {
-	return this.some(function(element) {
-		return element[property] === value;
-	});
-}
-
-Array.prototype.shuffle = function() {
-	return this.sort(function() { return 0.5 - Math.random(); })
-}
-
-_global.zeroArray = function(l) {
-	var ret = [];
-	for (var i = 0; i < l; ++i)
-		ret[i] = 0;
-	return ret;
-}
-
-_global.randomUnitArray = function(l) {
-	var ret = zeroArray(l);
-	ret[random(l)] = 1;
-	return ret;
-}
-
-Array.prototype.addArray = function(arr) {
-	for (var i = 0; i < this.length; ++i)
-		this[i] += arr[i];
-}
-
-// returns a random property of an object
-_global.randomItem = function(obj) {
-    var ret;
-    var count = 0;
-    for (var i in obj)
-        if (Math.random() < 1/++count)
-           ret = i;
-    return obj[ret];
-}
-
-// cluster analysis happens here
-_global.naiveFindClusters = function(list, size) {
-	var ret = { clusters: [], xav: [], yav: [], maxIdx: 0, maxCount: 0 };
-	for (var i = list.length - 1; i >= 0; --i) {
-		var x = list[i].x, y = list[i].y;
-		var found = false;
-		for (var j = 0; j < ret.clusters.length; ++j) {
-			if (distance(ret.xav[j], ret.yav[j], x, y) < size) {
-				var n = ret.clusters[j].length;
-				ret.clusters[j][n] = list[i];
-				ret.xav[j] = (n * ret.xav[j] + x) / (n + 1);
-				ret.yav[j] = (n * ret.yav[j] + y) / (n + 1);
-				if (ret.clusters[j].length > ret.maxCount) {
-					ret.maxIdx = j;
-					ret.maxCount = ret.clusters[j].length;
-				}
-				found = true;
-				break;
-			}
-		}
-		if (!found) {
-			var n = ret.clusters.length;
-			ret.clusters[n] = [list[i]];
-			ret.xav[n] = x;
-			ret.yav[n] = y;
-			if (1 > ret.maxCount) {
-				ret.maxIdx = n;
-				ret.maxCount = 1
-			}
-		}
-	}
-	return ret;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_includes/misc.js b/data/mp/multiplay/skirmish/nb_includes/misc.js
deleted file mode 100644
index b5fbf87..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/misc.js
+++ /dev/null
@@ -1,56 +0,0 @@
-
-/*
- * A few globals that didn't have a place for them in any other file
- *
- */
-
-var baseLocation = startPositions[me];
-
-function distanceToBase(loc) {
-	return distance(loc, baseLocation);
-}
-
-function canReachFromBase(propulsion, location) {
-	if (defined(propulsion))
-		return propulsionCanReach(propulsion, baseLocation.x, baseLocation.y, location.x, location.y);
-}
-
-function myPower() {
-	return playerPower(me) - queuedPower(me);
-}
-
-function isAvailable(stat) {
-	return isStructureAvailable(stat, me);
-}
-
-function isAlly(player) {
-	return allianceExistsBetween(me, player);
-}
-
-function isEnemy(player) {
-	return !isAlly(player);
-}
-
-function enumLivingPlayers() {
-	function uncached() {
-		var ret = [];
-		for (var i = 0; i < maxPlayers; ++i) {
-			if (countStructList(targets, i) > 0) {
-				ret.push(i);
-				continue;
-			}
-			if (enumDroid(i).length > 0)
-				ret.push(i);
-		}
-		return ret;
-	};
-	return cached(uncached, 30000);
-}
-
-function enumTrucks() {
-	return enumDroid(me, DROID_CONSTRUCT);
-}
-
-function goEasy() {
-	personality = randomItem(subpersonalities);
-}
diff --git a/data/mp/multiplay/skirmish/nb_includes/produce.js b/data/mp/multiplay/skirmish/nb_includes/produce.js
deleted file mode 100644
index c2638c7..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/produce.js
+++ /dev/null
@@ -1,239 +0,0 @@
-
-/*
- * This file is responsible for droid production.
- * 
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-function ourBuildDroid(factory, name, bodies, propulsions, weapons1, weapons2, weapons3) {
-	return buildDroid(factory, name, bodies, propulsions, "", "", weapons1, weapons2, weapons3);
-}
-
-function produceTruck(factory, turrets) {
-	var turret = truckTurrets.concat();
-	if (defined(turrets))
-		turret = turrets.concat();
-	turret.reverse();
-	// TODO: switch to using chooseBodyWeaponPair() here
-	var bodies = filterBodyStatsByUsage(BODYUSAGE.TRUCK, BODYCLASS.KINETIC).map(function(val) { return val.stat; });
-	var propulsions = getPropulsionStatsComponents(PROPULSIONUSAGE.GROUND|PROPULSIONUSAGE.HOVER);
-	return ourBuildDroid(factory, "Fancy Truck", bodies, propulsions, turret);
-}
-
-function chooseWeapon(forVtol) {
-	if (!defined(forVtol))
-		forVtol = false;
-	if (forVtol) {
-		var ret = chooseAvailableWeaponPathByRoleRatings(getProductionPaths(), chooseAttackWeaponRole(), 3);
-		if (defined(ret))
-			return ret.vtols.concat().reverse();
-	} else {
-		var ret = chooseAvailableWeaponPathByRoleRatings(getProductionPaths(), chooseAttackWeaponRole(), 0);
-		if (defined(ret))
-			return ret.weapons.concat().reverse();
-	}
-}
-
-function chooseBodyWeaponPair(bodies, weapons) {
-	if (!defined(bodies))
-		return undefined;
-	if (!defined(weapons))
-		return undefined;
-	for (var i = 0; i < weapons.length; ++i) {
-		var w = weapons[i].stat, ww = weapons[i].weight;
-		if (!componentAvailable(w))
-			continue;
-		for (var j = 0; j < bodies.length; ++j) {
-			var b = bodies[j].stat, bw = bodies[j].weight;
-			if (!componentAvailable(b))
-				continue;
-			switch(ww) {
-				case WEIGHT.ULTRALIGHT:
-					if (bw <= WEIGHT.LIGHT)
-						return {b: b, w: w};
-					break;
-				case WEIGHT.LIGHT:
-					if (bw <= WEIGHT.MEDIUM)
-						return {b: b, w: w};
-					break;
-				case WEIGHT.MEDIUM:
-						return {b: b, w: w};
-					break;
-				case WEIGHT.HEAVY:
-					if (bw >= WEIGHT.MEDIUM)
-						return {b: b, w: w};
-					break;
-				case WEIGHT.ULTRAHEAVY:
-					if (bw >= WEIGHT.HEAVY)
-						return {b: b, w: w};
-					break;
-			}
-		}
-	}
-}
-
-function produceTank(factory) {
-    // TODO: needs refactoring. Make some more clever sorting.
-    var bodies = []
-    if (chooseBodyClass() === BODYCLASS.KINETIC) {
-        bodies = bodies.concat(
-			filterBodyStatsByUsage(BODYUSAGE.GROUND, BODYCLASS.KINETIC),
-			filterBodyStatsByUsage(BODYUSAGE.GROUND, BODYCLASS.THERMAL)
-		);
-    } else {
-        bodies = bodies.concat(
-			filterBodyStatsByUsage(BODYUSAGE.GROUND, BODYCLASS.THERMAL),
-            filterBodyStatsByUsage(BODYUSAGE.GROUND, BODYCLASS.KINETIC)
-		);
-    }
-    var propulsions;
-	var ret = scopeRatings();
-	var rnd = random(ret.land + ret.sea);
-	if (!defined(rnd)) // we need only vtols?
-		return false;
-	propulsions = getPropulsionStatsComponents(PROPULSIONUSAGE.GROUND);
-	if (iHaveHover()) {
-		if (rnd >= ret.land)
-			propulsions = getPropulsionStatsComponents(PROPULSIONUSAGE.HOVER);
-	} else {
-		if (ret.land === 0)
-			return false;
-	}
-	var bwPair = chooseBodyWeaponPair(bodies, chooseWeapon());
-	if (!defined(bwPair))
-		return false;
-	return ourBuildDroid(factory, "Tank", bwPair.b, propulsions, bwPair.w, bwPair.w, bwPair.w);
-}
-
-function produceVtol(factory) {
-	// TODO: consider thermal bodies
-	var bodies = filterBodyStatsByUsage(BODYUSAGE.AIR, BODYCLASS.KINETIC)
-	var propulsions = getPropulsionStatsComponents(PROPULSIONUSAGE.VTOL);
-	var bwPair = chooseBodyWeaponPair(bodies, chooseWeapon(true));
-	if (!defined(bwPair))
-		return false;
-	return ourBuildDroid(factory, "VTOL", bwPair.b, propulsions, bwPair.w, bwPair.w, bwPair.w);
-}
-
-function produceTemplateFromList(factory, list) {
-	var ret = scopeRatings();
-	for (var i = list.length - 1; i >= 0; --i) {
-		if (ret.land === 0 && !isHoverPropulsion(list[i].prop) && !isVtolPropulsion(list[i].prop))
-			continue;
-		if (ret.land === 0 && ret.sea === 0 && !isVtolPropulsion(list[i].prop))
-			continue;
-		if (isVtolPropulsion(list[i].prop) !== (factory.stattype === VTOL_FACTORY))
-			continue;
-		if ((!randomTemplates) || withChance(100 / (i + 1)))
-			if (ourBuildDroid(factory, "Template Droid", list[i].body, list[i].prop, list[i].weapons[0], list[i].weapons[1], list[i].weapons[2]))
-				return true;
-	}
-	return false;
-}
-
-function produceTemplate(factory) {
-	var path = chooseAvailableWeaponPathByRoleRatings(getProductionPaths(), chooseAttackWeaponRole(), 1);
-	if (defined(path))
-		return produceTemplateFromList(factory, path.templates);
-	return false;
-}
-
-_global.checkTruckProduction = function() {
-	var trucks = enumTrucks();
-	var hoverTrucksCount = trucks.filter(function(droid) { return isHoverPropulsion(droid.propulsion); }).length;
-	if (iHaveHover() && hoverTrucksCount < personality.minHoverTrucks) {
-		groundTrucks = trucks.filter(function(droid) { return !isHoverPropulsion(droid.propulsion); });
-		if (groundTrucks.length > personality.minTrucks) {
-			groundTrucks.length -= personality.minTrucks;
-			groundTrucks.forEach(function(droid) { orderDroid(droid, DORDER_RECYCLE); });
-			return false;
-		}
-	}
-	if (trucks.length >= getDroidLimit(me, DROID_CONSTRUCT))
-		return false;
-	if (trucks.length < personality.minTrucks || myPower() > personality.maxPower
-		|| (iHaveHover() && hoverTrucksCount < personality.minHoverTrucks)
-	) {
-		var f;
-		f = enumFinishedStructList(structures.factories)[0];
-		if (defined(f))
-			if (structureIdle(f))
-				if (produceTruck(f))
-					return true;
-		if (defined(f))
-			return false;
-		f = enumFinishedStructList(structures.templateFactories)[0];
-		if (defined(f))
-			if (structureIdle(f))
-				if (produceTemplateFromList(f, truckTemplates))
-					return true;
-	}
-	if (!iHaveArty())
-		return false;
-	var sensors = enumDroid(me, DROID_SENSOR).length;
-	if (withChance(100 - 100 * sensors / personality.maxSensors)) {
-		f = enumFinishedStructList(structures.factories)[0];
-		if (defined(f))
-			if (structureIdle(f))
-				if (produceTruck(f, sensorTurrets))
-					return true;	
-	}
-	return false;
-}
-
-function checkTankProduction() {
-	if (!iCanDesign())
-		return false; // don't cheat by producing tanks before design is available (also saves money for early generators)
-	var success = false;
-	enumIdleStructList(structures.factories).forEach(function(factory) {
-		success = success || produceTank(factory);
-	});
-	return success;
-}
-
-function checkTemplateProduction() {
-	var success = false;
-	enumIdleStructList(structures.templateFactories)
-		.concat(enumIdleStructList(structures.vtolFactories))
-		.forEach(function(factory)
-	{
-		success = success || produceTemplate(factory);
-	});
-	return success;
-}
-
-function checkVtolProduction() {
-	var success = false;
-	if (!iCanDesign())
-		return false; // don't cheat by producing vtols before design is available
-	enumIdleStructList(structures.vtolFactories).forEach(function(factory) {
-		success = success || produceVtol(factory);
-	});
-	return success;
-}
-
-_global.checkProduction = function() {
-	switch(chooseObjectType()) {
-		case 1:
-			if (checkTemplateProduction())
-				return;
-		case 3:
-			if (checkVtolProduction())
-				return;
-		default:
-			if (checkTankProduction())
-				return;
-	}
-	// if having too much energy, don't care about what we produce
-	if (myPower() > personality.maxPower) {
-		queue("checkConstruction");
-		checkTemplateProduction();
-		checkTankProduction();
-		checkVtolProduction();
-	}
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_includes/research.js b/data/mp/multiplay/skirmish/nb_includes/research.js
deleted file mode 100644
index dd260a7..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/research.js
+++ /dev/null
@@ -1,87 +0,0 @@
-
-/*
- * This file controls the AI's research choices.
- * 
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-var forcedResearch;
-
-_global.setForcedResearch = function(list) {
-	forcedResearch = list;
-}
-
-_global.needFastestResearch = function() {
-	var ret = scopeRatings();
-	if (ret.land === 0 && ret.sea === 0 && !iHaveVtol())
-		return PROPULSIONUSAGE.VTOL;
-	if (ret.land === 0 && ret.sea !== 0 && !iHaveHover() && !iHaveVtol())
-		return PROPULSIONUSAGE.HOVER;
-	return PROPULSIONUSAGE.GROUND;
-}
-
-function doResearch(lab) {
-	if (defined(forcedResearch)) {
-		if (forcedResearch === null)
-			return false;
-		if (pursueResearch(lab, forcedResearch))
-			return true;
-	}
-	// if we need to quickly get a certain propulsion to reach the enemy, prioritize that.
-	var fastest = needFastestResearch();
-	if (fastest === PROPULSIONUSAGE.VTOL)
-		if (pursueResearch(lab, [
-			propulsionStatsToResList(PROPULSIONUSAGE.VTOL),
-			fastestResearch,
-		].random())) 
-			return true;
-	if (fastest === PROPULSIONUSAGE.HOVER)
-		if (pursueResearch(lab, [
-			propulsionStatsToResList(PROPULSIONUSAGE.HOVER),
-			propulsionStatsToResList(PROPULSIONUSAGE.VTOL),
-			fastestResearch,
-		].random()))
-			return true;
-	// otherwise, start with completing the fixed research path
-	if (defined(personality.earlyResearch))
-		if (pursueResearch(lab, personality.earlyResearch))
-			return true;
-	// then, see if we want to research some weapons
-	var objType = chooseObjectType();
-	if (withChance(70)) { // TODO: make a more thoughtful decision here
-		var list = weaponStatsToResList(chooseAvailableWeaponPathByRoleRatings(personality.weaponPaths, chooseWeaponRole()), objType);
-		if (pursueResearch(lab, list))
-			return true;
-	}
-	if (withChance(65)) { // TODO: make a more thoughtful decision here
-		if (chooseBodyClass() === BODYCLASS.KINETIC) {
-			if (withChance(40))
-				if (pursueResearch(lab, classResearch.kinetic[objType]))
-					return true;
-			if (objType === OBJTYPE.TANK || objType === OBJTYPE.VTOL || (objType === OBJTYPE.DEFS && personality.defensiveness < 100))
-				if (pursueResearch(lab, bodyStatsToResList(BODYCLASS.KINETIC)))
-					return true;
-		} else {
-			if (withChance(40))
-				if (pursueResearch(lab, classResearch.thermal[objType]))
-					return true;
-			if (objType === OBJTYPE.TANK || objType === OBJTYPE.VTOL || (objType === OBJTYPE.DEFS && personality.defensiveness < 100))
-				if (pursueResearch(lab, bodyStatsToResList(BODYCLASS.THERMAL)))
-					return true;
-		}
-	}
-	// if nothing of the above holds, do some generic research
-	if (pursueResearch(lab, fundamentalResearch))
-		return true;
-	return false;
-	
-}
-
-_global.checkResearch = function() {
-	enumIdleStructList(structures.labs).forEach(doResearch);
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_includes/stats.js b/data/mp/multiplay/skirmish/nb_includes/stats.js
deleted file mode 100644
index b970904..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/stats.js
+++ /dev/null
@@ -1,233 +0,0 @@
-
-/*
- * This file contain functions for manipulating stats defined by rulesets.
- * 
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-_global.isHoverPropulsion = function(str) {
-	return propulsionStats.some(function(val) { return val.usage === PROPULSIONUSAGE.HOVER && val.stat === str; });
-}
-
-_global.isVtolPropulsion = function(str) {
-	return propulsionStats.some(function(val) { return val.usage === PROPULSIONUSAGE.VTOL && val.stat === str; });
-}
-
-_global.iHaveHover = function() {
-	return propulsionStats.some(function(val) { return val.usage === PROPULSIONUSAGE.HOVER && componentAvailable(val.stat);} );
-}
-
-_global.iHaveVtol = function() {
-    return propulsionStats.some(function(val) { return val.usage === PROPULSIONUSAGE.VTOL && componentAvailable(val.stat);} );
-}
-
-_global.iHaveArty = function() {
-	for (var stat in weaponStats)
-		for (var i = 0; i < weaponStats[stat].defenses.length; ++i)
-			if (weaponStats[stat].defenses[i].defrole === DEFROLE.ARTY)
-				if (countStruct(weaponStats[stat].defenses[i].stat) > 0)
-					return true;
-	return false;
-}
-
-// works with stored droid objects too!
-_global.safeIsVtol = function(droid) {
-	return isVtolPropulsion(droid.propulsion);
-}
-
-_global.enumStructList = function(list, player) {
-	if (!defined(player))
-		player = me;
-	return list.reduce(function(summ, new_value) { return summ.concat(enumStruct(player, new_value)); }, []);
-}
-
-_global.countStructList = function(list, player) {
-	if (!defined(player))
-		player = me;
-	return list.reduce(function(summ, new_value) { return summ + countStruct(new_value, player); }, 0);
-}
-
-_global.enumFinishedStructList = function(list, player) {
-	return enumStructList(list, player).filterProperty("status", BUILT);
-}
-
-_global.countFinishedStructList = function(list, player) {
-	return enumFinishedStructList(list, player).length;
-}
-
-_global.enumIdleStructList = function(list, player) {
-	return enumFinishedStructList(list, player).filter(structureIdle);
-}
-
-_global.structListLimit = function(list) {
-	return list.reduce(function (summ, val) {return summ + getStructureLimit(val)}, 0)
-}
-
-_global.guessWeaponRole = function (name) {
-	for (var stat in weaponStats) {
-		if (
-			weaponStats[stat].weapons.someProperty("stat", name) ||
-			weaponStats[stat].vtols.someProperty("stat", name) ||
-			weaponStats[stat].templates.some(function (i) {return i.weapons.indexOf(name) > -1;})
-		)
-		return weaponStats[stat].roles;
-	}
-	niceDebug("Ruleset warning: Couldn't guess weapon role of", name);
-}
-
-function guessWeaponMicro(name) {
-	function uncached() {
-		for (var stat in weaponStats)
-			if (weaponStats[stat].weapons.someProperty("stat", name))
-				return weaponStats[stat].micro;
-			if (weaponStats[stat].templates.some(function(i) { return i.weapons.indexOf(name) > -1; }))
-				return weaponStats[stat].micro;
-	}
-	return cached(uncached, Infinity, name);
-}
-
-_global.guessDroidMicro = function(droid) {
-	for (var i = 0; i < droid.weapons.length; ++i) {
-		var ret = guessWeaponMicro(droid.weapons[i].name);
-		if (ret !== MICRO.RANGED)
-			return ret;
-	}
-	return MICRO.RANGED;
-}
-
-_global.guessBodyArmor = function(name) {
-    var body = bodyStats.filterProperty("stat", name).last()
-    if (defined(body))
-        return body.armor;
-    else
-        niceDebug("Ruleset warning: Couldn't guess body class of", name);
-}
-
-function weaponPathIsAvailable(path, objectType, defrole) {
-	switch(objectType) {
-		case 0:
-			return path.weapons.some(function(val) { return componentAvailable(val.stat); })
-		case 1:
-			return path.templates.some(function(val) {
-				for (var i = 0; i < val.weapons.length; ++i)
-					if (!componentAvailable(val.weapons[i]))
-						return false;
-				return componentAvailable(val.body) && componentAvailable(val.prop);
-			});
-		case 2:
-			return path.defenses.some(function(val) { return val.defrole === defrole && isAvailable(val.stat); });
-		case 3:
-			return path.vtols.some(function(val) { return componentAvailable(val.stat); });
-		default: // research
-			return true;
-	}
-}
-
-_global.getProductionPaths = function() {
-	if (!defined(fallbackWeapon) || gameTime > 600000)
-		return personality.weaponPaths;
-	return [weaponStats[fallbackWeapon]].concat(personality.weaponPaths);
-}
-
-_global.chooseAvailableWeaponPathByRoleRatings = function(paths, rating, objectType, defrole) {
-	var minDist = Infinity, minPath;
-	paths.forEach(function(path) {
-		if (!weaponPathIsAvailable(path, objectType, defrole))
-			return;
-		var dist = 0;
-		for (var i = 0; i < ROLE.LENGTH; ++i) {
-			var newDist = Math.abs(rating[i] - path.roles[i])
-			if (newDist > dist)
-				dist = newDist;
-		}
-		if (dist < minDist) {
-			minDist = dist;
-			minPath = path;
-		}
-	});
-	return minPath;
-}
-
-//
-// here be functions for querying out research paths
-//
-
-function statsToResList(path) {
-	return path.map(function (val) { return val.res; });
-}
-
-// todo make one StatsToResList and do filtering for path outside
-_global.bodyStatsToResList = function(armor) {
-    return statsToResList(filterBodyStatsByUsage(armor)).reverse();
-}
-
-_global.propulsionStatsToResList = function(usage) {
-	return statsToResList(filterDataByFlag(propulsionStats, 'usage', usage));
-}
-
-_global.weaponStatsToResList = function(path, objType) {
-	if (!defined(path))
-		return [];
-	var ret = [];
-	switch(objType) {
-		case 0:
-			ret = statsToResList(path.weapons); break;
-		case 1:
-			ret = statsToResList(path.templates); break;
-		case 2:
-			ret = statsToResList(path.defenses); break;
-		case 3:
-			ret = statsToResList(path.vtols); break;
-	}
-	if (ret.length === 0)
-		ret = ret.concat(
-			statsToResList(path.weapons),
-			statsToResList(path.templates),
-			statsToResList(path.defenses),
-			statsToResList(path.vtols)
-		);
-	return ret;
-}
-
-//
-// here be functions for querying out component lists
-//
-
-// TODO: move this to math. If we have same structure of data <list of objects> we can use it all around.
-_global.filterDataByFlag = function(data, attr_name, flag) {
-     return data.filter(function(obj) { return obj[attr_name] & flag; });
-}
-
-_global.filterBodyStatsByUsage = function(usage, armor) {
-	var data;
-    if (defined(armor))
-        data = filterDataByFlag(bodyStats, 'armor', armor)
-    else
-        data = bodyStats;
-    return filterDataByFlag(data, 'usage', usage).reverse();
-}
-
-_global.getPropulsionStatsComponents = function(usage) {
-    var data = filterDataByFlag(propulsionStats, 'usage', usage)
-	return data.map(function(val) { return val.stat; }).reverse()
-}
-
-//
-// here be functions for querying out defensive structures
-//
-
-_global.weaponStatsToDefenses = function(stats, defrole) {
-	if (!defined(stats))
-		return [];
-	var ret = [];
-	for (var i = 0; i < stats.defenses.length; ++i)
-		if (!defined(defrole) || stats.defenses[i].defrole === defrole)
-			ret.push(stats.defenses[i].stat);
-	// reverse not needed here
-	return ret;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_includes/tactics.js b/data/mp/multiplay/skirmish/nb_includes/tactics.js
deleted file mode 100644
index 6d1abe7..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/tactics.js
+++ /dev/null
@@ -1,462 +0,0 @@
-
-/*
- * This file is responsible for moving combat unit around.
- *
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-_global.MAX_GROUPS = maxPlayers;
-_global.miscGroup = MAX_GROUPS;
-_global.vtolGroup = miscGroup + 1;
-var groupInfo = [];
-var firstTimeHarass = true;
-
-function GroupInfo() {
-	this.lastAttacked = undefined; // gameTime at the moment of the last combat
-}
-
-function safeGetObject(label) {
-	var obj = getObject(label);
-	if (obj === null)
-		return undefined;
-	return obj;
-}
-
-function groupsBySize() {
-	var ret = [];
-	for (var i = 0; i < MAX_GROUPS; ++i)
-		if (isEnemy(i))
-			ret.push(i);
-	ret.sort(function(one, two) { return groupSize(two) - groupSize(one); });
-	return ret;
-}
-
-function findLargestGroupIn(list) {
-	var sizes = []
-	for (var i = 0; i < MAX_GROUPS; ++i)
-		sizes[i] = 0;
-	list.forEach(function(object) {
-		if (!defined(object.group) || object.group < 0 && object.group >= MAX_GROUPS)
-			return;
-		++sizes[object.group];
-	});
-	var maxCount = 0, maxIdx = 0;
-	for (var i = 0; i < sizes.length; ++i)
-		if (sizes[i] > maxCount) {
-			maxCount = sizes[i];
-			maxIdx = i;
-		}
-	return maxIdx;
-}
-
-function findNearestGroup(x, y) {
-	var ret = naiveFindClusters(enumDroid(me).filter(function(droid) {
-		return !isVTOL(droid) && (droid.droidType === DROID_WEAPON || droid.droidType === DROID_CYBORG);
-	}), baseScale / 3);
-	if (ret.maxCount === 0)
-		return undefined;
-	var minDist = Infinity, minIdx;
-	var gr = [];
-	for (var i = 0; i < ret.clusters.length; ++i) {
-		gr[i] = findLargestGroupIn(ret.clusters[i]);
-		if (groupSize(gr[i]) > attackGroupSize()) {
-			var dist = distance(ret.xav[i], ret.yav[i], x, y);
-			if (dist < minDist) {
-				minDist = dist;
-				minIdx = i;
-			}
-		}
-	}
-	if (defined(minIdx))
-		return gr[minIdx];
-	gr = groupsBySize();
-	if (gr.length > 0)
-		if (groupSize(gr[0]) > attackGroupSize())
-			return gr[0];
-}
-
-function targetSuitableForHarass(object) {
-	function uncached() {
-		var ret = enumRange(object.x, object.y, baseScale / 2, ENEMIES, false).filter(function(obj) {
-			return !(obj.type == STRUCTURE && obj.stattype != DEFENSE);
-		}).length;
-		return ret <= groupSize(miscGroup);
-	}
-	return cached(uncached, 60000, object.id);
-}
-
-function getGroupInfo(gr) {
-	if (defined(groupInfo[gr]))
-		return groupInfo[gr];
-	groupInfo[gr] = new GroupInfo();
-	return groupInfo[gr];
-}
-
-function groupTargetLabel(gr) {
-	return "NullBot_" + me + "_GroupTarget_" + gr;
-}
-
-function groupMicroTargetLabel(gr) {
-	return "NullBot_" + me + "_GroupMicroTarget_" + gr;
-}
-
-function vtolTargetLabel() {
-	return "NullBot_" + me + "_VtolTarget";
-}
-
-function findTarget(gr) {
-	var obj = safeGetObject(groupMicroTargetLabel(gr));
-	var obj2 = safeGetObject(groupTargetLabel(gr));
-	getGroupInfo(gr);
-	if (gameTime > groupInfo[gr].lastAttacked + 10000 && defined(obj2) && obj2.type === POSITION)
-		removeLabel(groupMicroTargetLabel(gr));
-	if (!defined(obj))
-		obj = obj2;
-	if (defined(obj)) {
-		if (gr === miscGroup) {
-			// harass group should switch targets when its target gets protected, otherwise targets are permanent
-			if (throttled(10000) || targetSuitableForHarass(obj))
-				return obj;
-		} else
-			return obj;
-	}
-	// find harass targets for the misc group
-	if (gr === miscGroup) {
-		var list = enumStructList(miscTargets, enumLivingPlayers().filter(isEnemy).random());
-		powerUps.forEach(function(stat) { // pick up oil drums and artifacts
-			list = list.concat(enumFeature(-1, stat));
-		});
-		list = list.filter(targetSuitableForHarass).filter(function(feature) {
-			if (iHaveHover())
-				if (canReachFromBase(getPropulsionStatsComponents(PROPULSIONUSAGE.HOVER)[0], feature))
-					return true;
-			return canReachFromBase(getPropulsionStatsComponents(PROPULSIONUSAGE.GROUND)[0], feature);
-		}).sort(function(one, two) {
-			return distanceToBase(one) - distanceToBase(two);
-		});
-		obj = list[random(Math.min(3, list.length))];
-		if (obj) {
-			addLabel(obj, groupTargetLabel(gr));
-			return obj;
-		}
-	}
-	// fund structure targets
-	var list = enumStructList(targets, gr);
-	if (list.length > 0)
-		obj = list.random();
-	else {
-		// find remaining droids
-		list = enumDroid(gr);
-		if (list.length > 0)
-			obj = list.random();
-	}
-	if (defined(obj)) {
-		addLabel(obj, groupTargetLabel(gr));
-		return obj;
-	}
-}
-
-function groupInDanger(gr) {
-	getGroupInfo(gr); // make sure everything is defined
-	if (!defined(groupInfo[gr].lastAttacked))
-		return false;
-	return gameTime - groupInfo[gr].lastAttacked < 10000;
-}
-
-function regroup(gr) {
-	if (inPanic())
-		return enumGroup(gr).filter(checkRepaired);
-	var size = attackGroupSize();
-	if (size < groupSize(gr) / 2)
-		size = groupSize(gr) / 2;
-	var ret = naiveFindClusters(enumGroup(gr).filter(checkRepaired), (baseScale / 3));
-	if (ret.maxCount === 0)
-		return [];
-	for (var i = 0; i < ret.clusters.length; ++i)
-		if (i !== ret.maxIdx) 
-			for (var j = 0; j < ret.clusters[i].length; ++j) 
-				orderDroidLoc(ret.clusters[i][j], DORDER_MOVE, ret.xav[ret.maxIdx], ret.yav[ret.maxIdx]);
-	if (ret.maxCount < size) {
-		for (var j = 0; j < ret.clusters[ret.maxIdx].length; ++j) {
-			if (groupInDanger(gr))
-				orderDroid(ret.clusters[ret.maxIdx][j], DORDER_RTB);
-			else
-				orderDroid(ret.clusters[ret.maxIdx][j], DORDER_STOP);
-		}
-		return [];
-	}
-	return ret.clusters[ret.maxIdx];
-}
-
-function weHaveRepair() {
-	function uncached() {
-		return enumStruct(me, REPAIR_FACILITY).length > 0;
-	}
-	return cached(uncached, 1000);
-}
-
-function checkRepaired(droid) {
-	if (!weHaveRepair())
-		return true;
-	if (droid.order === DORDER_RTR)
-		return false;
-	if (droid.health < personality.repairAt) {
-		orderDroid(droid, DORDER_RTR);
-		return false;
-	}
-	return true;
-}
-
-function droidFree(droid) {
-	if (droid.order === DORDER_SCOUT)
-		return false;
-	if (droid.order === DORDER_ATTACK)
-		return false;
-	if (droid.order === DORDER_RTR)
-		return false;
-	if (!checkRepaired(droid))
-		return false;
-	return true;
-}
-
-function attackTarget(droid) {
-	var target = findTarget(droid.group);
-	if (droid.group !== miscGroup)
-		if (!defined(target) || !droidCanReach(droid, target.x, target.y)) {
-			groupDroid(droid);
-			return;
-		}
-	if (defined(target))
-		switch (target.type) {
-			case DROID:
-				if (droid.droidType !== DROID_SENSOR)
-					orderDroidObj(droid, DORDER_ATTACK, target);
-				else
-					orderDroidObj(droid, DORDER_OBSERVE, target);
-				break;
-			case FEATURE:
-				orderDroidObj(droid, DORDER_RECOVER, target);
-				break;
-			case STRUCTURE:
-				if (droid.droidType !== DROID_SENSOR)
-					orderDroidLoc(droid, DORDER_SCOUT, target.x, target.y);
-				else
-					orderDroidObj(droid, DORDER_OBSERVE, target);
-				break;
-			default:
-				orderDroidLoc(droid, DORDER_SCOUT, target.x, target.y);
-				break;
-		}
-}
-
-function vtolCanHit(droid, obj) {
-	if (typeof(obj) === DROID && isVTOL(obj))
-		return droid.canHitAir;
-	else
-		return droid.canHitGround;
-}
-
-function pickVtolTarget(droid) {
-	function uncached() {
-		function canHit(obj) {
-			return vtolCanHit(droid, obj);
-		}
-		var enemy = enumLivingPlayers().filter(isEnemy).random();
-		var list;
-		list = enumStructList(miscTargets, enemy).filter(canHit);
-		if (list.length > 0) return list.random();
-		list = enumStruct(enemy, DEFENSE).filterProperty("canHitAir", true).filter(canHit);
-		if (list.length > 0) return list.random();
-		list = enumDroid(enemy, DROID_WEAPON).filterProperty("canHitAir", true).filter(canHit);
-		if (list.length > 0) return list.random();
-		list = enumDroid(enemy, DROID_CYBORG).filterProperty("canHitAir", true).filter(canHit);
-		if (list.length > 0) return list.random();
-		list = enumStructList(targets, enemy).filter(canHit);
-		if (list.length > 0) return list.random();
-		list = enumDroid(enemy).filter(canHit);
-		if (list.length > 0) return list.random();
-	}
-	return cached(uncached, 100, droid.canHitAir + 2 * droid.canHitGround);
-}
-
-function vtolArmed(obj, percent) {
-	if (obj.type != DROID)
-		return;
-	if (!isVTOL(obj))
-		return false;
-	for (var i = 0; i < obj.weapons.length; ++i)
-		if (obj.weapons[i].armed >= 99)
-			return true;
-	return false;
-}
-
-function vtolReady(droid) {
-	if (droid.order == DORDER_ATTACK)
-		return false;
-	if (vtolArmed(droid, 99))
-		return true;
-	if (droid.order != DORDER_REARM) {
-		orderDroid(droid, DORDER_REARM);
-		buildVtols() // actually pads
-	}
-	return false;
-}
-
-_global.attackGroupSize = function() {
-	var ret = personality.minTanks + (gameTime / 300000) * personality.becomeHarder;
-	if (ret > personality.maxTanks)
-		ret = personality.maxTanks;
-	return ret;
-}
-
-_global.setTarget = function(object, group) {
-	if (!defined(group)) {
-		group = findNearestGroup(object.x, object.y);
-		if (object.type === STRUCTURE || object.type === DROID)
-			addLabel(object, vtolTargetLabel());
-	}
-	if (!defined(group))
-		return false;
-	if (defined(safeGetObject(groupTargetLabel(group))))
-		if (throttled(10000, group)) // don't switch targets too often
-			return false;
-	if (object.type === DROID || (object.type === STRUCTURE && object.stattype === DEFENSE))
-		addLabel(object, groupMicroTargetLabel(group));
-	else
-		addLabel(object, groupTargetLabel(group));
-	return true;
-}
-
-_global.unsetTarget = function(player) {
-	for (var i = 0; i <= MAX_GROUPS; ++i) {
-		var obj = safeGetObject(groupTargetLabel(i));
-		if (defined(obj) && obj.type === POSITION && findBeaconPlayer(obj.x, obj.y) === player)
-			removeLabel(groupTargetLabel(i));
-	}
-}
-
-_global.groupDroid = function(droid) {
-	if (droid.droidType === DROID_WEAPON || droid.droidType === DROID_CYBORG) {
-		if (isVTOL(droid)) {
-			groupAdd(vtolGroup, droid);
-			return;
-		}
-		if (withChance(100 - groupSize(miscGroup) * 50 / personality.maxMiscTanks) || firstTimeHarass) {
-			firstTimeHarass = false;
-			groupAdd(miscGroup, droid);
-			return;
-		}
-		var grp = groupsBySize().filter(function(i) {
-			if (isAlly(i))
-				return false;
-			if (!defined(findTarget(i)))
-				return false;
-			if (!droidCanReach(droid, findTarget(i).x, findTarget(i).y))
-				return false;
-			return true;
-		});
-		var ret = grp.filter(function(i) {
-			return groupSize(i) < attackGroupSize() * 2 && defined(findTarget(i));
-		});
-		if (ret.length === 0)
-			ret = grp;
-		if (ret.length === 0)
-			ret = [ miscGroup ];
-		groupAdd(ret[0], droid);
-	}
-	if (droid.droidType === DROID_SENSOR)
-		groupAdd(miscGroup, droid);
-}
-
-_global.rebalanceGroups = function() {
-	if (throttled(5000))
-		return;
-	if (groupSize(miscGroup) > personality.maxMiscTanks) {
-		var list = enumGroup(miscGroup).shuffle();
-		for (var i = personality.maxMiscTanks; i < personality.maxMiscTanks + 5 && i < list.length; ++i)
-			groupDroid(list[i]);
-	}
-	var ret = groupsBySize();
-	if (ret.length > 0)
-		if (ret[0] > 0 && ret[0] < attackGroupSize())
-			for (var i = 1; i < ret.length; ++i) {
-				var list = enumGroup(ret[i]);
-				for (var j = 0; j < list.length; ++j) {
-					target = findTarget(ret[0]);
-					if (defined(target))
-						if (droidCanReach(list[j], target.x, target.y)) {
-							groupAdd(ret[0], list[j]);
-							return;
-						}
-				}
-			}
-}
-
-_global.touchGroup = function(gr) {
-	getGroupInfo(gr); // make sure everything is defined
-	groupInfo[gr].lastAttacked = gameTime;
-}
-
-_global.fallBack = function(droid, threat) {
-	if (droid.order === DORDER_MOVE)
-		return;
-	if (guessDroidMicro(droid) === MICRO.MELEE)
-		return;
-	var x = droid.x - (baseScale / 7) * (threat.x - droid.x) / distance(threat, droid);
-	var y = droid.y - (baseScale / 7) * (threat.y - droid.y) / distance(threat, droid);
-	if (x < 1 || y < 1 || x > mapWidth - 2 || y > mapHeight - 2)
-		return;
-	orderDroidLoc(droid, DORDER_MOVE, x, y);
-}
-
-_global.dangerLevel = function(loc) {
-	return enumRange(loc.x, loc.y, baseScale / 2, ENEMIES, false).length;
-}
-
-_global.checkAttack = function() {
-	for (var i = 0; i < MAX_GROUPS; ++i)
-		if (!throttled(3000, i)) {
-			regroup(i).forEach(attackTarget);
-			break;
-		}
-	if (throttled(1000, "misc"))
-		return;
-	enumGroup(miscGroup).filter(checkRepaired).forEach(attackTarget);
-	if (throttled(5000, "vtols"))
-		return;
-	var droids = enumGroup(vtolGroup).filter(vtolReady);
-	if (droids.length > attackGroupSize() / 3.)
-		droids.forEach(function(droid) {
-			var target = pickVtolTarget(droid);
-			if (defined(target))
-				orderDroidObj(droid, DORDER_ATTACK, target);
-		});
-}
-
-_global.pushVtols = function(object) {
-	var vtols = enumRange(object.x, object.y, 20, me, false);
-	var enemies = enumRange(object.x, object.y, 8, ENEMIES, true);
-	for (var i = 0; i < vtols.length; ++i)
-		if (vtolArmed(vtols[i], 1))
-			for (var j = 0; j < enemies.length; ++j)
-				if (vtolCanHit(vtols[i], enemies[j])) {
-					orderDroidObj(vtols[i], DORDER_ATTACK, enemies[j]);
-					break;
-				}
-}
-
-_global.inPanic = function() {
-	function uncached() {
-		var badGuys = enumRange(baseLocation.x, baseLocation.y, baseScale, ENEMIES).length;
-		var goodGuys = enumRange(baseLocation.x, baseLocation.y, baseScale, ALLIES).filter(function(object) {
-			return object.type === DROID && (object.droidType === DROID_WEAPON || object.droidType === DROID_CYBORG);
-		}).length;
-		return 3 * badGuys > 2 * goodGuys;
-	}
-	return cached(uncached, 10000);
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_includes/timers.js b/data/mp/multiplay/skirmish/nb_includes/timers.js
deleted file mode 100644
index 81895be..0000000
--- a/data/mp/multiplay/skirmish/nb_includes/timers.js
+++ /dev/null
@@ -1,27 +0,0 @@
-
-/*
- * This file lists all timers used by the AI.
- * 
- */
-
-(function(_global) {
-////////////////////////////////////////////////////////////////////////////////////////////
-
-// slightly shift all timers so that not to get too many of them on the same game frame,
-// especially when multiple AI instances are running
-function rnd() {
-	return random(201) - 100;
-}
-
-_global.setTimers = function() {
-	setTimer("spendMoney", 2000 + 3 * rnd());
-	setTimer("checkConstruction", 3000 + 8 * rnd());
-	setTimer("checkAttack", 100);
-	setTimer("adaptCycle", 100);
-	setTimer("rebalanceGroups", 10000 + 20 * rnd());
-	if (difficulty === EASY)
-		setTimer("goEasy", 30000);
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-})(this);
diff --git a/data/mp/multiplay/skirmish/nb_rulesets/standard.js b/data/mp/multiplay/skirmish/nb_rulesets/standard.js
deleted file mode 100644
index 3dc9bcc..0000000
--- a/data/mp/multiplay/skirmish/nb_rulesets/standard.js
+++ /dev/null
@@ -1,564 +0,0 @@
-
-/*
- * This file describes standard stats and strategies of 
- * the base (unmodded) game.
- * 
- * If you want to make an AI specially designed for your mod, start by
- * making a copy of this file and modifying it according to your mod's rules.
- * 
- * Then provide a personality to use the ruleset, similar to 
- * how nb_generic.[js|ai] is provided for this ruleset.
- * 
- * You may find some useful functions for working with these stats
- * in stats.js .
- * 
- */
-
-// a factor for figuring out how large things are in this ruleset,
-// or simply a typical radius of a player's base
-const baseScale = 20; 
-
-// diameter of laser satellite splash/incendiary damage 
-// for use in lassat.js
-const lassatSplash = 4; 
-
-// set this to 1 to choose templates randomly, instead of later=>better.
-const randomTemplates = 0;
-
-// this function is used for avoiding AI cheats that appear due to 
-// being able to build droids before designing them
-function iCanDesign() {
-	if (difficulty === INSANE) // won't make INSANE much worse ...
-		return true;
-	return countFinishedStructList(structures.hqs) > 0;
-}
-
-const structures = {
-	factories: [ "A0LightFactory", ],
-	templateFactories: [ "A0CyborgFactory", ],
-	vtolFactories: [ "A0VTolFactory1", ],
-	labs: [ "A0ResearchFacility", ],
-	gens: [ "A0PowerGenerator", ],
-	hqs: [ "A0CommandCentre", ],
-	vtolPads: [ "A0VtolPad", ],
-	derricks: [ "A0ResourceExtractor", ],
-	extras: [ "A0RepairCentre3", "A0Sat-linkCentre", "A0LasSatCommand", ],
-	sensors: [ "Sys-SensoTower02", "Sys-CB-Tower01", "Sys-RadarDetector01", "Sys-SensoTowerWS", ],
-};
-
-const oilResources = [ "OilResource", ];
-
-const powerUps = [ "OilDrum", "Crate" ];
-
-// NOTE: you cannot use specific stats as bases, but only stattypes
-// probably better make use of .name rather than of .stattype here?
-const modules = [
-	{ base: POWER_GEN, module: "A0PowMod1", count: 1, cost: MODULECOST.CHEAP },
-	{ base: FACTORY, module: "A0FacMod1", count: 2, cost: MODULECOST.EXPENSIVE },
-	{ base: VTOL_FACTORY, module: "A0FacMod1", count: 2, cost: MODULECOST.EXPENSIVE },
-	{ base: RESEARCH_LAB, module: "A0ResearchModule1", count: 1, cost: MODULECOST.EXPENSIVE },
-];
-
-const targets = []
-	.concat(structures.factories)
-	.concat(structures.templateFactories)
-	.concat(structures.vtolFactories)
-	.concat(structures.extras)
-;
-
-const miscTargets = []
-	.concat(structures.derricks)
-;
-
-const sensorTurrets = [
-	"SensorTurret1Mk1", // sensor
-	"Sensor-WideSpec", // wide spectrum sensor
-];
-
-const fundamentalResearch = [
-	"R-Struc-PowerModuleMk1",
-	"R-Struc-RprFac-Upgrade01",
-	"R-Sys-Sensor-Tower02",
-	"R-Vehicle-Prop-Halftracks",
-	"R-Struc-Power-Upgrade01c",
-	"R-Vehicle-Prop-Tracks",
-	"R-Sys-CBSensor-Tower01",
-	"R-Struc-VTOLPad-Upgrade01",
-	"R-Struc-Power-Upgrade03a",
-	"R-Struc-VTOLPad-Upgrade03",
-	"R-Sys-Autorepair-General",
-	"R-Wpn-LasSat",
-	"R-Struc-RprFac-Upgrade04",
-	"R-Struc-VTOLPad-Upgrade06",
-	"R-Struc-RprFac-Upgrade06",
-];
-
-const fastestResearch = [
-	"R-Struc-Research-Upgrade09",
-];
-
-// body and propulsion arrays don't affect fixed template droids
-const bodyStats = [
-	{ res: "R-Vehicle-Body01", stat: "Body1REC", weight: WEIGHT.LIGHT, usage: BODYUSAGE.UNIVERSAL, armor: BODYCLASS.KINETIC }, // viper
-	{ res: "R-Vehicle-Body05", stat: "Body5REC", weight: WEIGHT.MEDIUM, usage: BODYUSAGE.COMBAT, armor: BODYCLASS.KINETIC }, // cobra
-	{ res: "R-Vehicle-Body11", stat: "Body11ABT", weight: WEIGHT.HEAVY, usage: BODYUSAGE.GROUND, armor: BODYCLASS.KINETIC }, // python
-	{ res: "R-Vehicle-Body02", stat: "Body2SUP", weight: WEIGHT.LIGHT, usage: BODYUSAGE.UNIVERSAL, armor: BODYCLASS.KINETIC }, // leopard
-	{ res: "R-Vehicle-Body06", stat: "Body6SUPP", weight: WEIGHT.MEDIUM, usage: BODYUSAGE.COMBAT, armor: BODYCLASS.KINETIC }, // panther
-	{ res: "R-Vehicle-Body09", stat: "Body9REC", weight: WEIGHT.HEAVY, usage: BODYUSAGE.GROUND, armor: BODYCLASS.KINETIC }, // tiger
-	{ res: "R-Vehicle-Body13", stat: "Body13SUP", weight: WEIGHT.HEAVY, usage: BODYUSAGE.GROUND, armor: BODYCLASS.KINETIC }, // wyvern
-	{ res: "R-Vehicle-Body14", stat: "Body14SUP", weight: WEIGHT.HEAVY, usage: BODYUSAGE.GROUND, armor: BODYCLASS.KINETIC }, // dragon
-	{ res: "R-Vehicle-Body04", stat: "Body4ABT", weight: WEIGHT.LIGHT, usage: BODYUSAGE.UNIVERSAL, armor: BODYCLASS.THERMAL }, // bug
-	{ res: "R-Vehicle-Body08", stat: "Body8MBT", weight: WEIGHT.HEAVY, usage: BODYUSAGE.COMBAT, armor: BODYCLASS.THERMAL }, // scorpion
-	{ res: "R-Vehicle-Body12", stat: "Body12SUP", weight: WEIGHT.HEAVY, usage: BODYUSAGE.GROUND, armor: BODYCLASS.THERMAL }, // mantis
-	{ res: "R-Vehicle-Body03", stat: "Body3MBT", weight: WEIGHT.MEDIUM, usage: BODYUSAGE.UNIVERSAL, armor: BODYCLASS.THERMAL }, // retaliation
-	{ res: "R-Vehicle-Body07", stat: "Body7ABT", weight: WEIGHT.HEAVY, usage: BODYUSAGE.COMBAT, armor: BODYCLASS.THERMAL }, // retribution
-	{ res: "R-Vehicle-Body10", stat: "Body10MBT", weight: WEIGHT.HEAVY, usage: BODYUSAGE.GROUND, armor: BODYCLASS.THERMAL }, // vengeance
-];
-
-const classResearch = {
-	kinetic: [
-		[ // OBJTYPE.TANK
-			"R-Vehicle-Metals09",
-		],
-		[ // OBJTYPE.BORG
-			"R-Cyborg-Metals09",
-		],
-		[ // OBJTYPE.DEFS
-			"R-Defense-WallUpgrade03",
-			"R-Struc-Materials03",
-			"R-Defense-WallUpgrade06",
-			"R-Struc-Materials06",
-			"R-Defense-WallUpgrade12",
-			"R-Struc-Materials09",
-		],
-		[ // OBJTYPE.VTOL
-			"R-Vehicle-Metals09",
-		],
-	],
-	thermal: [
-		[
-			"R-Vehicle-Armor-Heat09",
-		],
-		[
-			"R-Cyborg-Armor-Heat09",
-		],
-		[
-			"R-Defense-WallUpgrade03",
-			"R-Struc-Materials03",
-			"R-Defense-WallUpgrade06",
-			"R-Struc-Materials06",
-			"R-Defense-WallUpgrade12",
-			"R-Struc-Materials09",
-		],
-		[
-			"R-Vehicle-Armor-Heat09",
-		],
-	],
-}
-
-// NOTE: Please don't put hover propulsion into the ground list, etc.!
-// NOTE: Hover propulsion should be placed AFTER ground propulsion!
-// Adaptation code relies on that for discovering map topology.
-// Ground propulsions need to be ground only, hover propulsions shouldn't
-// be able to cross cliffs, but should be able to cross seas, etc. 
-const propulsionStats = [
-	{ res: "R-Vehicle-Prop-Wheels", stat: "wheeled01", usage: PROPULSIONUSAGE.GROUND },
-	{ res: "R-Vehicle-Prop-Halftracks", stat: "HalfTrack", usage: PROPULSIONUSAGE.GROUND },
-	{ res: "R-Vehicle-Prop-Tracks", stat: "tracked01", usage: PROPULSIONUSAGE.GROUND },
-	{ res: "R-Vehicle-Prop-Hover", stat: "hover01", usage: PROPULSIONUSAGE.HOVER },
-	{ res: "R-Vehicle-Prop-VTOL", stat: "V-Tol", usage: PROPULSIONUSAGE.VTOL },
-];
-
-
-const truckTurrets = [
-	"Spade1Mk1",
-];
-
-const truckTemplates = [
-	{ body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "CyborgSpade", ] } // engineer
-];
-
-const fallbackWeapon = 'machineguns';
-
-// Unlike bodies and propulsions, weapon lines don't have any specific meaning.
-// You can make as many weapon lines as you want for your ruleset.
-const weaponStats = {
-	machineguns: {
-		// How good weapons of this path are against tanks, borgs, defenses, vtols?
-		// The sum of the four should be equal to 1.
-		roles: [ 0.1, 0.7, 0.1, 0.1 ], 
-		// This explains how are human players supposed to call this weapon path in the chat.
-		chatalias: "mg",
-		// This controls micromanagement of units based on the weapons of this path.
-		micro: MICRO.RANGED,
-		// Weapons of the path, better weapons below.
-		weapons: [
-			{ res: "R-Wpn-MG1Mk1", stat: "MG1Mk1", weight: WEIGHT.ULTRALIGHT }, // mg
-			{ res: "R-Wpn-MG2Mk1", stat: "MG2Mk1", weight: WEIGHT.LIGHT }, // tmg
-			{ res: "R-Wpn-MG3Mk1", stat: "MG3Mk1", weight: WEIGHT.MEDIUM }, // hmg
-			{ res: "R-Wpn-MG4", stat: "MG4ROTARYMk1", weight: WEIGHT.MEDIUM }, // ag
-			{ res: "R-Wpn-MG5", stat: "MG5TWINROTARY", weight: WEIGHT.MEDIUM }, // tag
-		],
-		// VTOL weapons of the path, in the same order.
-		vtols: [
-			{ res: "R-Wpn-MG3Mk1", stat: "MG3-VTOL", weight: WEIGHT.ULTRALIGHT }, // vtol hmg
-			{ res: "R-Wpn-MG4", stat: "MG4ROTARY-VTOL", weight: WEIGHT.MEDIUM }, // vtol ag
-		],
-		// Defensive structures of the path, in the same order.
-		// NOTE: a defensive structure is recycled whenever there are at least two structures
-		// with the same role available down the list
-		defenses: [
-			// turtle AI needs early versatile towers, hence duplicate stat
-			{ res: "R-Defense-Tower01", stat: "GuardTower1", defrole: DEFROLE.GATEWAY }, // hmg tower
-			{ res: "R-Defense-Tower01", stat: "GuardTower1", defrole: DEFROLE.STANDALONE }, // hmg tower
-			{ res: "R-Defense-Pillbox01", stat: "PillBox1", defrole: DEFROLE.STANDALONE }, // hmg bunker
-			{ res: "R-Defense-WallTower01", stat: "WallTower01", defrole: DEFROLE.GATEWAY }, // hmg hardpoint
-			{ res: "R-Defense-RotMG", stat: "Pillbox-RotMG", defrole: DEFROLE.STANDALONE }, // ag bunker
-			{ res: "R-Defense-Wall-RotMg", stat: "Wall-RotMg", defrole: DEFROLE.GATEWAY }, // ag hardpoint
-			{ res: "R-Defense-WallTower-TwinAGun", stat: "WallTower-TwinAssaultGun", defrole: DEFROLE.GATEWAY }, // tag hardpoint
-		],
-		// Cyborg templates, better borgs below, as usual.
-		templates: [
-			{ res: "R-Wpn-MG1Mk1", body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "CyborgChaingun", ] }, // mg cyborg
-			{ res: "R-Wpn-MG4", body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "CyborgRotMG", ] }, // ag cyborg
-		],
-		// Extra things to research on this path, even if they don't lead to any new stuff
-		extras: [
-			"R-Wpn-MG-Damage08",
-		],
-	},
-	flamers: {
-		roles: [ 0.3, 0.7, 0.0, 0.0 ],
-		chatalias: "fl",
-		micro: MICRO.MELEE,
-		weapons: [
-			{ res: "R-Wpn-Flamer01Mk1", stat: "Flame1Mk1", weight: WEIGHT.LIGHT }, // flamer
-			{ res: "R-Wpn-Flame2", stat: "Flame2", weight: WEIGHT.HEAVY }, // inferno
-			{ res: "R-Wpn-Plasmite-Flamer", stat: "PlasmiteFlamer", weight: WEIGHT.HEAVY }, // plasmite
-		],
-		vtols: [],
-		defenses: [
-			{ res: "R-Defense-Pillbox05", stat: "PillBox5", defrole: DEFROLE.GATEWAY }, // flamer bunker
-			{ res: "R-Defense-HvyFlamer", stat: "Tower-Projector", defrole: DEFROLE.GATEWAY }, // inferno bunker
-			{ res: "R-Defense-PlasmiteFlamer", stat: "Plasmite-flamer-bunker", defrole: DEFROLE.GATEWAY }, // plasmite bunker
-		],
-		templates: [
-			{ res: "R-Wpn-Flamer01Mk1", body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "CyborgFlamer01", ] }, // flamer cyborg
-			{ res: "R-Wpn-Flame2", body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "Cyb-Wpn-Thermite", ] }, // flamer cyborg
-		],
-		extras: [
-			"R-Wpn-Flamer-ROF03",
-			"R-Wpn-Flamer-Damage09",
-		],
-	},
-	cannons: {
-		roles: [ 0.5, 0.2, 0.3, 0.0 ],
-		chatalias: "cn",
-		micro: MICRO.RANGED,
-		weapons: [
-			{ res: "R-Wpn-Cannon1Mk1", stat: "Cannon1Mk1", weight: WEIGHT.LIGHT }, // lc
-			{ res: "R-Wpn-Cannon2Mk1", stat: "Cannon2A-TMk1", weight: WEIGHT.HEAVY }, // mc
-			{ res: "R-Wpn-Cannon4AMk1", stat: "Cannon4AUTOMk1", weight: WEIGHT.HEAVY }, // hpv
-			{ res: "R-Wpn-Cannon5", stat: "Cannon5VulcanMk1", weight: WEIGHT.HEAVY }, // ac
-			{ res: "R-Wpn-Cannon6TwinAslt", stat: "Cannon6TwinAslt", weight: WEIGHT.ULTRAHEAVY }, // tac
-			{ res: "R-Wpn-Cannon3Mk1", stat: "Cannon375mmMk1", weight: WEIGHT.ULTRAHEAVY }, // hc
-			{ res: "R-Wpn-RailGun01", stat: "RailGun1Mk1", weight: WEIGHT.LIGHT }, // needle
-			{ res: "R-Wpn-RailGun02", stat: "RailGun2Mk1", weight: WEIGHT.HEAVY }, // rail
-			{ res: "R-Wpn-RailGun03", stat: "RailGun3Mk1", weight: WEIGHT.ULTRAHEAVY }, // gauss
-		],
-		vtols: [
-			{ res: "R-Wpn-Cannon1Mk1", stat: "Cannon1-VTOL", weight: WEIGHT.LIGHT }, // lc
-			{ res: "R-Wpn-Cannon4AMk1", stat: "Cannon4AUTO-VTOL", weight: WEIGHT.HEAVY }, // hpv
-			{ res: "R-Wpn-Cannon5", stat: "Cannon5Vulcan-VTOL", weight: WEIGHT.HEAVY }, // ac
-			{ res: "R-Wpn-RailGun01", stat: "RailGun1-VTOL", weight: WEIGHT.LIGHT }, // needle
-			{ res: "R-Wpn-RailGun02", stat: "RailGun2-VTOL", weight: WEIGHT.HEAVY }, // rail
-		],
-		defenses: [
-			{ res: "R-Defense-Pillbox04", stat: "PillBox4", defrole: DEFROLE.STANDALONE }, // lc bunker
-			{ res: "R-Defense-WallTower02", stat: "WallTower02", defrole: DEFROLE.GATEWAY }, // lc hard
-			{ res: "R-Defense-WallTower03", stat: "WallTower03", defrole: DEFROLE.GATEWAY }, // mc hard
-			{ res: "R-Defense-Emplacement-HPVcannon", stat: "Emplacement-HPVcannon", defrole: DEFROLE.STANDALONE }, // hpv empl
-			{ res: "R-Defense-WallTower-HPVcannon", stat: "WallTower-HPVcannon", defrole: DEFROLE.GATEWAY }, // hpv hard
-			{ res: "R-Defense-Wall-VulcanCan", stat: "Wall-VulcanCan", defrole: DEFROLE.GATEWAY }, // ac hard
-			{ res: "R-Defense-Cannon6", stat: "PillBox-Cannon6", defrole: DEFROLE.STANDALONE }, // tac bunker
-			{ res: "R-Defense-WallTower04", stat: "WallTower04", defrole: DEFROLE.GATEWAY }, // hc hard
-			{ res: "R-Defense-Super-Cannon", stat: "X-Super-Cannon", defrole: DEFROLE.FORTRESS }, // cannon fort
-			{ res: "R-Defense-GuardTower-Rail1", stat: "GuardTower-Rail1", defrole: DEFROLE.STANDALONE }, // needle tower
-			{ res: "R-Defense-Rail2", stat: "Emplacement-Rail2", defrole: DEFROLE.STANDALONE }, // rail empl
-			{ res: "R-Defense-WallTower-Rail2", stat: "WallTower-Rail2", defrole: DEFROLE.GATEWAY }, // rail hard
-			{ res: "R-Defense-Rail3", stat: "Emplacement-Rail3", defrole: DEFROLE.STANDALONE }, // gauss empl
-			{ res: "R-Defense-WallTower-Rail3", stat: "WallTower-Rail3", defrole: DEFROLE.GATEWAY }, // gauss hard
-			{ res: "R-Defense-MassDriver", stat: "X-Super-MassDriver", defrole: DEFROLE.FORTRESS }, // mass driver fort
-		],
-		templates: [
-			{ res: "R-Wpn-Cannon1Mk1", body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "CyborgCannon", ] }, // lc borg
-			{ res: "R-Cyborg-Hvywpn-Mcannon", body: "CyborgHeavyBody", prop: "CyborgLegs", weapons: [ "Cyb-Hvywpn-Mcannon", ] }, // mc super
-			{ res: "R-Cyborg-Hvywpn-HPV", body: "CyborgHeavyBody", prop: "CyborgLegs", weapons: [ "Cyb-Hvywpn-HPV", ] }, // hpv super
-			{ res: "R-Cyborg-Hvywpn-Acannon", body: "CyborgHeavyBody", prop: "CyborgLegs", weapons: [ "Cyb-Hvywpn-Acannon", ] }, // ac super
-			{ res: "R-Wpn-RailGun01", body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "Cyb-Wpn-Rail1", ] }, // needle borg
-			{ res: "R-Cyborg-Hvywpn-RailGunner", body: "CyborgHeavyBody", prop: "CyborgLegs", weapons: [ "Cyb-Hvywpn-RailGunner", ] }, // rail super
-		],
-		extras: [
-			"R-Wpn-Cannon-ROF06",
-			"R-Vehicle-Engine09", // cannons are heeeeavy
-			"R-Wpn-Rail-Damage03", // sure it's required by gauss, but what if our AI uses only cyborgs and vtols?
-			"R-Wpn-Rail-ROF03",
-		],
-	},
-	cannons_AA: {
-		roles: [ 0.0, 0.0, 0.0, 1.0 ],
-		chatalias: "ca",
-		micro: MICRO.RANGED,
-		weapons: [
-			{ res: "R-Wpn-AAGun02", stat: "AAGun2Mk1", weight: WEIGHT.HEAVY },
-		],
-		vtols: [],
-		defenses: [
-			{ res: "R-Defense-AASite-QuadBof", stat: "AASite-QuadBof", defrole: DEFROLE.STANDALONE },
-			{ res: "R-Defense-WallTower-DoubleAAgun", stat: "WallTower-DoubleAAGun", defrole: DEFROLE.GATEWAY },
-		],
-		templates: [],
-		extras: [],
-	},
-	mortars: {
-		roles: [ 0.2, 0.4, 0.4, 0.0 ],
-		chatalias: "mo",
-		micro: MICRO.DUMB,
-		weapons: [
-			{ res: "R-Wpn-Mortar01Lt", stat: "Mortar1Mk1", weight: WEIGHT.HEAVY }, // duplicate stat!
-			{ res: "R-Wpn-Mortar02Hvy", stat: "Mortar2Mk1", weight: WEIGHT.HEAVY },
-			{ res: "R-Wpn-Mortar3", stat: "Mortar3ROTARYMk1", weight: WEIGHT.HEAVY },
-			{ res: "R-Wpn-HowitzerMk1", stat: "Howitzer105Mk1", weight: WEIGHT.ULTRAHEAVY },
-			{ res: "R-Wpn-Howitzer03-Rot", stat: "Howitzer03-Rot", weight: WEIGHT.ULTRAHEAVY },
-			{ res: "R-Wpn-HvyHowitzer", stat: "Howitzer150Mk1", weight: WEIGHT.ULTRAHEAVY },
-		],
-		vtols: [
-			{ res: "R-Wpn-Bomb01", stat: "Bomb1-VTOL-LtHE", weight: WEIGHT.LIGHT },
-			{ res: "R-Wpn-Bomb02", stat: "Bomb2-VTOL-HvHE", weight: WEIGHT.HEAVY },
-		],
-		defenses: [
-			{ res: "R-Defense-MortarPit", stat: "Emplacement-MortarPit01", defrole: DEFROLE.STANDALONE },
-			{ res: "R-Defense-HvyMor", stat: "Emplacement-MortarPit02", defrole: DEFROLE.STANDALONE },
-			{ res: "R-Defense-RotMor", stat: "Emplacement-RotMor", defrole: DEFROLE.STANDALONE },
-			{ res: "R-Defense-Howitzer", stat: "Emplacement-Howitzer105", defrole: DEFROLE.ARTY },
-			{ res: "R-Defense-RotHow", stat: "Emplacement-RotHow", defrole: DEFROLE.ARTY },
-			{ res: "R-Defense-HvyHowitzer", stat: "Emplacement-Howitzer150", defrole: DEFROLE.ARTY },
-		],
-		templates: [
-			{ res: "R-Wpn-Mortar01Lt", body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "Cyb-Wpn-Grenade", ] },
-		],
-		extras: [
-			"R-Wpn-Bomb-Accuracy03",
-			"R-Wpn-Howitzer-Damage06",
-			"R-Wpn-Howitzer-ROF04",
-			"R-Wpn-Howitzer-Accuracy03",
-		],
-	},
-	fireMortars: {
-		roles: [ 0.3, 0.3, 0.4, 0.0 ],
-		chatalias: "fm", 
-		micro: MICRO.DUMB,
-		weapons: [
-			{ res: "R-Wpn-Mortar01Lt", stat: "Mortar1Mk1", weight: WEIGHT.HEAVY }, // duplicate stat!
-			{ res: "R-Wpn-Mortar-Incenediary", stat: "Mortar-Incenediary", weight: WEIGHT.HEAVY },
-			{ res: "R-Wpn-Howitzer-Incenediary", stat: "Howitzer-Incenediary", weight: WEIGHT.ULTRAHEAVY },
-		],
-		vtols: [
-			{ res: "R-Wpn-Bomb03", stat: "Bomb3-VTOL-LtINC", weight: WEIGHT.LIGHT },
-			{ res: "R-Wpn-Bomb04", stat: "Bomb4-VTOL-HvyINC", weight: WEIGHT.HEAVY },
-			{ res: "R-Wpn-Bomb05", stat: "Bomb5-VTOL-Plasmite", weight: WEIGHT.HEAVY },
-		],
-		defenses: [
-			{ res: "R-Defense-MortarPit-Incenediary", stat: "Emplacement-MortarPit-Incenediary", defrole: DEFROLE.STANDALONE },
-			{ res: "R-Defense-Howitzer-Incenediary", stat: "Emplacement-Howitzer-Incenediary", defrole: DEFROLE.ARTY },
-		],
-		templates: [],
-		extras: [
-			"R-Wpn-Bomb-Accuracy03",
-			"R-Wpn-Howitzer-Damage06",
-			"R-Wpn-Howitzer-ROF04",
-			"R-Wpn-Howitzer-Accuracy03",
-		],
-	},
-	rockets_AT: {
-		roles: [ 1.0, 0.0, 0.0, 0.0 ],
-		chatalias: "rx",
-		micro: MICRO.RANGED,
-		weapons: [
-			{ res: "R-Wpn-Rocket05-MiniPod", stat: "Rocket-Pod", weight: WEIGHT.LIGHT }, // pod
-			{ res: "R-Wpn-Rocket01-LtAT", stat: "Rocket-LtA-T", weight: WEIGHT.LIGHT }, // lancer
-			{ res: "R-Wpn-Rocket07-Tank-Killer", stat: "Rocket-HvyA-T", weight: WEIGHT.LIGHT }, // tk
-			{ res: "R-Wpn-Missile2A-T", stat: "Missile-A-T", weight: WEIGHT.LIGHT }, // scourge
-		],
-		vtols: [
-			{ res: "R-Wpn-Rocket05-MiniPod", stat: "Rocket-VTOL-Pod", weight: WEIGHT.ULTRALIGHT }, // pod
-			{ res: "R-Wpn-Rocket01-LtAT", stat: "Rocket-VTOL-LtA-T", weight: WEIGHT.LIGHT }, // lancer
-			{ res: "R-Wpn-Rocket07-Tank-Killer", stat: "Rocket-VTOL-HvyA-T", weight: WEIGHT.LIGHT }, // tk
-			{ res: "R-Wpn-Missile2A-T", stat: "Missile-VTOL-AT", weight: WEIGHT.LIGHT }, // scourge
-		],
-		defenses: [
-			// rocket turtle AI needs early AT gateway towers, hence duplicate stat
-			{ res: "R-Defense-Tower06", stat: "GuardTower6", defrole: DEFROLE.GATEWAY }, // pod tower
-			{ res: "R-Defense-Tower06", stat: "GuardTower6", defrole: DEFROLE.STANDALONE }, // pod tower
-			{ res: "R-Defense-Pillbox06", stat: "GuardTower5", defrole: DEFROLE.STANDALONE }, // lancer tower
-			{ res: "R-Defense-WallTower06", stat: "WallTower06", defrole: DEFROLE.GATEWAY }, // lancer hardpoint
-			{ res: "R-Defense-HvyA-Trocket", stat: "Emplacement-HvyATrocket", defrole: DEFROLE.STANDALONE }, // tk emplacement
-			{ res: "R-Defense-WallTower-HvyA-Trocket", stat: "WallTower-HvATrocket", defrole: DEFROLE.GATEWAY }, // tk hardpoint
-			{ res: "R-Defense-Super-Rocket", stat: "X-Super-Rocket", defrole: DEFROLE.FORTRESS }, // rocket bastion
-			{ res: "R-Defense-GuardTower-ATMiss", stat: "GuardTower-ATMiss", defrole: DEFROLE.STANDALONE }, // scourge tower
-			{ res: "R-Defense-WallTower-A-Tmiss", stat: "WallTower-Atmiss", defrole: DEFROLE.GATEWAY }, // scourge hardpoint
-			{ res: "R-Defense-Super-Missile", stat: "X-Super-Missile", defrole: DEFROLE.FORTRESS }, // missile fortress
-		],
-		templates: [
-			{ res: "R-Wpn-Rocket01-LtAT", body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "CyborgRocket", ] }, // lancer borg
-			{ res: "R-Cyborg-Hvywpn-TK", body: "CyborgHeavyBody", prop: "CyborgLegs", weapons: [ "Cyb-Hvywpn-TK", ] }, // tk super
-			{ res: "R-Wpn-Missile2A-T", body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "Cyb-Wpn-Atmiss", ] }, // scourge borg
-			{ res: "R-Cyborg-Hvywpn-A-T", body: "CyborgHeavyBody", prop: "CyborgLegs", weapons: [ "Cyb-Hvywpn-A-T", ] }, // scourge super
-		],
-		extras: [
-			"R-Wpn-Rocket-ROF03",
-			"R-Wpn-Missile-Damage03",
-			"R-Wpn-Missile-ROF03",
-			"R-Wpn-Missile-Accuracy02",
-		],
-	},
-	rockets_Arty: {
-		roles: [ 0.2, 0.4, 0.4, 0.0 ],
-		chatalias: "rxarty",
-		micro: MICRO.DUMB,
-		weapons: [
-			{ res: "R-Wpn-Rocket02-MRL", stat: "Rocket-MRL", weight: WEIGHT.LIGHT }, // mra
-			{ res: "R-Wpn-Rocket03-HvAT", stat: "Rocket-BB", weight: WEIGHT.MEDIUM }, // bb
-			{ res: "R-Wpn-Rocket06-IDF", stat: "Rocket-IDF", weight: WEIGHT.ULTRAHEAVY }, // ripple
-			{ res: "R-Wpn-MdArtMissile", stat: "Missile-MdArt", weight: WEIGHT.HEAVY }, // seraph
-			{ res: "R-Wpn-HvArtMissile", stat: "Missile-HvyArt", weight: WEIGHT.ULTRAHEAVY }, // archie
-		],
-		vtols: [
-			{ res: "R-Wpn-Rocket03-HvAT", stat: "Rocket-VTOL-BB", weight: WEIGHT.LIGHT }, // bb
-		],
-		defenses: [
-			{ res: "R-Defense-MRL", stat: "Emplacement-MRL-pit", defrole: DEFROLE.STANDALONE }, // mra
-			{ res: "R-Defense-IDFRocket", stat: "Emplacement-Rocket06-IDF", defrole: DEFROLE.ARTY }, // ripple
-			{ res: "R-Defense-MdArtMissile", stat: "Emplacement-MdART-pit", defrole: DEFROLE.STANDALONE }, // seraph
-			{ res: "R-Defense-HvyArtMissile", stat: "Emplacement-HvART-pit", defrole: DEFROLE.ARTY }, // archie
-		],
-		templates: [],
-		extras: [],
-	},
-	rockets_AS: {
-		roles: [ 0.0, 0.0, 1.0, 0.0 ],
-		chatalias: "rxas",
-		micro: MICRO.RANGED,
-		weapons: [
-			{ res: "R-Wpn-Rocket03-HvAT", stat: "Rocket-BB", weight: WEIGHT.MEDIUM }, // bb
-		],
-		vtols: [
-			{ res: "R-Wpn-Rocket03-HvAT", stat: "Rocket-VTOL-BB", weight: WEIGHT.LIGHT }, // bb
-		],
-		defenses: [],
-		templates: [],
-		extras: [],
-	},
-	rockets_AA: {
-		roles: [ 0.0, 0.0, 0.0, 1.0 ],
-		chatalias: "rxaa",
-		micro: MICRO.RANGED,
-		weapons: [
-			{ res: "R-Wpn-Sunburst", stat: "Rocket-Sunburst", weight: WEIGHT.LIGHT }, // sunburst
-			{ res: "R-Wpn-Missile-LtSAM", stat: "Missile-LtSAM", weight: WEIGHT.LIGHT }, // avenger
-			{ res: "R-Wpn-Missile-HvSAM", stat: "Missile-HvySAM", weight: WEIGHT.HEAVY }, // vindicator
-		],
-		vtols: [
-			{ res: "R-Wpn-Sunburst", stat: "Rocket-VTOL-Sunburst", weight: WEIGHT.LIGHT }, // sunburst a2a
-		],
-		defenses: [
-			{ res: "R-Defense-Sunburst", stat: "P0-AASite-Sunburst", defrole: DEFROLE.STANDALONE }, // sunburst
-			{ res: "R-Defense-SamSite1", stat: "P0-AASite-SAM1", defrole: DEFROLE.STANDALONE }, // avenger
-			{ res: "R-Defense-WallTower-SamSite", stat: "WallTower-SamSite", defrole: DEFROLE.GATEWAY }, // avenger
-			{ res: "R-Defense-SamSite2", stat: "P0-AASite-SAM2", defrole: DEFROLE.STANDALONE }, // vindicator
-			{ res: "R-Defense-WallTower-SamHvy", stat: "WallTower-SamHvy", defrole: DEFROLE.GATEWAY }, // vindicator hardpoint
-		],
-		templates: [],
-		extras: [],
-	},
-	lasers: {
-		roles: [ 0.2, 0.6, 0.2, 0.0],
-		chatalias: "ls",
-		micro: MICRO.RANGED,
-		weapons: [
-			{ res: "R-Wpn-Laser01", stat: "Laser3BEAMMk1", weight: WEIGHT.ULTRALIGHT }, // flash
-			{ res: "R-Wpn-Laser02", stat: "Laser2PULSEMk1", weight: WEIGHT.HEAVY }, // pulse
-			{ res: "R-Wpn-HvyLaser", stat: "HeavyLaser", weight: WEIGHT.ULTRAHEAVY }, // hvy laser
-		],
-		vtols: [
-			{ res: "R-Wpn-Laser01", stat: "Laser3BEAM-VTOL", weight: WEIGHT.ULTRALIGHT }, // flash
-			{ res: "R-Wpn-Laser02", stat: "Laser2PULSE-VTOL", weight: WEIGHT.HEAVY }, // pulse
-			{ res: "R-Wpn-HvyLaser", stat: "HeavyLaser-VTOL", weight: WEIGHT.HEAVY }, // hvy laser
-		],
-		defenses: [
-			{ res: "R-Defense-PrisLas", stat: "Emplacement-PrisLas", defrole: DEFROLE.STANDALONE }, // flash empl
-			{ res: "R-Defense-PulseLas", stat: "GuardTower-BeamLas", defrole: DEFROLE.STANDALONE }, // pulse tower
-			{ res: "R-Defense-WallTower-PulseLas", stat: "WallTower-PulseLas", defrole: DEFROLE.GATEWAY }, // pulse hard
-			{ res: "R-Defense-HeavyLas", stat: "Emplacement-HeavyLaser", defrole: DEFROLE.STANDALONE }, // hvy empl
-		],
-		templates: [
-			{ res: "R-Wpn-Laser01", body: "CyborgLightBody", prop: "CyborgLegs", weapons: [ "Cyb-Wpn-Laser", ] }, // flash borg
-			{ res: "Cyb-Hvy-PulseLsr", body: "CyborgHeavyBody", prop: "CyborgLegs", weapons: [ "Cyb-Hvywpn-PulseLsr", ] }, // pulse super
-		],
-		extras: [],
-	},
-	useless_AT: {
-		roles: [ 1.0, 0.0, 0.0, 0.0 ],
-		chatalias: "useless_AT",
-		weapons: [
-			{ stat: "CannonSuper" }, // cannon fort weapon
-			{ stat: "RocketSuper" }, // rocket bastion weapon
-			{ stat: "MissileSuper" }, // missile fort weapon
-			{ stat: "MassDriver" }, // mass driver fort weapon
-			{ stat: "MortarEMP" }, // emp mortar
-			{ stat: "EMP-Cannon" }, // emp cannon
-		],
-		vtols: [],
-		defenses: [],
-		templates: [],
-		extras: [],
-	},
-	useless_AP: {
-		roles: [ 0.0, 1.0, 0.0, 0.0 ],
-		chatalias: "useless_AP",
-		weapons: [
-			{ stat: "MG1-Pillbox" }, // imaginary invisible single mg, may be found on some maps
-			{ stat: "MG2-Pillbox" }, // imaginary invisible twin mg, may be found on some maps
-			{ stat: "MG3-Pillbox" }, // mg bunker dedicated weapon
-			{ stat: "NEXUSlink" }, // nexus link (still unused)
-			{ stat: "MG4ROTARY-Pillbox" }, // ag bunker dedicated weapon
-		],
-		vtols: [],
-		defenses: [],
-		templates: [],
-		extras: [],
-	},
-	useless_AS: {
-		roles: [ 0.0, 0.0, 1.0, 0.0 ],
-		chatalias: "useless_AS",
-		weapons: [
-			{ stat: "PlasmaHeavy" }, // plasma cannon (still unused)
-		],
-		vtols: [],
-		defenses: [],
-		templates: [],
-		extras: [],
-	},
-	useless_AA: {
-		roles: [ 0.0, 0.0, 0.0, 1.0 ],
-		chatalias: "useless_AA",
-		weapons: [
-			{ stat: "QuadMg1AAGun" }, // hurricane (still unused)
-			{ stat: "QuadRotAAGun" }, // whirlwind (still unused)
-		],
-		vtols: [],
-		defenses: [],
-		templates: [],
-		extras: [],
-	},
-};
diff --git a/data/mp/multiplay/skirmish/nb_turtle.js b/data/mp/multiplay/skirmish/nb_turtle.js
deleted file mode 100644
index e68fb81..0000000
--- a/data/mp/multiplay/skirmish/nb_turtle.js
+++ /dev/null
@@ -1,99 +0,0 @@
-
-/*
- * This file defines a standard AI personality for the base game.
- *
- * It relies on ruleset definition in /rulesets/ to provide
- * standard strategy descriptions and necessary game stat information.
- *
- * Then it passes control to the main code.
- *
- */
-
-// You can redefine these paths when you make a customized AI
-// for a map or a challenge.
-NB_PATH = "/multiplay/skirmish/";
-NB_INCLUDES = NB_PATH + "nb_includes/";
-NB_RULESETS = NB_PATH + "nb_rulesets/";
-NB_COMMON = NB_PATH + "nb_common/";
-
-// please don't touch this line
-include(NB_INCLUDES + "_head.js");
-
-////////////////////////////////////////////////////////////////////////////////////////////
-// Start the actual personality definition
-
-// the rules in which this personality plays
-include(NB_RULESETS + "standard.js");
-include(NB_COMMON + "standard_build_order.js");
-
-// variables defining the personality
-var subpersonalities = {
-	MR: {
-		chatalias: "mr",
-		weaponPaths: [
-			weaponStats.rockets_AT,
-			weaponStats.machineguns,
-			weaponStats.rockets_AS,
-			weaponStats.rockets_AA,
-			weaponStats.rockets_Arty,
-		],
-		earlyResearch: [
-			"R-Defense-Tower01",
-			"R-Defense-Pillbox01",
-			"R-Defense-Tower06",
-			"R-Defense-MRL",
-		],
-		minTanks: 3, becomeHarder: 3, maxTanks: 21,
-		minTrucks: 5, minHoverTrucks: 4, maxSensors: 6,
-		minMiscTanks: 1, maxMiscTanks: 6,
-		vtolness: 100,
-		defensiveness: 100, // this enables turtle AI specific code
-		maxPower: 300,
-		repairAt: 50,
-	},
-	MC: {
-		chatalias: "mc",
-		weaponPaths: [
-			weaponStats.cannons,
-			weaponStats.machineguns,
-			weaponStats.mortars,
-			weaponStats.fireMortars,
-			weaponStats.cannons_AA,
-		],
-		earlyResearch: [
-			"R-Defense-Tower01",
-			"R-Defense-Pillbox04",
-			"R-Defense-WallTower02",
-			"R-Defense-MortarPit",
-		],
-		minTanks: 3, becomeHarder: 3, maxTanks: 21,
-		minTrucks: 5, minHoverTrucks: 4, maxSensors: 6,
-		minMiscTanks: 1, maxMiscTanks: 6,
-		vtolness: 100, defensiveness: 100,
-		maxPower: 300,
-		repairAt: 50,
-	},
-};
-
-// this function describes the early build order
-// you can rely on personality.chatalias for choosing different build orders for
-// different subpersonalities
-function buildOrder() {
-	// Only use this build order in early game, on standard difficulty, in T1 no bases.
-	// Otherwise, fall back to the safe build order.
-	if (gameTime > 300000 || difficulty === INSANE
-	                      || isStructureAvailable("A0ComDroidControl") || baseType !== CAMP_CLEAN)
-		return buildOrder_StandardFallback();
-	if (buildMinimum(structures.factories, 1)) return true;
-	if (buildMinimum(structures.labs, 1)) return true;
-	if (buildMinimum(structures.hqs, 1)) return true;
-	if (buildMinimum(structures.labs, 3)) return true;
-	if (buildMinimum(structures.gens, 1)) return true;
-	if (buildMinimumDerricks(3)) return true;
-	return withChance(25) ? captureSomeOil() : buildDefenses();
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-// Proceed with the main code
-
-include(NB_INCLUDES + "_main.js");
diff --git a/data/mp/multiplay/skirmish/nb_turtle.json b/data/mp/multiplay/skirmish/nb_turtle.json
deleted file mode 100644
index 7a49a80..0000000
--- a/data/mp/multiplay/skirmish/nb_turtle.json
+++ /dev/null
@@ -1,7 +0,0 @@
-{
-    "AI": {
-        "js": "nb_turtle.js",
-        "name": "Turtle AI",
-        "tip": "Tower wars AI, based on NullBot"
-    }
-}
diff --git a/data/mp/multiplay/skirmish/nexus.json b/data/mp/multiplay/skirmish/nexus.json
deleted file mode 100644
index d9028fc..0000000
--- a/data/mp/multiplay/skirmish/nexus.json
+++ /dev/null
@@ -1,8 +0,0 @@
-{
-    "AI": {
-        "name": "Nexus",
-        "slo": "nexus.slo",
-        "tip": "Default AI",
-        "vlo": "nexus.vlo"
-    }
-}
diff --git a/data/mp/multiplay/skirmish/nexus.slo b/data/mp/multiplay/skirmish/nexus.slo
deleted file mode 100644
index 0e377d4..0000000
--- a/data/mp/multiplay/skirmish/nexus.slo
+++ /dev/null
@@ -1,4147 +0,0 @@
-/////////////////////////////////////////////////////////////////////
-// general ai for skirmish game
-/////////////////////////////////////////////////////////////////////
-// Warzone2100, Pumpkin Studios,
-// alex lee.98/99.
-//
-/////////////////////////////////////////////////////////////////////
-
-//Tile in world units
-#define	TILE					128
-#define	NONE					(-1)
-
-// These are final rules of the lexical parser
-#define	R_REQUEST_HELP			"help me"
-#define	R_REQUEST_BEACON		"drop a beacon"
-#define	R_REPORT_SAFETY			"i'm ok"
-#define R_REQUEST_ALLY			"ally me"
-
-// These are our own messages - lexical parser should be able to handle them
-#define M_REQUEST_HELP			"help me!!"
-#define M_REQUEST_BEACON		"drop a beacon"
-#define M_AFFIRMATIVE_OK		"ok"
-#define M_AFFIRMATIVE_ROGER		"roger"
-#define M_ANNOYED				"bug off"
-#define M_HELPERS_KILLED		"that was all I had.."
-#define M_HELP_NO_UNITS			"I don't have anything"
-
-#define	MAX_PROBABILITY			100
-
-// Base threat range in world units
-#define	W_BASE_THREAT_RANGE		((17 + (mapWidth + mapHeight) / 2 / 35) * TILE)
-#define ALL_ALLIES				-1
-
-#define	BASE_DEFEND_DURATION	(3 * 60)
-
-// Delay before we repeat our request, in seconds
-#define HELP_REQUEST_INTERVAL	(3 * 60)
-
-//in secs
-#define BEACON_TIMEOUT			30
-
-#define	MAX_DROIDS				150
-
-//range for trucks to look for more oil
-#define MORE_OIL_RANGE			(10 * TILE)
-//don't try to build on oil if there's threat within this range
-#define	OIL_THREAT_RANGE		(9 * TILE)
-
-#define	MAX_TRUCKS				12
-#define	MIN_TRUCKS				5
-
-//Enter power saving mode when lower than this
-#define	LOW_POWER				250
-
-//Target type values
-#define	NO_TARGET_VALUE			0
-#define	DROID_TARGET_VALUE		1
-#define	OTHER_TARGET_VALUE		2
-#define	DEFENSE_TARGET_VALUE	3
-#define	RESEARCH_TARGET_VALUE	4
-#define	HQ_TARGET_VALUE			5
-#define	OIL_TARGET_VALUE		6
-#define	FACTORY_TARGET_VALUE	7
-
-#define	UNLIMITED 				(-1)
-
-#define	AA_THREAT_RANGE			(TILE * 12)
-
-#define	MAX_DEFENDERS_RADIUS	(TILE * 40)
-
-#define	MAX_VTOL_DEFEND_RADIUS	(TILE * 25)
-
-// AI will remember max this number of structures
-#define	MAX_REBUILD_STRUCT		100
-
-//Total number of technology branches
-#define	TECHS					2
-
-//How many best templates to choose from when deciding what template to build
-#define	MAX_RANDOM_TEMPLATES	4
-
-
-
-private	int				me;			// player for this instance.
-public	int				tileExpand;			// rate of exploration
-
-public	int				numScouts[TECHS],maxScouts[TECHS];			// aim for...
-public	int				numDefenders[TECHS],maxDefenders[TECHS];
-public	int				numAttackers[TECHS],maxAttackers[TECHS];
-public	int				numCyborgs[TECHS],maxCyborgs[TECHS];
-
-public	int				branchDefault,branchVTOL,techCount[TECHS],maxVtolFacs[TECHS],maxIdleRes[TECHS],
-						maxVTOLs[TECHS],numVtolTargets,vtolTargetWeight[10],numRebuildStat[TECHS];
-public	RESEARCHSTAT	tech[TECHS][30];		//technology for different research branches
-public	STRUCTURESTAT	vtolTarget[10],rebuildStat[TECHS][2];
-
-// structures
-private int				baseX,baseY,minx,miny,maxx,maxy;
-public	int				numStructs,numIncendrys,numDefStructs,numExtraStructs[TECHS],numWallWeaps,numBaseStruct,numLightCyborgs,numFundamental;
-private	STRUCTURESTAT	structChoice[5];
-public	STRUCTURESTAT	incendrys[8],structs[13],defStructs[26],extraStructs[TECHS][6],wallWeaps[11];
-public	STRUCTURESTAT	sensorTower,wall,cornerWall,resLab,powGen,playerHQ,lassat,factory,derrick,cybFactory,
-						vtolDefStruct[5],vtolPad,vtolFactory,uplink,baseStruct[8];
-public	STRUCTURESTAT	powModule,facModule,resModule,vtolModule;
-public	int				extraStruct;
-
-// unit templates
-public	int				numTemplates[TECHS];
-public	TEMPLATE		tmpl[TECHS][70];
-private	TEMPLATE		tmplChoice[5];
-
-public	TEMPLATE		cybTempl[10],superCyb[4],cybMechanic,cybEngineer,hovertruck;
-
-public	TEMPLATE		vtols[18];
-public	int				numVtolTemplates;
-
-public	TEMPLATE		sense[11];
-public	int				numSenseTemplates;
-
-public	TEMPLATE		constructor,repairUnit;
-public	int				numRepairUnits;
-
-//defend
-private GROUP			defendGroup;
-private bool			defendbusy;
-private BASEOBJ			defendObj;
-
-public  RESEARCHSTAT		nexusDefence;
-private  RESEARCHSTAT		research;
-
-//build
-private GROUP			buildGroup;
-private int				buildX,buildY,buildX2,buildY2;
-public	FEATURESTAT		oilRes;
-
-// scout
-private GROUP			scoutGroup;
-private int				scoutX,scoutY;
-private int				scoutTLX,scoutTLY,scoutW,scoutH;
-
-// attack
-private GROUP			attackGroup;
-private BASEOBJ			attackObj,allOutAttack,vtolGrAttackObj[10];
-
-// vtols
-private GROUP			vtolDefendGr,vtolAttackGr[10];
-
-// generic
-private STRUCTURE		structure,structure2,rebuildObj[100];
-private DROID			droid;
-private FEATURE			feature;
-private BASEOBJ			baseobj,baseobj2;
-private int				count,count2,result,result2,tempx,tempy;
-private bool			boolResult,boolResult2;
-
-private bool			powerSave,_DEBUG,bRunning;
-// Hopefully this will be at least as large as MAX_PLAYERS... Why can't I just use MAX_PLAYERS as the array size?!
-// P.S. And why can't I put a comment on the same line as a #define??!! Gah, who cares if the lua2 branch works, lets switch to it, anyway.
-#define MAX_PLAYERS_HACK 17
-private	int				allianceTime[MAX_PLAYERS_HACK];
-private int				sender,x,y,beaconX[8],beaconY[8],tBeacon[8],
-						tLastHelpRequest,lastHelpPlayer,tHelp,tHelpTimeout,helpX,helpY;
-private string			message;
-
-private	int				defendX,defendY,__defendRadiusUnused,tDefendStart,tDefendTimeout,
-						defendMoveType,baseRange,curTech,numVtolAttackGroups,numAttackVtols,
-						numDefendVtols,rebuildStructX[MAX_REBUILD_STRUCT],rebuildStructY[MAX_REBUILD_STRUCT],countRebuildStruct;
-private	STRUCTURESTAT	rebuildStructStat[MAX_REBUILD_STRUCT];
-
-private STRUCTURESTAT		fundamentalBeingBuilt;
-private int			order;	// callback global
-
-/////////////////////////////////////////////////////////////////////
-// triggers.
-
-#region triggers
-trigger reachedTr				(CALL_DROID_REACH_LOCATION, me, ref droid, ref order);
-trigger buildExpandTr				(every, 600);
-trigger fortifyTr					(every,	1000);
-trigger upgradeStructuresTr			(every, 360);
-trigger conDroidsTr					(every, 900);	// was 1400
-trigger repairDroidsTr				(every, 2600);
-trigger basedetailsTr				(every, 600	);
-trigger buildDerrickTr				(every, 80	);
-trigger buildOilDefenseOrRetreatTr	(every, 120	);
-trigger incendryTr					(every, 250 );
-trigger buildPowerGeneratorsTr		(every, 80	);
-trigger buildBaseTr					(every, 150	);
-trigger finishStructsTr				(every, 210);
-trigger droidBuiltTr				(CALL_NEWDROID,me, ref droid,ref structure);
-trigger	structBuiltTr				(CALL_STRUCTBUILT, me, ref droid, ref structure);
-trigger droidDestroyedTr			(CALL_DROID_DESTROYED,  me, ref droid);
-trigger	structureDestroyedTr		(CALL_STRUCT_DESTROYED, me, ref structure);
-trigger	rebuildStructureTr			(every, 50);
-trigger consolidateEventTr			(every,	3100);
-trigger factoryEventTr				(every, 170	);
-trigger cyborgFactoryEventTr		(every, 170	);
-trigger chooseScoutAreaTr			(every,	200	);
-trigger expandScoutAreaTr			(every,	600	);
-trigger scoutMainTr					(every,	150	);
-trigger newObjectReportTr			(CALL_OBJ_SEEN, me, ref baseobj, ref baseobj2);
-trigger attackStuffTr				(every, 300	);
-trigger allOutAttackTr				(every, 4000);
-trigger defendWatchTr				(CALL_STRUCT_ATTACKED, me, ref structure, ref baseobj);
-trigger defendReturnTr				(every,	500	);
-trigger doResearchTr				(CALL_RESEARCHCOMPLETED, ref research, ref structure, me);
-trigger vtolDefendTr				(CALL_STRUCT_ATTACKED, me, ref structure, ref baseobj);
-trigger vtolStructsTr				(every, 290);
-trigger buildVtolsTr				(every, 360);
-trigger vtolAttackTr				(every, 150);
-trigger vtolEnablerTr				(every, 700);
-trigger takeoverTr					(CALL_UNITTAKEOVER, ref droid);
-trigger useLassatTr					(every, 3000);
-trigger reassignTr					(CALL_PLAYERLEFT,ref count);
-trigger formAllianceEventTr			(every,170);
-trigger breakAllianceEventTr		(every,3000);
-trigger difficultyModifierTr		(every,600);
-trigger humanAllianceTr				(CALL_ALLIANCEOFFER,ref count, ref count2);
-trigger multiMsgTr					(CALL_AI_MSG, me, ref sender, ref message);
-trigger	beaconTr					(CALL_BEACON, me, ref sender, ref x, ref y, ref message);
-trigger consoleTr					(CALL_CONSOLE, ref sender, ref message);
-trigger watchBaseThreatTr			(every, 120);
-trigger manageAllyHelpTr			(every, 80);
-trigger everySec					(every, 10);
-trigger manageDefendLocationTr		(every, 70);
-trigger startLevelTr				(CALL_START_NEXT_LEVEL);
-trigger chainloadTr				(wait, 1);
-trigger slowloadTr				(wait, 13);
-trigger checkResearchTr				(every, 400);
-
-/* Events */
-event	conDroids;
-event	multiMsgEv;
-event	beaconEv;
-event	watchBaseThreat;
-event	manageAllyHelp;
-event	everySecEv;
-event	manageDefendLocationEv;
-event	structureDestroyed;
-event	rebuildStructureEv;
-event	doResearch;
-event	buildDerrick;
-
-/* Function prototypes */
-function bool haveBeacon(int _player);
-function bool beaconTimeout(int _player);
-function void processCommand(string _message, int _sender, bool _bBlipMessage);
-function bool haveHelpers();
-function bool attemptToHelp(int _playerToHelp, int _x, int _y);
-function void helpPlayer(int _playerToHelp, int _helpX, int _helpY);
-function bool canStopHelpingAlly();
-function void stopHelpingAlly();
-function bool helpingAlly();
-function bool helpAllyTimeout();
-function void requestHelp(int _helpX, int _helpY);
-function void doRequestHelp(int _helpX, int _helpY);
-function bool allyBaseAtLoc(int _ally, int _x, int _y);
-function void messagePlayer(int _playerToMessage, string _message, int _probability);
-function void messagePlayerAddressed(int _playerToMessage, int _playersToAddress, string _message);
-function bool canSeeAllies();
-function bool baseInTrouble();
-function string m_affirmative();
-function void defendLocation(int _defendX, int _defendY, int _tDefendTimeout, bool _bMove);
-function void stopDefendingLocation();
-function bool defendingLocation();
-function bool defendLocationTimeout();
-function bool friendlyPlayer(int _playerToCheck);
-function void factoryBuildDroid(STRUCTURE _factory);
-function void cybFactorBuildCyborg(STRUCTURE _factory);
-function void vtolFactoryBuildVtol(STRUCTURE _factory);
-function bool insideBase(int _x, int _y);
-function int numAlliesInBase(bool _bVtols);
-function int numEnemiesInBase(bool _bVtols);
-function bool defendingOwnBase();
-function int targetTypeValue(BASEOBJ _target);
-function int numBitsSet(int _integer);
-function int findResearch(int _searchStart, int _techTree);
-function bool upgradeFactory(DROID _truck, int _maxBuilders);
-function bool upgradeVtolFactory(DROID _truck, int _maxBuilders);
-function bool upgradeResearch(DROID _truck, int _maxBuilders);
-function bool upgradePowGen(DROID _truck, int _maxBuilders);
-function void buildRearmPads();
-function int numEnemyAAInRange(int _x, int _y, int _range);
-function BASEOBJ chooseVtolTarget(bool bExclusiveTarget);
-function int getVtolTargetWeight(BASEOBJ _target);
-function bool vtolTargetAssigned(BASEOBJ _target);
-function int numBuildSameBuilding(STRUCTURESTAT _checkStat, int _x, int _y);
-function int totalVtols();
-function bool needTank();
-function void setTechBranch(int _tech);
-function DROID closestIdleTruck(int _x, int _y);
-function void buildOnExactLocation(DROID _truck, int _x, int _y, STRUCTURESTAT _stat);
-function void rebuildStructures();
-function BASEOBJ chooseVtolDefenceTarget(int _x, int _y, int _range, bool bExclusiveTarget);
-function int numGroupSameOrder(GROUP _group, int _orderIndex);
-function void rearrangeAttackVtols();
-function int numStructBusyByType(STRUCTURESTAT _busyStructType);
-function bool aiResponsibleForPlayer(int _player);
-function void reassignAI();
-function void shutDownAI();
-function bool buildUnit(TEMPLATE _tankTemplate, STRUCTURE _factory, STRUCTURESTAT _factoryType, bool _bIdleOnly);
-function STRUCTURE findIdleStructure(STRUCTURESTAT _structType, bool _bIdleOnly);
-#endregion triggers
-
-/////////////////////////////////////////////////////////////////////
-// HouseKeeping
-event initialisedEvent(CALL_GAMEINIT)
-{
-	local int player;
-	// initialise
-	me = getPlayer("Nexus");
-	_DEBUG = FALSE;
-	dbgMsgOn(me, _DEBUG);
-
-	extraStruct = 0;
-	numRepairUnits = 0;
-	allOutAttack = NULLOBJECT;
-
-	tLastHelpRequest = -1;	//when we requested help for the last time
-	lastHelpPlayer = -1;		//we are not currently helping anyone
-	tHelp = -1;					//when we started helping last time
-	tHelpTimeout = -1;			//time when help times out
-	helpX = -1;
-	helpY = -1;
-	defendX = -1;
-	defendY = -1;
-	tDefendStart = -1;
-	tDefendTimeout = -1;
-	defendMoveType = -1;		//move or scout
-
-	baseRange = 4 * TILE;
-
-	// set current research branch
-	setTechBranch(-1);
-
-	numVtolAttackGroups = 10;
-	numAttackVtols = 10;	//num vtols in an attack group
-	numDefendVtols = 5;	//num vtols in an attack group
-
-	// setup build group - all initial droids are in buildgroup!
-	groupAddArea(buildGroup, me, 0, 0, (mapWidth*128), (mapHeight*128));
-
-	// note where our base is.
-	getPlayerStartPosition(me, ref baseX, ref baseY);
-
-	// defence.
-	defendbusy = FALSE;
-
-	// setup scouts
-	structure = getStructure(factory, me);
-	if(structure != NULLOBJECT)
-	{
-		scoutTLX		= structure.x;
-		scoutTLY		= structure.y;
-	}
-	else
-	{
-		scoutTLX		= baseX;
-		scoutTLY		= baseY;
-	}
-	scoutW			= 256;
-	scoutH			= 256;
-	scoutX			= scoutTLX;
-	scoutY			= scoutTLY;
-
-	// clear the alliance array...
-	player = 0;
-	while (player != MAX_PLAYERS)
-	{
-		allianceTime[player] = 0;
-		player = player + 1;
-	}
-
-	fundamentalBeingBuilt = derrick;	// to avoid ever being null
-	
-	if(aiResponsibleForPlayer(me))
-	{
-		bRunning = true;
-	}
-	else
-	{
-		bRunning = false;
-		shutDownAI();
-	}
-}
-
-// check whether we have at least one structure of that type
-function bool haveStructure(STRUCTURESTAT type) 
-{
-	return getStructure(type, me) != NULLOBJECT;
-}
-
-// check if we are getting any income
-function bool havePowerSource()
-{
-	// we don't check buildings being finished here
-	return haveStructure(powGen) and haveStructure(derrick);
-}
-
-// I am not sure why we need this hack, but the AI can still end up not researching anything at times
-event checkResearch(checkResearchTr)
-{
-	setEventTrigger(doResearch, chainloadTr);
-}
-
-function void dbgPlr(string message)
-{
-	setEventTrigger(doResearch, chainloadTr);
-	if (me == selectedPlayer)
-	{
-		console(message);
-	}
-}
-
-function void dbgObj(DROID obj, string message)
-{
-	if (obj.selected)
-	{
-		console(message);
-	}
-}
-
-function bool conCanHelp(DROID mydroid, int bx, int by)
-{
-	return (mydroid.order != DORDER_HELPBUILD and mydroid.order != DORDER_BUILD and mydroid.order != DORDER_LINEBUILD and droidCanReach(mydroid, bx, by));
-}
-
-// Build something in main base, grab trucks to do it within tiles range
-function bool grabTrucksAndBuild(int range, STRUCTURESTAT bstats, int maxBlockingTiles)
-{
-	local DROID	mydroid, closestDroid;
-	local int	closestDist, currDist, numHelpDroids, tilerange, bx, by;
-
-	initIterateGroup(buildGroup);				// find idle droids in build group.
-	mydroid = iterateGroup(buildGroup);
-	closestDist = 99999;
-	closestDroid = NULLOBJECT;
-	numHelpDroids = 0;
-	tilerange = range * TILE;
-	while (mydroid != NULLOBJECT)
-	{
-		if (conCanHelp(mydroid, baseX, baseY))
-		{
-			bx = baseX;
-			by = baseY;
-			if (pickDroidStructLocation(mydroid, bstats, ref bx, ref by, me, maxBlockingTiles))
-			{
-				currDist = distBetweenTwoPoints(bx, by, mydroid.x, mydroid.y);
-				if (currDist < tilerange)
-				{
-					orderDroidStatsLoc(mydroid, DORDER_BUILD, bstats, bx, by);	// close, so help build it
-					numHelpDroids = numHelpDroids + 1;
-				}
-				else if (currDist < closestDist)
-				{
-					closestDroid = mydroid;	// record this droid as being closest so far
-					closestDist = currDist;
-				}
-			}
-		}
-		mydroid = iterateGroup(buildGroup);
-	}
-	if (numHelpDroids == 0 and closestDroid != NULLOBJECT)	// found none within help radius, so force someone to go long distance traveling
-	{
-		orderDroidStatsLoc(closestDroid, DORDER_BUILD, bstats, bx, by);	// you, book a plane ticket and go!
-		return true;
-	}
-	return (numHelpDroids > 0);
-}
-
-event arrived(reachedTr)
-{
-	local bool found;
-	local STRUCTURESTAT myChoice;
-
-	if (droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT)
-	{
-		dbgObj(droid, "Failed to build where we should - attempt to screw up enemy oil derrick");
-
-		// Check if at oil well, and it was taken by enemy
-		structure = structureBuiltInRange(derrick, droid.x, droid.y, (5 * 128), -1);
-		if (structure != NULLOBJECT)
-		{
-			if (not friendlyPlayer(structure.player) and droid.health == 100)
-			{
-				// Ok, at enemy derrick, and nobody has hurt us yet. Start being nasty.
-				count = 0;
-				found = false;
-				// find simplest/cheapest one available to build
-				while (count < numDefStructs and not found)
-				{
-					if (isStructureAvailable(defStructs[count], me))
-					{
-						found = true;
-					}
-					else
-					{
-						count++;
-					}
-				}
-				if (found)
-				{
-					buildX = droid.x;
-					buildY = droid.y;
-					if (pickDroidStructLocation(droid, defStructs[count], ref buildX, ref buildY, me, -1))
-					{
-						orderDroidStatsLoc(droid, DORDER_BUILD, defStructs[count], buildX, buildY);
-					}
-					else
-					{
-						dbgObj(droid, "Wanted to be nasty, but found nowhere to build defense");
-						orderDroid(droid, DORDER_RTB);		// nothing more to do here.
-					}
-				}
-				else
-				{
-					dbgObj(droid, "Wanted to be nasty, but had nothing nasty to build - returning to base");
-					orderDroid(droid, DORDER_RTB);		// oh, well. nothing more to do here.
-				}
-				exit;
-			}
-			else if (droid.health < 100 and !insideBase(droid.x, droid.y))
-			{
-				orderDroid(droid, DORDER_RTR);		// bolt back to base now!
-				exit;
-			}
-		}
-	}
-}
-
-event buildFundamentals(inactive)
-{
-	count = 0;
-	while (count < numFundamental)
-	{
-		// check that struct.
-		structure = getStructure(structs[count], me);
-		if (structure == NULLOBJECT)				// if missing build it.
-		{
-			if (isStructureAvailable(structs[count], me))
-			{
-				if (grabTrucksAndBuild(12, structs[count], 0))
-				{
-					exit;	// no need to check more
-				}
-			}
-		}
-		count = count + 1;
-	}
-	fundamentalBeingBuilt = derrick;
-	setEventTrigger(buildFundamentals, inactive);
-}
-
-event startLevel(startLevelTr)
-{
-	setEventTrigger(buildFundamentals, slowloadTr);
-	setEventTrigger(conDroids, chainloadTr);
-	setEventTrigger(doResearch, chainloadTr);
-	setEventTrigger(buildDerrick, slowloadTr);
-	setEventTrigger(startLevel, inactive);
-}
-
-// decide what technology branch we will use
-function void setTechBranch(int _tech)
-{
-	local float		_y2,_y1,_x2,_x1,_a,_y,_m,_rnd,_mapSize;
-
-	_mapSize = (float)((mapWidth + mapHeight) / 2);
-
-	if(_tech != -1)
-	{
-		curTech = _tech;
-	}
-	else
-	{
-		//probability to choose vtol branch for map size 90 = 0; probability for map size 200 = 45
-		//build a linear function: y = ((y2 - y1) / (x2 - x1)) * x + a depending on two values given (short: y = mx+a)
-		_x1 = 90.0; _y1 = 0.0;
-		_x2 = 200.0; _y2 = 45.0;
-		_m = ((_y2 - _y1) / (_x2 - _x1));
-		_a = -(_m * _x1);
-
-		//calculate probability for the current map
-		_y = _m * _mapSize + _a;
-
-		dbg("_m = " & _m & ", a = " & _a, me);
-
-		_rnd = (float)random(100);
-		if(_rnd  < _y)
-		{
-			curTech = branchVTOL;
-			dbg("going air (" & _y & "/" & _rnd & ")", me);
-		}
-		else
-		{
-			curTech = branchDefault;
-			dbg("going land (" & _y & "/" & _rnd & ")", me);
-		}
-	}
-}
-
-/* returns TRUE if AI is responsible for the _player */
-function bool aiResponsibleForPlayer(int _player)
-{
-	if(not _DEBUG and ((_player == selectedPlayer) or not myResponsibility(_player)))
-	{
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-/////////////////////////////////////////////////////////////////////
-// keep details about the size and postion of the ai players base
-event basedetails(basedetailsTr)
-{
-	// clear old extremities.
-	maxy = 0;
-	maxx = 0;
-	miny = (mapHeight*128);
-	minx = (mapWidth*128);
-
-	baseRange = 4 * TILE;
-
-	// now find the extremities of our vital structures.
-	count = 0;
-	while(count < numBaseStruct)
-	{
-		initEnumStruct(FALSE,baseStruct[count],me,me);
-		structure= enumStruct();
-		while(structure != NULLOBJECT)
-		{
-			if(structure.x < minx)
-			{
-				minx = structure.x;
-			}
-			if(structure.x > maxx)
-			{
-				maxx = structure.x;
-			}
-			if(structure.y < miny)
-			{
-				miny = structure.y;
-			}
-			if(structure.y > maxy)
-			{
-				maxy = structure.y;
-			}
-
-			result = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
-
-			if(result > baseRange){
-				baseRange = result;
-			}
-
-			structure= enumStruct();
-		}
-
-		count = count + 1;
-	}
-
-	result = 3 * 128;
-	minx = minx - result;
-	maxx = maxx + result;
-	miny = miny - result;
-	maxy = maxy + result;
-
-	baseRange = baseRange + (4 * 128);
-}
-
-/////////////////////////////////////////////////////////////////////
-// structure building rules
-
-// build derricks on oil.
-event buildDerrick(buildDerrickTr)
-{
-	local bool	foundOne, _same;
-	local FEATURE	_oil, _closestOil;
-	local int	_bestDist, _newDist;
-	local DROID	_search;
-
-	// what if we can't waste power on building derricks because we don't have a gen yet?
-	if (playerPower(me) < 300 and haveStructure(derrick) and not haveStructure(powGen))
-	{
-		setEventTrigger(buildDerrick, slowloadTr);
-		exit;
-	}
-
-	_bestDist = 99999;
-	_closestOil = NULLOBJECT;
-	foundOne = false;
-	initIterateGroup(buildGroup);				// find all units in build group
-	droid = iterateGroup(buildGroup);
-	while (droid != NULLOBJECT && !foundOne)
-	{
-		if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.order != DORDER_HELPBUILD)
-		{
-			foundOne = true;
-		}
-		else
-		{
-			droid = iterateGroup(buildGroup);
-		}
-	}
-	if (droid != NULLOBJECT)
-	{
-		initGetFeature(oilRes, -1, me);
-		_oil = getFeatureB(me);
-		while (_oil != NULLOBJECT)
-		{
-			_newDist = distBetweenTwoPoints(droid.x, droid.y, _oil.x, _oil.y);
-			_same = false;
-
-			if (_newDist < _bestDist and droidCanReach(droid, _oil.x, _oil.y))	// this one is closer
-			{
-				if (!threatInRange(me, _oil.x, _oil.y, OIL_THREAT_RANGE, FALSE))
-				{
-					initIterateGroup(buildGroup);				// find all units in build group.
-					_search = iterateGroup(buildGroup);
-					foundOne = false;
-					while (_search != NULLOBJECT && !foundOne)
-					{
-						if (_search.orderx == _oil.x and _search.ordery == _oil.y and _search != droid)
-						{
-							_same = true;
-							foundOne = true;
-						}
-						_search = iterateGroup(buildGroup);
-					}
-					if (!_same)	// do not go to same spot as another droid
-					{
-						_bestDist = _newDist;
-						_closestOil = _oil;
-					}
-				}
-			}
-			_oil = getFeatureB(me);
-		}
-		if (_closestOil != NULLOBJECT)
-		{
-			orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _closestOil.x, _closestOil.y); // build a derick
-			if (idleGroup(buildGroup) > 0)
-			{
-				setEventTrigger(buildDerrick, slowloadTr);	// do it again for next droid
-				exit;
-			}
-		}
-	}
-	setEventTrigger(buildDerrick, buildDerrickTr);
-}
-
-/////////////////////////////////////////////////////////////////////
-// if idle and derrick in range and no defense then build defense, else ret to base .
-event buildOilDefenseOrRetreat(buildOilDefenseOrRetreatTr)
-{
-	local	int		_numBuilders,_maxBuilders;
-
-	_maxBuilders = 1;
-
-	// check idle.
-	initIterateGroup(buildGroup);					// find idle droids in build group.
-	droid = iterateGroup(buildGroup);
-	while(droid != NULLOBJECT)
-	{
-		if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.order != DORDER_HELPBUILD)
-		{
-			// if in range of a derrick
-			structure = structureBuiltInRange(derrick, droid.x, droid.y, (5*128), me);
-
-			// if inside base limits then presume ok..
-			if( structure != NULLOBJECT)
-			{
-				if((structure.x > minx) and (structure.y > miny) and (structure.x < maxx) and (structure.y <maxy))
-				{
-					structure = NULLOBJECT;
-				}
-			}
-
-			if(structure != NULLOBJECT)
-			{
-				buildX = structure.x;
-				buildY = structure.y;
-
-				// not many defenses nearby
-				if(numFriendlyWeapStructsInRange(me, buildX, buildY, (3*128), FALSE) < 2)
-				{
-					count = numDefStructs - 1;							//pick a struct to build..
-					count2 = 0;
-					while( (count2 < 5) and (count >= 0) )
-					{
-						if( isStructureAvailable(defStructs[count],me))
-						{
-							structChoice[count2] = defStructs[count];
-							count2 = count2 + 1;
-						}
-						count = count - 1;
-					}
-					count =0;
-					if(count2 > 0)
-					{
-						count = random(count2);						 //count = choice!
-
-						// pick a location
-						boolResult = pickDroidStructLocation(droid, structChoice[count], ref buildX, ref buildY, me, -1);
-
-						_numBuilders = numBuildSameBuilding(NULLSTRUCTURESTAT, buildX, buildY);
-
-						if((boolResult == TRUE) and (_numBuilders < _maxBuilders) and droidCanReach(droid, buildX, buildY))
-						{
-							// build it.
-							orderDroidStatsLoc(droid, DORDER_BUILD,structChoice[count], buildX,buildY);
-							_numBuilders++;
-						}
-					}
-				}
-				else
-				{
-					structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), me);
-					if(structure == NULLOBJECT)
-					{
-						if(!insideBase(droid.x, droid.y))
-						{
-							orderDroid(droid,DORDER_RTB);				// return to base;
-						}
-					}
-				}
-			}
-			else
-			{
-				structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), me);
-				if(structure == NULLOBJECT)
-				{
-					if(!insideBase(droid.x, droid.y))
-					{
-						orderDroid(droid,DORDER_RTB);					// return to base;
-					}
-				}
-			}
-		}
-		droid = iterateGroup(buildGroup);
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-//mortar etc.. rules. build sensor towers and emplacements.
-event incendry(incendryTr)
-{
-	if (not isStructureAvailable(sensorTower, me))
-	{
-		exit;
-	}
-
-	initEnumStruct(FALSE,sensorTower,me,me);
-
-	count = 0;
-	structure = enumStruct();
-	while(structure != NULLOBJECT)
-	{
-		count = count + 1;
-		structure = enumStruct();
-	}
-
-	if (count < (gameTime/4200))		// every 7 mins
-	{
-		// if not found build a sensor tower.
-		// find a place to build.
-		buildX = 0;
-		buildY = 0;
-		initEnumStruct(FALSE,derrick,me,me);
-		structure= enumStruct();
-		while(structure != NULLOBJECT)
-		{
-			count = 0;
-			result = 0;
-			while(count < numDefStructs)
-			{
-				structure2 = structureBuiltInRange(defStructs[count], structure.x, structure.y,(4*128), me);
-				if(structure2 != NULLOBJECT)
-				{
-					result = result + 1;
-				}
-				count = count + 1;
-			}
-
-			// check for sensor nearby,
-			structure2 = structureBuiltInRange(sensorTower, structure.x, structure.y,(5*128), me);
-			if(structure2 != NULLOBJECT)
-			{
-				result = 4;
-			}
-
-			if(result < 3)
-			{
-				buildX = structure.x;
-				buildY = structure.y;
-				structure = NULLOBJECT;
-			}
-			else
-			{
-				structure = enumStruct();
-			}
-		}
-
-		if(buildX != 0)
-		{
-			boolResult = pickStructLocation(sensorTower, ref buildX, ref buildY,me);	// pick spot.
-			if(boolResult == TRUE)
-			{
-				// find unit
-				initIterateGroup(buildGroup);
-				droid = iterateGroup(buildGroup);
-				while(droid != NULLOBJECT)
-				{
-					if ((droid.order == DORDER_NONE or droid.order == DORDER_RTB) and droidCanReach(droid, buildX, buildY))
-					{
-						orderDroidStatsLoc(droid, DORDER_BUILD, sensorTower, buildX, buildY);
-						droid = NULLOBJECT;
-					}
-					else
-					{
-						droid = iterateGroup(buildGroup);
-					}
-				}
-			}
-		}
-	}
-	else
-	{
-		// find a sensor tower with least incencdry structs around it..
-		buildX = 0;
-		buildY = 0;
-
-		initEnumStruct(FALSE,sensorTower,me,me);
-		structure= enumStruct();
-		count = 999;
-		while(structure != NULLOBJECT)
-		{
-			// count incendrys near this tower.
-			result = 0;
-			count2 = 0;
-			while(count2 < numIncendrys)
-			{
-				structure2 = structureBuiltInRange(incendrys[count2], structure.x, structure.y,(4*128), me);
-				if(structure2 != NULLOBJECT)
-				{
-					result = result + 1;
-				}
-				count2 = count2 + 1;
-			}
-
-			if((result < 6) and (result < count))		// lowest found yet. only sites with <6 too.
-			{
-				buildX = structure.x;
-				buildY = structure.y;
-				count  = result;
-			}
-			structure = enumStruct();
-		}
-
-		if(buildX != 0)
-		{
-
-			// choose a device
-			count = numIncendrys - 1;
-			result = 99;
-			while(count >= 0 )
-			{
-				if(isStructureAvailable(incendrys[count],me))
-				{
-					result = count;
-					count = -1;
-				}
-				else
-				{
-					count = count - 1;
-				}
-			}
-
-
-			// find a unit and build an incendry device.
-			if(result != 99)
-			{
-				boolResult = pickStructLocation(incendrys[result], ref buildX, ref buildY,me);	// pick spot.
-				if(boolResult == TRUE)
-				{
-					initIterateGroup(buildGroup);
-					droid = iterateGroup(buildGroup);
-
-					boolResult = (numBuildSameBuilding(incendrys[result], buildX, buildY) > 0);	//anyone building there already?
-
-					while(droid != NULLOBJECT and (not boolResult))
-					{
-						if ((droid.order == DORDER_NONE or droid.order == DORDER_RTB) and droidCanReach(droid, buildX, buildY))
-						{
-							orderDroidStatsLoc(droid, DORDER_BUILD,incendrys[result], buildX,buildY);
-							boolResult = TRUE;	//only 1 truck
-						}
-						droid = iterateGroup(buildGroup);
-					}
-				}
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// build a power gen for every 4 derricks. VITAL!
-event buildPowerGenerators(buildPowerGeneratorsTr)
-{
-	if (!isStructureAvailable(powGen, me))
-	{
-		exit;
-	}
-	initEnumStruct(FALSE,derrick,me,me);					// count = numderricks
-	structure= enumStruct();
-	count	 = 0;
-	while(structure != NULLOBJECT)
-	{
-		count = count + 1;
-		structure= enumStruct();
-	}
-
-	initEnumStruct(FALSE,powGen,me,me);					// count2 = numpowgens
-	structure= enumStruct();
-	count2	 = 0;
-	while(structure != NULLOBJECT)
-	{
-		count2 = count2 + 1;
-		structure= enumStruct();
-	}
-
-	if( (count2 * 4) < count )								// if we need powergen
-	{
-		initIterateGroup(buildGroup);
-		droid = iterateGroup(buildGroup);
-		while(droid != NULLOBJECT)
-		{
-			if (droid.order != DORDER_HELPBUILD and droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD)
-			{
-				buildX = baseX;							// try build powergen.
-				buildY = baseY;
-				if (pickDroidStructLocation(droid, powGen, ref buildX, ref buildY, me, 1))
-				{
-					orderDroidStatsLoc(droid, DORDER_BUILD, powGen, buildX,buildY);
-				}
-			}
-			droid = iterateGroup(buildGroup);
-		}
-	}
-}
-
-
-/////////////////////////////////////////////////////////////////////
-// ensure we have everything in the vital structs list.
-event buildBase(buildBaseTr)
-{
-	if (idleGroup(buildGroup) >= (buildGroup.members / 2))
-	{
-		count = 0;
-		while(count < numStructs)
-		{
-			// check that struct.
-			structure = getStructure(structs[count],me);
-			if(structure == NULLOBJECT)				// if missing build it.
-			{
-				if(isStructureAvailable(structs[count],me))
-				{
-					if (grabTrucksAndBuild(10, structs[count], 0))
-					{
-						exit;	// done here
-					}
-				}
-			}
-			count = count + 1;
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-//  build other stuff, grow the base slowly...
-event buildExpand( buildExpandTr )
-{
-	if (playerPower(me) < LOW_POWER)
-	{
-		exit;	// do not expand base with low power
-	}
-
-	if(extraStruct == numExtraStructs[curTech])	// loop round
-	{
-		extraStruct = 0;
-	}
-
-	if(isStructureAvailable(extraStructs[curTech][extraStruct],me))
-	{
-		if (not grabTrucksAndBuild(10, extraStructs[curTech][extraStruct], 0))
-		{
-			dbg("Failed to build expand", me);
-		}
-	}
-
-	extraStruct = extraStruct + 1;
-}
-
-
-/////////////////////////////////////////////////////////////////////
-//	Structure (fac/res/pow) upgrades
-event upgradeStructures(upgradeStructuresTr )
-{
-	if (not havePowerSource()) 
-	{
-		exit;
-	}
-	initIterateGroup(buildGroup);				// find idle droids in build group.
-	droid = iterateGroup(buildGroup);
-	while(droid != NULLOBJECT)
-	{
-		if ((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
-		{
-			boolResult = FALSE;
-
-			if(curTech == branchDefault)
-			{
-				//powergen
-				boolResult = upgradePowGen(droid, 2);
-
-				//factory
-				if(droid.order != DORDER_BUILD){
-					boolResult = upgradeFactory(droid, 3);
-				}
-
-				//research
-				if(droid.order != DORDER_BUILD){
-					boolResult = upgradeResearch(droid, 1);
-				}
-
-				//vtol Factory
-				if(droid.order != DORDER_BUILD){
-					boolResult = upgradeVtolFactory(droid, 1);
-				}
-			}
-			else if(curTech == branchVTOL)
-			{
-				//powergen
-				boolResult = upgradePowGen(droid, 2);
-
-				//vtol Factory
-				if(droid.order != DORDER_BUILD){
-					boolResult = upgradeVtolFactory(droid, 3);
-				}
-
-				//factory
-				if(droid.order != DORDER_BUILD){
-					boolResult = upgradeFactory(droid, 2);
-				}
-
-				//research
-				if(droid.order != DORDER_BUILD){
-					boolResult = upgradeResearch(droid, 1);
-				}
-			}
-		}
-		droid = iterateGroup(buildGroup);
-	}
-}
-
-function bool upgradeFactory(DROID _truck, int _maxBuilders)
-{
-	local	STRUCTURE	_factory;
-
-	initEnumStruct(FALSE,factory,me,me);
-	_factory = enumStruct();
-	while(_factory != NULLOBJECT)
-	{
-		// if upgrade is available && struct is not upgraded
-		if( isStructureAvailable(facModule,me) and (skGetFactoryCapacity(_factory) < 2 ) and droidCanReach(_truck, _factory.x, _factory.y))
-		{
-			if((numBuildSameBuilding(facModule, _factory.x, _factory.y) +
-			    numBuildSameBuilding(vtolFactory, _factory.x, _factory.y)) < _maxBuilders)
-			{
-				orderDroidStatsLoc(_truck, DORDER_BUILD,facModule, _factory.x,_factory.y);	// upgrade it.
-				return TRUE;
-			}
-		}
-		_factory = enumStruct();
-	}
-
-	return FALSE;
-}
-
-function bool upgradeVtolFactory(DROID _truck, int _maxBuilders)
-{
-	local	STRUCTURE	_factory;
-
-	initEnumStruct(FALSE,vtolFactory,me,me);
-	_factory = enumStruct();
-	while(_factory != NULLOBJECT)
-	{
-		// if upgrade is available && struct is not upgraded
-		if( isStructureAvailable(facModule,me) and (skGetFactoryCapacity(_factory) < 2 ) and droidCanReach(_truck, _factory.x, _factory.y))
-		{
-			if((numBuildSameBuilding(facModule, _factory.x, _factory.y) +
-			    numBuildSameBuilding(factory, _factory.x, _factory.y)) < _maxBuilders)
-			{
-				orderDroidStatsLoc(_truck, DORDER_BUILD,facModule, _factory.x,_factory.y);	// upgrade it.
-				return TRUE;
-			}
-		}
-		_factory = enumStruct();
-	}
-
-	return FALSE;
-}
-
-function bool upgradeResearch(DROID _truck, int _maxBuilders)
-{
-	local	STRUCTURE	_resFac;
-
-	initEnumStruct(FALSE,resLab,me,me);
-	_resFac = enumStruct();
-	while(_resFac != NULLOBJECT)
-	{
-		// if upgrade is available && struct is not upgraded
-		if( isStructureAvailable(resModule,me) and (not testStructureModule(me, _resFac, 0)) and droidCanReach(_truck, _resFac.x, _resFac.y))
-		{
-			if((numBuildSameBuilding(resModule, _resFac.x, _resFac.y) +
-			    numBuildSameBuilding(resLab, _resFac.x, _resFac.y)) < _maxBuilders)
-			{
-				orderDroidStatsLoc(_truck, DORDER_BUILD,resModule, _resFac.x,_resFac.y);	// upgrade it.
-				return TRUE;
-			}
-		}
-		_resFac = enumStruct();
-	}
-
-	return FALSE;
-}
-
-function bool upgradePowGen(DROID _truck, int _maxBuilders)
-{
-	local	STRUCTURE	_powGen;
-
-	initEnumStruct(FALSE,powGen,me,me);
-	_powGen = enumStruct();
-	while(_powGen != NULLOBJECT)
-	{
-		// if upgrade is available && struct is not upgraded
-		if( isStructureAvailable(powModule,me) and (not testStructureModule(me, _powGen, 0)) and droidCanReach(_truck, _powGen.x, _powGen.y))
-		{
-			if((numBuildSameBuilding(powModule, _powGen.x,_powGen.y) +
-			    numBuildSameBuilding(powGen, _powGen.x,_powGen.y)) < _maxBuilders)
-			{
-				orderDroidStatsLoc(_truck, DORDER_BUILD, powModule, _powGen.x,_powGen.y);	// upgrade it.
-				return TRUE;
-			}
-		}
-		_powGen = enumStruct();
-	}
-
-	return FALSE;
-}
-
-
-/////////////////////////////////////////////////////////////////////
-//	Finish Building Part Built Structures
-event finishStructs(finishStructsTr)
-{
-	initEnumStruct(TRUE,factory,me,me);
-	structure= enumStruct();
-	while(structure != NULLOBJECT)
-	{
-		if(not structureComplete(structure))
-		{
-			initIterateGroup(buildGroup);				// find idle droids in build group.
-			droid = iterateGroup(buildGroup);
-			while(droid != NULLOBJECT)
-			{
-				if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD
-				    and droidCanReach(droid, structure.x, structure.y)
-				    and distBetweenTwoPoints(droid.x, droid.y, structure.x, structure.y) < 20 * TILE)
-				{
-					orderDroidObj(droid,DORDER_HELPBUILD,structure);
-				}
-				droid = iterateGroup(buildGroup);
-			}
-		}
-		structure= enumStruct();
-	}
-}
-
-
-/////////////////////////////////////////////////////////////////////
-//  fortify base by builiding defensive structs on the edge of the base.
-// rewrote fortify to use scrSkDefenseLocation(baseX,baseY,me);
-
-event newfortify(fortifyTr)
-{
-	local	int		_numBuilders,_maxBuilders;
-
-	_maxBuilders = 1;
-
-	if(numGroupSameOrder(buildGroup, DORDER_LINEBUILD) >= _maxBuilders)
-	{
-		exit;
-	}
-
-	boolResult = FALSE;
-	initIterateGroup(buildGroup);				// find idle an idle veh.in build group.
-	droid = iterateGroup(buildGroup);
-	while((boolResult == FALSE) and (droid != NULLOBJECT))
-	{
-		if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.order != DORDER_HELPBUILD)
-		{
-			boolResult = TRUE;					// dont do this again!
-
-			tempx = baseX;
-			tempy = baseY;
-
-			// choose a suitable turret.
-			count = numWallWeaps - 1;
-			count2 = 0;
-			while( (count2 < 3) and (count >= 0) )
-			{
-				if( isStructureAvailable(wallWeaps[count],me))
-				{
-					structChoice[count2] = wallWeaps[count];
-					count2 = count2 + 1;
-				}
-				count = count - 1;
-			}
-			count =0;
-			if((count2 > 0) and (_numBuilders < _maxBuilders))
-			{
-				count = random(count2);
-				skDefenseLocationB(ref tempx,ref tempy,wall,structChoice[count],droid,me);
-				_numBuilders++;
-			}
-
-		}
-		droid = iterateGroup(buildGroup);
-
-	}
-}
-
-
-/////////////////////////////////////////////////////////////////////
-// droid building rules
-/////////////////////////////////////////////////////////////////////
-// deal with a droid being built
-event droidBuiltAssign(droidBuiltTr)
-{
-	if(isVtol(droid))
-	{
-		if(vtolDefendGr.members < numDefendVtols)
-		{
-			groupAddDroid(vtolDefendGr, droid);
-		}
-		else
-		{
-			count = 0;
-			while(count < numVtolAttackGroups)
-			{
-				if(vtolAttackGr[count].members < numAttackVtols)
-				{
-					dbg("added new vtol to group " & count, me);
-					groupAddDroid(vtolAttackGr[count], droid);
-					count = numVtolAttackGroups;
-				}
-				count++;
-			}
-		}
-	}
-	else if((droid.droidType != DROID_TRANSPORTER) and (droid.droidType != DROID_COMMAND))
-	{
-
-		if((droid.droidType == DROID_REPAIR)
-			or (droid.droidType == DROID_CYBORG_REPAIR))
-		{
-			numRepairUnits = numRepairUnits + 1;
-		}
-		
-		if((droid.droidType == DROID_CONSTRUCT)
-			or (droid.droidType == DROID_CYBORG_CONSTRUCT))				// if constructor droid
-		{
-			groupAddDroid(buildGroup, droid);
-		}
-		else
-		{
-			if(droid.droidType == DROID_CYBORG)
-			{
-				groupAddDroid(defendGroup, droid);
-			}
-			else
-			{
-				if(scoutGroup.members < numScouts[curTech])
-				{
-					groupAddDroid(scoutGroup, droid);
-				}
-				else if(attackGroup.members < numAttackers[curTech])
-				{
-					groupAddDroid(attackGroup, droid);
-				}
-				else if( defendGroup.members < numDefenders[curTech])
-				{
-					groupAddDroid(defendGroup, droid);
-				}
-				else
-				{
-					if(scoutGroup.members < maxScouts[curTech])
-					{
-						groupAddDroid(scoutGroup, droid);
-					}
-					else if(attackGroup.members < maxAttackers[curTech])
-					{
-						groupAddDroid(attackGroup, droid);
-					}
-					else if( defendGroup.members < maxDefenders[curTech])
-					{
-						groupAddDroid(defendGroup, droid);
-					}
-					else	//make them attack
-					{
-						groupAddDroid(attackGroup, droid);
-					}
-				}
-			}
-		}
-	}
-}
-
-//When droid built: check emergency jobs, start building next droid
-event droidBuilt(droidBuiltTr)
-{
-	local STRUCTURE _fundie;
-
-	/* Start building next droid */
-	if(structure != NULLOBJECT)
-	{
-		// derrick works as NULL here, as NULLSTAT does not seem to work
-		if (droid.droidType == DROID_CONSTRUCT and fundamentalBeingBuilt != derrick)
-		{
-			_fundie = getStructure(fundamentalBeingBuilt, me);
-			if (_fundie != NULLOBJECT)
-			{
-				if (not structureComplete(_fundie))
-				{
-					orderDroidObj(droid, DORDER_HELPBUILD, _fundie);
-				}
-			}
-		}
-
-		if (droid.droidType == DROID_CONSTRUCT && structure.stattype == REF_FACTORY)
-		{
-			setEventTrigger(conDroids, chainloadTr);	// consider building more
-		}
-		// Continue building new droids right away
-		else if(structure.stattype == REF_FACTORY)
-		{
-			factoryBuildDroid(structure);
-		}
-		else if(structure.stattype == REF_CYBORG_FACTORY)
-		{
-			cybFactorBuildCyborg(structure);
-		}
-		else if(structure.stattype == REF_VTOL_FACTORY)
-		{
-			vtolFactoryBuildVtol(structure);
-		}
-	}
-}
-
-/* Gets triggered when structure was built */
-event structBuilt(structBuiltTr)
-{
-	local	FEATURE	_oilResource;
-	local	int		_count,_count2;
-
-	if (structure == NULLOBJECT || droid == NULLOBJECT)
-	{
-		exit;
-	}
-
-	/* factory or factory module */
-	if(structure.stattype == REF_FACTORY)
-	{
-		if (isStructureAvailable(facModule, me) and (skGetFactoryCapacity(structure) < 2 ) and (getDroidCount(me) > 4))
-		{
-			orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.
-		}
-		else
-		{
-			setEventTrigger(conDroids, chainloadTr);
-		}
-	}
-	/* vtol factory or vtol factory module */
-	else if(structure.stattype == REF_VTOL_FACTORY)
-	{
-		if( isStructureAvailable(facModule,me) and (skGetFactoryCapacity(structure) < 2 ))
-		{
-			orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.
-		}
-	}
-	else if(structure.stattype == REF_RESOURCE_EXTRACTOR)
-	{
-		setEventTrigger(buildDerrick, chainloadTr);
-		exit;
-	}
-	else if (structure.stattype == REF_RESEARCH)
-	{
-		if (isStructureAvailable(resModule, me))
-		{
-			orderDroidStatsLoc(droid, DORDER_BUILD, resModule, structure.x, structure.y);	// upgrade it.
-		}
-		else
-		{
-			setEventTrigger(doResearch, chainloadTr);
-		}
-	}
-	else if (structure.stattype == REF_POWER_GEN)
-	{
-		if (isStructureAvailable(powModule, me))
-		{
-			orderDroidStatsLoc(droid, DORDER_BUILD, powModule, structure.x, structure.y);	// upgrade it.
-		}
-	}
-
-	// Check if available trucks need to build more absolute necessities right away. We need a trigger here because
-	// droids involved in building have not yet come out of their build orders.
-	setEventTrigger(buildFundamentals, slowloadTr);
-
-	//see if we have just rebuilt a destroyed structure
-	_count = 0;
-	while(_count < countRebuildStruct)
-	{
-		if(structure.x == rebuildStructX[_count] and
-		   structure.y == rebuildStructY[_count] and
-		   ( (structure.stat == rebuildStructStat[_count]) or //walls can end up as corner walls
-		   ( (structure.stat == wall or structure.stat == cornerWall) and
-		   (rebuildStructStat[_count] == wall or rebuildStructStat[_count] == cornerWall))
-		   ))
-		{
-			dbg("finished rebuilding destroyed structure - " & _count, me);
-
-			//resort destroyed structures
-			_count2 = _count;
-			while(_count2 < (countRebuildStruct - 1))
-			{
-				rebuildStructX[_count2] = rebuildStructX[_count2 + 1];
-				rebuildStructY[_count2] = rebuildStructY[_count2 + 1];
-				rebuildStructStat[_count2] = rebuildStructStat[_count2 + 1];
-
-				_count2++;
-			}
-
-			//clear last entry
-			rebuildStructX[countRebuildStruct - 1] = 0;
-			rebuildStructY[countRebuildStruct - 1] = 0;
-			rebuildStructStat[countRebuildStruct - 1] = NULLSTRUCTURESTAT;
-
-			countRebuildStruct--;	//we just built one structure
-
-			//_count = countRebuildStruct;	//exit outer loop
-		}
-		_count++;
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// deal with attacks.
-event droidDestroyed(droidDestroyedTr)
-{
-
-	if(droid.droidType == DROID_REPAIR)
-	{
-		numRepairUnits = numRepairUnits - 1;
-	}
-
-	if(droid.droidType == DROID_CONSTRUCT)					// if constructor droid
-	{
-		initEnumStruct(FALSE,factory,me,me);
-		structure= enumStruct();							// find factory.
-
-		if( (structure != NULLOBJECT) and (getDroidCount(me) < MAX_DROIDS) )
-		{
-			buildDroid(constructor, structure, me, 1);	// build constructor
-		}
-
-	}
-}
-
-
-/////////////////////////////////////////////////////////////////////
-// build more con droids.
-event conDroids(conDroidsTr)
-{
-	local 	int			_maxTrucks;
-	local 	STRUCTURE	_factory;
-	local	int 		_numBuilding,_haveTrucks,_maxTruckFactories,_totalTrucks;
-	local	bool		_bStartedBuilding;
-
-	_maxTrucks = MAX_TRUCKS;
-	if (playerPower(me) < LOW_POWER)
-	{
-		_maxTrucks = MIN_TRUCKS;
-	}
-
-	_maxTruckFactories = 3; 		//max factories to use for truck production
-
-	_haveTrucks = buildGroup.members;
-	
-	//Find out how many trucks and combat engineers are already in production
-	_numBuilding = numTemplatesInProduction(constructor,me);	//trucks
-	_numBuilding = _numBuilding + numTemplatesInProduction(cybEngineer,me);	//engineers
-
-	_totalTrucks = _numBuilding + _haveTrucks;
-	
-	initEnumStruct(FALSE,factory,me,me);
-	_factory = enumStruct();
-	
-	while ((_factory != NULLOBJECT) and (_numBuilding < _maxTruckFactories) and (_totalTrucks < _maxTrucks))
-	{
-		//Try to build a truck
-		if (skCanBuildTemplate(me, _factory, hovertruck))
-		{
-			_bStartedBuilding = buildUnit(hovertruck, _factory, factory, FALSE);	//build truck even if not idle
-		}
-		else
-		{
-			_bStartedBuilding = buildUnit(constructor, _factory, factory, FALSE);	//build truck even if not idle
-		}
-		
-		//Update statistics if started building a truck
-		if(_bStartedBuilding)
-		{
-			_numBuilding++;
-			_totalTrucks++;
-		}
-		
-		_factory = enumStruct();
-	}
-	
-	//build cyborg engineers if needed, no building structure limit here
-	initEnumStruct(FALSE,cybFactory,me,me);
-	_factory = enumStruct();
-	while((_factory != NULLOBJECT) and (_totalTrucks < _maxTrucks))
-	{
-		//Try to build a truck
-		if( skCanBuildTemplate(me,_factory, cybEngineer) )	//make sure we have researched cyb engineer
-		{
-			_bStartedBuilding = buildUnit(cybEngineer, _factory, cybFactory, FALSE);	//build a cyb eng even if not idle
-			
-			//Update statistics if started building a cyborg engineer
-			if(_bStartedBuilding)
-			{
-				_numBuilding++;
-				_totalTrucks++;
-			}
-		}
-
-		_factory = enumStruct();
-	}
-	setEventTrigger(conDroids, conDroidsTr);
-}
-
-//Build a droid
-function bool buildUnit(TEMPLATE _tankTemplate, STRUCTURE _factory, STRUCTURESTAT _factoryType, bool _bIdleOnly)
-{
-	//Factory was not provided, find an factory
-	if(_factory == NULLOBJECT)
-	{
-		_factory = findIdleStructure(_factoryType, _bIdleOnly);
-	}
-
-	//Build if got a factory
-	if(_factory != NULLOBJECT)
-	{
-		if(structureComplete(_factory) and (getDroidCount(me) < MAX_DROIDS))
-		{
-			if( !(_bIdleOnly and !structureIdle(_factory)) )	//don't build if only allowed to build whe idle and fac is not idle
-			{
-				buildDroid(_tankTemplate, _factory, me, 1);	// build a tank
-				return TRUE;	//success
-			}
-		}
-	}
-
-	return FALSE;		//failed
-}
-
-//Returns an idle structure of the provided type or NULLOBJECT if none found
-function STRUCTURE findIdleStructure(STRUCTURESTAT _structType, bool _bIdleOnly)
-{
-	local	STRUCTURE	_structure;
-
-	initEnumStruct(FALSE,_structType,me,me);
-	_structure = enumStruct();
-	while(_structure != NULLOBJECT)
-	{
-		if(structureComplete(_structure))
-		{
-			if( !(_bIdleOnly and !structureIdle(_structure)) )
-			{
-				return _structure;
-			}
-		}
-
-		_structure = enumStruct();
-	}
-	
-	return NULLOBJECT;	//none found
-}
-
-/////////////////////////////////////////////////////////////////////
-// build repair droids.
-event repairDroids(repairDroidsTr)
-{
-	// if we're running low on repair droids, build some..
-	if(numRepairUnits <3)
-	{
-		initEnumStruct(FALSE,factory,me,me);
-		structure= enumStruct();							// find factory.
-		if (structure != NULLOBJECT)
-		{
-			if ((getDroidCount(me) < MAX_DROIDS) and (skCanBuildTemplate(me, structure, repairUnit)))
-			{
-				buildDroid(repairUnit, structure, me, 1);	// build repairunit.
-			}
-		}
-	}
-}
-
-
-/////////////////////////////////////////////////////////////////////
-event factoryEvent(factoryEventTr)
-{
-	// for each factory....
-	initEnumStruct(FALSE,factory,me,me);
-	structure = enumStruct();								// find factory.
-	if(getDroidCount(me) < MAX_DROIDS)
-	{
-		while(structure != NULLOBJECT)
-		{
-			if( structureIdle(structure) )
-			{
-				factoryBuildDroid(structure);
-			}
-
-			structure = enumStruct();
-		}
-	}
-}
-
-function bool needTank()
-{
-	if(not havePowerSource())
-	{
-		return FALSE;
-	}
-	
-	if((defendGroup.members < maxDefenders[curTech]) or (maxDefenders[curTech] == UNLIMITED))
-	{
-		return TRUE;
-	}
-
-	if((scoutGroup.members < maxScouts[curTech]) or (maxScouts[curTech] == UNLIMITED))
-	{
-		return TRUE;
-	}
-
-	if((attackGroup.members < maxAttackers[curTech]) or (maxAttackers[curTech] == UNLIMITED))
-	{
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-function void factoryBuildDroid(STRUCTURE _factory)
-{
-	local int _count,_count2;
-
-	if(_factory == NULLOBJECT){
-		dbg("factoryBuildDroid: factory is NULLOBJECT", me);
-		return;
-	}
-
-	if(not needTank())
-	{
-		//dbg("NEED NO TANKS!! " & maxDefenders[curTech], me);
-		return;
-	}
-
-	if( structureIdle(_factory) )
-	{
-		_count = numTemplates[curTech] - 1;
-		_count2 = 0;
-		while( (_count2 < MAX_RANDOM_TEMPLATES) and (_count >= 0) )
-		{
-			if( skCanBuildTemplate(me,_factory, tmpl[curTech][_count]) )
-			{
-				tmplChoice[_count2] = tmpl[curTech][_count];
-				_count2 = _count2 + 1;
-			}
-			_count = _count - 1;
-		}
-
-		if(_count2 > 0)
-		{
-			buildDroid(tmplChoice[random(_count2)],_factory,me,1);
-		}
-	}
-	else
-	{
-		dbg("factoryBuildDroid: factory is busy", me);
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// put cyborg factories to work
-event cyborgFactoryEvent(cyborgFactoryEventTr)
-{
-
-	if(not ((defendGroup.members < maxCyborgs[curTech]) or (maxCyborgs[curTech] == UNLIMITED)))
-	{
-		exit;		//we need no cyborgs
-	}
-
-	initEnumStruct(FALSE,cybFactory,me,me);
-	structure= enumStruct();								// find factory.
-
-	while(structure != NULLOBJECT)
-	{
-		if( structureIdle(structure) == TRUE)
-		{
-			cybFactorBuildCyborg(structure);
-		}
-		structure= enumStruct();							// find factory.
-	}
-}
-
-function void cybFactorBuildCyborg(STRUCTURE _factory)
-{
-	if(_factory == NULLOBJECT){
-		dbg("cybFactorBuildCyborg: factory is NULLOBJECT", me);
-		return;
-	}
-
-	if( structureIdle(_factory) )
-	{
-		if( (defendGroup.members < maxCyborgs[curTech]) and (getDroidCount(me) < MAX_DROIDS) )
-		{
-			if(random(5) == 1)
-			{
-				buildDroid(cybMechanic,_factory,me,1);
-			}
-			else
-			{
-				count = 3;
-				count2 = 0;
-				while( count >= 0 )
-				{
-					if( skCanBuildTemplate(me,_factory, superCyb[count]) )
-					{
-						tmplChoice[count2] = superCyb[count];
-						count2 = count2 + 1;
-					}
-					count = count - 1;
-				}
-
-				if(count2 > 0)
-				{
-					buildDroid(tmplChoice[random(count2)],_factory,me,1);
-				}
-				else	//try light cyborgs
-				{
-					count = numLightCyborgs - 1;
-					count2 = 0;
-					while( (count >= 0) and (count2 < 2) )
-					{
-						if( skCanBuildTemplate(me,_factory, cybTempl[count]) )
-						{
-							tmplChoice[count2] = cybTempl[count];
-							count2++;
-						}
-						count--;
-					}
-					if(count2 > 0)
-					{
-						buildDroid(tmplChoice[random(count2)], _factory, me, 1);
-					}
-				}
-			}
-
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// scouting rules
-
-// scout an area
-event chooseScoutArea(chooseScoutAreaTr)
-{
-	scoutX = scoutTLX + random(scoutW);
-	scoutY = scoutTLY + random(scoutH);
-}
-
-/////////////////////////////////////////////////////////////////////
-// visit new places
-
-event expandScoutArea(expandScoutAreaTr)
-{
-
-	//expand the scouting area slightly
-	scoutTLX	= scoutTLX - ((mapWidth*128)/ tileExpand);
-	scoutTLY	= scoutTLY - ((mapHeight*128)/ tileExpand);
-	scoutW		= scoutW + (2*((mapWidth*128)/ tileExpand));
-	scoutH		= scoutH + (2*((mapHeight*128)/ tileExpand));
-
-	// check & restrain.
-	if(scoutTLX <1)
-	{
-		scoutTLX = 1;
-	}
-	if(scoutTLY <1)
-	{
-		scoutTLY = 1;
-	}
-
-	if(scoutTLX >(mapWidth*128))
-	{
-		scoutTLX = (mapWidth*128) - 128;
-	}
-	if(scoutTLY >(mapHeight*128))
-	{
-		scoutTLY = (128*mapHeight) - 128;
-	}
-
-	if( (scoutTLX + scoutW) > (128 * mapWidth) )
-	{
-		scoutW = ( (128 * mapWidth) - scoutTLX) - 128;
-	}
-	if( (scoutTLY + scoutH) > (128 *mapHeight) )
-	{
-		scoutH = ( (128*mapHeight) - scoutTLY) - 128;
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// order scouts
-
-event scoutMain(scoutMainTr)
-{
-	// find any new scouts
-	// if scouts aren't busy, send them to a new spot.
-	if( idleGroup(scoutGroup) >= (scoutGroup.members /2) )
-	{
-		orderGroupLoc(scoutGroup, DORDER_MOVE,scoutX,scoutY);
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// process new visibility reports
-event newObjectReport(newObjectReportTr)
-{
-	if(!friendlyPlayer(baseobj.player))
-	{
-		if(targetTypeValue(baseobj) > targetTypeValue(attackObj))
-		{
-			attackObj = baseobj;// got a new unseen  target from a scout.
-
-			if(	attackObj.type == OBJ_STRUCTURE)
-			{
-				if(not allianceExistsBetween(attackObj.player,me))	// an enemy
-				{
-					structure = objToStructure(attackObj);
-					if(structure.stat == factory)
-					{
-						allOutAttack = attackObj;
-					}
-				}
-			}
-		}
-	}
-}
-
-function int targetTypeValue(BASEOBJ _target)
-{
-	local STRUCTURE _strTarget;
-
-	if(_target == NULLOBJECT){
-		return NO_TARGET_VALUE;
-	}
-
-	if(_target.type == OBJ_DROID)
-	{
-		return DROID_TARGET_VALUE;
-	}
-	else if(_target.type == OBJ_STRUCTURE)
-	{
-		_strTarget = objToStructure(_target);
-
-		if(_strTarget.stattype == REF_DEFENSE)
-		{
-			return DEFENSE_TARGET_VALUE;
-		}
-		else if(_strTarget.stattype == REF_RESEARCH or
-				_strTarget.stattype == REF_POWER_GEN)
-		{
-			return RESEARCH_TARGET_VALUE;
-		}
-		else if(_strTarget.stattype == REF_HQ or
-				_strTarget.stattype == REF_COMMAND_CONTROL)
-		{
-			return HQ_TARGET_VALUE;
-		}
-		else if(_strTarget.stattype == REF_RESOURCE_EXTRACTOR)
-		{
-			return OIL_TARGET_VALUE;
-		}
-		else if(_strTarget.stattype == REF_FACTORY or
-				_strTarget.stattype == REF_CYBORG_FACTORY or
-				_strTarget.stattype == REF_VTOL_FACTORY)
-		{
-			return FACTORY_TARGET_VALUE;
-		}
-		else	//walls, rearm pads etc
-		{
-			return OTHER_TARGET_VALUE;
-		}
-	}
-
-	return NO_TARGET_VALUE;
-}
-
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// spy technologies
-//event takeover( CALL_UNITTAKEOVER , ref droid  )
-
-event takeover(takeoverTr)
-{
-	if( droid.player == me )
-	{
-		if(droid.droidType == DROID_CONSTRUCT or
-				droid.droidType == DROID_CYBORG_CONSTRUCT)
-		{
-			groupAddDroid( buildGroup, droid );
-		}
-		else if (droid.droidType != DROID_TRANSPORTER
-		      && droid.droidType != DROID_COMMAND)
-		{
-			groupAddDroid( attackGroup, droid );
-		}
-	}
-}
-
-event takeoverDefend(takeoverTr)
-{
-	if( droid.player != me )
-	{
-		completeResearch(nexusDefence,me);
-		setEventTrigger(takeoverDefend,	inactive);
-	}
-}
-
-
-event useLassat(useLassatTr)
-{
-	// find my lassat
-	// fire it at my attack objective.
-	if(allOutAttack != NULLOBJECT)
-	{
-		initEnumStruct(FALSE,lassat,me,me);
-		structure= enumStruct();
-		while(structure != NULLOBJECT)
-		{
-			if(structureComplete(structure) == TRUE)
-			{
-				skFireLassat(me,allOutAttack);
-			}
-			structure= enumStruct();
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// attack rules
-
-event findEnemy(attackStuffTr)
-{
-	if(attackObj == NULLOBJECT)
-	{
-		count = random(8);
-		count2 = 100;
-		while( friendlyPlayer(count) && (count2 > 0) )
-		{
-			count = random(8);
-			count2--;
-		}
-
-		if(!friendlyPlayer(count))
-		{
-			baseobj = skLocateEnemy(count);
-			if(baseobj != NULLOBJECT)
-			{
-				attackObj =	baseobj;
-
-				// set allOutAttack to attackObj only if attackObj is a more valuable target than allOutAttack
-				if(targetTypeValue(attackObj) > targetTypeValue(allOutAttack))
-				{
-					allOutAttack = attackObj;
-				}
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// send attack team out to cause trouble near things scout found.
-event attackStuff(attackStuffTr)
-{
-	if( idleGroup(attackGroup) >= (attackGroup.members / 2))
-	{
-		if( (attackObj != NULLOBJECT) and (not helpingAlly()) )
-		{
-			if (not allianceExistsBetween(me, attackObj.player))
-			{
-				if(attackGroup.members > (6 + random(6)) )
-				{
-					orderGroupLoc(attackGroup, DORDER_SCOUT, attackObj.x, attackObj.y);
-				}
-
-				// make scouts attack too
-				if( idleGroup(scoutGroup) >= (scoutGroup.members / 2) )
-				{
-					orderGroupLoc(scoutGroup, DORDER_SCOUT, attackObj.x, attackObj.y);
-				}
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-event doAllOutAttack(allOutAttackTr)
-{
-	if (idleGroup(attackGroup) >= (attackGroup.members / 3))	// make sure at least 30% are idle
-	{
-		if ((allOutAttack != NULLOBJECT) and (not helpingAlly()))
-		{
-			if (!friendlyPlayer(allOutAttack.player))
-			{
-				if (getDroidCount(me) > 40)	// plenty of units.
-				{
-					orderGroupObj(attackGroup, DORDER_ATTACK, allOutAttack);
-					orderGroupLoc(scoutGroup, DORDER_SCOUT, allOutAttack.x, allOutAttack.y);
-				}
-			}
-			else
-			{
-				allOutAttack = NULLOBJECT;
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// defending rules
-
-// defend attacked objects.
-event defendWatch(defendWatchTr)
-{
-	if (baseobj != NULLOBJECT)
-	{
-		if(!friendlyPlayer(baseobj.player))
-		{
-			if(distBetweenTwoPoints(baseobj.x, baseobj.y, baseX, baseY) <= MAX_DEFENDERS_RADIUS)	//don't go too far away from the base
-			{
-				defendObj = baseobj;
-				defendbusy = TRUE;
-				// if not too busy, attack.
-				if (idleGroup(defendGroup) >= (defendGroup.members / 2))
-				{
-					orderGroupLoc(defendGroup, DORDER_MOVE,defendObj.x,defendObj.y);	//cyborg mechanics can't attack (won't move)
-				}
-
-				if (idleGroup(scoutGroup) >= (scoutGroup.members / 2))
-				{
-					orderGroupLoc(scoutGroup, DORDER_MOVE,scoutX,scoutY);
-				}
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// defenders  return after they are finished.
-event defendReturn(defendReturnTr)
-{
-	if( defendbusy and (idleGroup(defendGroup) == (defendGroup.members - defendGroup.members / 12)))
-	{
-		// find a place with no structures nearby
-		buildX = baseX;
-		buildY = baseY;
-		pickStructLocationB(powGen, ref buildX, ref buildY, me, 0);
-
-		orderGroupLoc(defendGroup, DORDER_MOVE,buildX,buildY);
-		defendbusy = FALSE;
-	}
-}
-
-//returns number of non-idle structures of a certain type
-function int numStructBusyByType(STRUCTURESTAT _busyStructType)
-{
-	local	int _result;
-
-	initEnumStruct(FALSE,_busyStructType,me,me);
-	structure = enumStruct();
-	_result = 0;
-	while(structure != NULLOBJECT)
-	{
-		if(structureComplete(structure))
-		{
-			if(not structureIdle(structure))
-			{
-				_result++;
-			}
-		}
-		structure = enumStruct();
-	}
-
-	return _result;
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// Research Rules Now does true research.
-// do research
-
-event doResearch(doResearchTr)
-{
-	local	int		_techIndex,_numResearching;
-
-	// don't throw in half of your money on research in T3 no bases when we don't have any income yet
-	if (isStructureAvailable(facModule,me) and not havePowerSource())
-	{
-		setEventTrigger(doResearch, doResearchTr);
-		exit;
-	}
-	
-	_techIndex = 0;	//research start
-	_numResearching = numStructBusyByType(resLab);
-
-	// for every research lab do this..
-	initEnumStruct(FALSE,resLab,me,me);
-	structure= enumStruct();
-	count = 0;
-	while(structure != NULLOBJECT)
-	{
-		boolResult = FALSE;		//haven't started research for the current resFac
-
-		if(structureIdle(structure))
-		{
-			if(structureComplete(structure))
-			{
-				// first research all technologies necessary for the current research branch
-				while(not boolResult and _techIndex != NONE)	//not started researching and still branch tech left to try
-				{
-					_techIndex = findResearch(_techIndex, curTech);
-					if(_techIndex > NONE)
-					{
-						boolResult = pursueResearch(structure,me,tech[curTech][_techIndex]);
-
-						_techIndex++;	//try nect research next time if needed
-						_numResearching++;
-					}
-				}
-
-				// do common research
-				if(not boolResult)	//didn't start branch research
-				{
-					if((maxIdleRes[curTech] == UNLIMITED) or (_numResearching < maxIdleRes[curTech]))
-					{
-						skDoResearch(structure,me,0);
-						_numResearching++;
-					}
-				}
-			}
-		}
-
-		structure = enumStruct();
-	}
-	setEventTrigger(doResearch, doResearchTr);
-}
-
-// find next available research of our research branch
-function int findResearch(int _searchStart, int _techTree)
-{
-	local	int	_result;
-
-	ASSERT(_searchStart >= 0, "findResearch: _searchStart < 0", me);
-	ASSERT(_techTree >= 0, "findResearch: _techTree < 0", me);
-
-	_result = _searchStart;
-	while(_result < techCount[_techTree])
-	{
-		if((not researchFinished(tech[_techTree][_result], me)) and (not researchStarted(tech[_techTree][_result], me)))
-		{
-			return _result;		//found research
-		}
-		_result++;
-	}
-
-	return NONE;		//not found
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// Alliance Rules
-
-// form alliances
-event formAllianceEvent(formAllianceEventTr)
-{
-	count = 0;
-	while(count < MAX_PLAYERS)
-	{
-		if( count != me )												// if not the only other player and rand2
-		{
-			if((getDroidCount(me) > 1) and (getDroidCount(count) > 1) )	// not dead
-			{
-				if(random(28) == 1)											// bit random
-				{
-					if(not isHumanPlayer(count))							// not human
-					{
-						createAlliance(me,count);
-						allianceTime[count] = gameTime;
-					}
-				}
-			}
-		}
-		count = count + 1;
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// break the alliance too.
-event breakAllianceEvent(breakAllianceEventTr)
-{
-	count = 0;
-	while(count<multiPlayerMaxPlayers)
-	{
-		if( count != me)
-		{
-			if((getDroidCount(me) > 1) and (getDroidCount(count) > 1) )	// not dead
-			{
-				if(allianceExistsBetween(me,count) )
-				{
-					// check if we're in alliance with any other players.
-					if( (random(30) == 1) and ( (gameTime - allianceTime[count]) > 6000) )	// rand and more than 10 minutes.
-					{
-						allianceTime[count] = gameTime;
-						breakAlliance(me,count);
-					}
-
-					// rules for breaking alliances with humans.
-					// built within my base
-					if(numStructsInArea(count,minx,miny,maxx,maxy) > 1)
-					{
-						allianceTime[count] = gameTime;
-						breakAlliance(me,count);
-					}
-
-					// you've got lots of units in my area.
-					if(numDroidsInArea(count,minx,miny,maxx,maxy) > 3)
-					{
-						allianceTime[count] = gameTime;
-						breakAlliance(me,count);
-					}
-
-					// you've wiped out one of my allies ??.
-				}
-			}
-		}
-		count = count + 1;
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-event formHumanAlliances(humanAllianceTr)
-{
-	if(count2 == me) // offered to me.
-	{
-		result = 0;
-		result2 = 0;
-		while(result < multiPlayerMaxPlayers)
-		{
-			if(allianceExistsBetween(count,result))
-			{
-				result2 = result2 + 1;
-			}
-			result = result + 1;
-		}
-		if( result2 < ((multiPlayerMaxPlayers / 2) - 1) )	// not too many already
-		{
-			//not too soon.
-			if((allianceTime[count] == 0) or (gameTime - allianceTime[count] > 1200))
-			{
-				result = 0;								// check forming wont end the game
-				result2 = 0;
-				while(result < multiPlayerMaxPlayers)
-				{
-					while(result2 < multiPlayerMaxPlayers)
-					{
-						if((not allianceExistsBetween(result,result2)) and (getDroidCount(result) > 0) and (getDroidCount(result2) > 0) and (result != result2) )
-						{
-							if( ((result == count and result2 == count2) or (result2 == count2 and result == count)) )	// ignore the outcome of this alliance
-							{
-								createAlliance(me,count);
-								allianceTime[count] = gameTime;
-							}
-						}
-						result2 = result2 + 1;
-					}
-					result = result + 1;
-				}
-			}
-
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// Consolidate Rules
-
-// bring forces back together to consolidate attacks
-event consolidateEvent(consolidateEventTr)
-{
-	if(not helpingAlly())
-	{
-		if(random(3) == 1)				// order all droids home to rejoin forces.!
-		{
-			// find a place with no structures nearby
-			buildX = baseX;
-			buildY = baseY;
-			pickStructLocationB(powGen, ref buildX, ref buildY, me, 0);
-
-			orderGroupLoc(scoutGroup, DORDER_MOVE,buildX,buildY);
-			orderGroupLoc(defendGroup, DORDER_MOVE,buildX,buildY);
-		}
-
-/*
-		if(attackObj != NULLOBJECT)	// consolidate any ongoing attack.
-		{
-			if(!friendlyPlayer(attackObj.player))
-			{
-				orderGroupLoc(attackGroup, DORDER_SCOUT, attackObj.x, attackObj.y);
-			}
-			else
-			{
-				attackObj = NULLOBJECT;
-			}
-		}
-		else if(allOutAttack == NULLOBJECT) //make sure not allOutAttacking
-		{
-
-			// find a place with no structures nearby
-			buildX = baseX;
-			buildY = baseY;
-			pickStructLocationB(powGen, ref buildX, ref buildY, me, 0);
-
-			orderGroupLoc(attackGroup, DORDER_MOVE,buildX,buildY);
-		}
-*/
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-
-event difficultyModifier(difficultyModifierTr)
-{
-	if(not isHumanPlayer(me))
-	{
-		skDifficultyModifier(me);
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// vtols.
-/////////////////////////////////////////////////////////////////////
-// build vtol strucutures.
-event vtolStructs(inactive)
-{
-	local	int		_numVtolFacs,_numRearmPads;
-
-	// got any idle trucks?
-	if (idleGroup(buildGroup) < 1)
-	{
-		exit;
-	}
-
-	// see how many vtol factories we already have
-	_numVtolFacs = getNumStructures(vtolFactory,me);
-	_numRearmPads = getNumStructures(vtolPad,me);
-
-	//see if we have enough rearm pads
-	if( _numRearmPads * 4 / 3 <= totalVtols() )
-	{
-		dbg("NEED REARM PADS", me);
-		buildRearmPads();
-	}
-
-	if (_numVtolFacs > 0 and playerPower(me) < LOW_POWER)
-	{
-		exit;	// Throttle expansion to avoid waste
-	}
-
-	if (isStructureAvailable(vtolFactory, me) and _numVtolFacs < maxVtolFacs[curTech])			// if not enough
-	{
-		if (not grabTrucksAndBuild(8, vtolFactory, 1))
-		{
-			dbg("Failed to build Vtol fac", me);
-		}
-	}
-}
-
-//counts vtols
-function int totalVtols()
-{
-	local	int		_vtolGroup,_totalVtols;
-
-	_totalVtols = 0;
-	_vtolGroup = 0;
-	while(_vtolGroup < numVtolAttackGroups)
-	{
-		_totalVtols = _totalVtols + vtolAttackGr[_vtolGroup].members;
-		_vtolGroup++;
-	}
-
-	_totalVtols = _totalVtols + vtolDefendGr.members;
-
-	return _totalVtols;
-}
-
-function void buildRearmPads()
-{
-	if (isStructureAvailable(vtolPad, me))
-	{
-		if (not grabTrucksAndBuild(4, vtolPad, -1))
-		{
-			dbg("Failed to build vtol pad", me);
-		}
-	}
-}
-
-
-/////////////////////////////////////////////////////////////////////
-// build vtols.
-
-event buildVtols(inactive)
-{
-	// got enough vtols?
-	if((vtolDefendGr.members >= maxVTOLs[curTech]) or (getDroidCount(me) >= MAX_DROIDS)){
-		dbg("CAN'T BUILD VTOLS - TOO MANY UNITS", me);
-		exit;
-	}
-
-	// build vtols
-	initEnumStruct(FALSE,vtolFactory,me,me);
-	structure = enumStruct();
-	while(structure != NULLOBJECT)
-	{
-		if(structureIdle(structure))	// if factory idle
-		{
-			vtolFactoryBuildVtol(structure);
-		}
-
-		structure = enumStruct();
-	}
-}
-
-
-function void vtolFactoryBuildVtol(STRUCTURE _factory)
-{
-	local	int		_numTemplates,_bestTemplates;
-
-	if(_factory == NULLOBJECT){
-		return;
-	}
-
-	if( structureIdle(_factory) )
-	{
-		_numTemplates = numVtolTemplates - 1;
-		_bestTemplates = 0;
-		while( (_bestTemplates < 3) and (_numTemplates >= 0) )
-		{
-			if( skCanBuildTemplate(me,_factory, vtols[_numTemplates]) )
-			{
-				tmplChoice[_bestTemplates] = vtols[_numTemplates];
-				_bestTemplates++;
-			}
-			_numTemplates--;
-		}
-
-		if(_bestTemplates > 0)
-		{
-			buildDroid(tmplChoice[random(_bestTemplates)],_factory,me,1);
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// attack with vtols.
-
-event vtolAttack(inactive)
-{
-	local		int			_groupIndex,_newTargetWeight,_oldTargetWeight;
-	local		BASEOBJ		_newTarget;
-	local		bool		_bHaveDefendTarget;
-	local		DROID		_droid;
-
-	// if vtol group is not busy..
-	if(  (idleGroup(vtolDefendGr) >= (vtolDefendGr.members / 2)) and (vtolDefendGr.members >= 2) )
-	{
-		if(attackObj != NULLOBJECT)
-		{
-			if(!friendlyPlayer(attackObj.player))
-			{
-				orderGroupObj(vtolDefendGr, DORDER_ATTACK, attackObj);	// get the attack target.
-			}
-			else
-			{
-				attackObj = NULLOBJECT;
-			}
-		}
-		else
-		{
-			if(defendObj != NULLOBJECT)
-			{
-				orderGroupObj(vtolDefendGr, DORDER_ATTACK,defendObj);		// get the defend target
-			}
-		}
-	}
-
-	//make sure attack vtol groups are not cluttered
-	rearrangeAttackVtols();
-
-	//attack vtols
-	_groupIndex = 0;
-	while(_groupIndex < numVtolAttackGroups)
-	{
-		if(vtolAttackGr[_groupIndex].members > 0)
-		{
-			// if our base is in trouble see if we have a target in the base
-			// don't choose new target if already have one
-			_bHaveDefendTarget = FALSE;
-			if((vtolGrAttackObj[_groupIndex] != NULLOBJECT))
-			{
-				if(defendingOwnBase() and
-					(distBetweenTwoPoints(baseX, baseY, vtolGrAttackObj[_groupIndex].x, vtolGrAttackObj[_groupIndex].y) <= MAX_VTOL_DEFEND_RADIUS))
-				{
-					_bHaveDefendTarget = TRUE;
-				}
-				else	//reset target if it's not worth it
-				{
-					//we don't want to attack enemy heavy tanks outside of our base
-					if(vtolGrAttackObj[_groupIndex].type == OBJ_DROID)
-					{
-						_droid = objToDroid(vtolGrAttackObj[_groupIndex]);
-						if(_droid.droidType != DROID_CONSTRUCT)
-						{
-							vtolGrAttackObj[_groupIndex] = NULLOBJECT;	//reset target
-							_bHaveDefendTarget = FALSE;
-						}
-					}
-				}
-			}
-
-			//find target in our base if our base is in trouble
-			if(!_bHaveDefendTarget and defendingOwnBase())
-			{
-				vtolGrAttackObj[_groupIndex] = chooseVtolDefenceTarget(baseX, baseY, MAX_VTOL_DEFEND_RADIUS, FALSE);
-
-				if(vtolGrAttackObj[_groupIndex] != NULLOBJECT)
-				{
-					dbg("assigned new defence target for group " & _groupIndex, me);
-					_bHaveDefendTarget = TRUE;
-				}
-			}
-
-			//attack rules
-			if(!_bHaveDefendTarget and (idleGroup(vtolAttackGr[_groupIndex]) >= (vtolAttackGr[_groupIndex].members / 2)) and
-			(vtolAttackGr[_groupIndex].members >= (numAttackVtols * 2 / 3)))
-			{
-				_newTarget = NULLOBJECT;
-
-				//reset attack targets once in a while
-				if(vtolGrAttackObj[_groupIndex] != NULLOBJECT)
-				{
-					if(random(10) > 7)
-					{
-						vtolGrAttackObj[_groupIndex] = NULLOBJECT;
-					}
-				}
-
-				//now try to find an attack target if we have no defence target
-				//find best attack target
-				_newTarget = chooseVtolTarget(TRUE);	//search for an exclusive target
-				if(_newTarget == NULLOBJECT)
-				{
-					_newTarget = chooseVtolTarget(FALSE);	//search for any target
-				}
-
-				_newTargetWeight = getVtolTargetWeight(_newTarget);
-				_oldTargetWeight = getVtolTargetWeight(vtolGrAttackObj[_groupIndex]);
-
-				// new one or a much better one
-				if((_newTargetWeight >= (_oldTargetWeight + 20)) or
-					(vtolGrAttackObj[_groupIndex] == NULLOBJECT ))
-				{
-					dbg("choosing new attack object for " & _groupIndex, me);
-					vtolGrAttackObj[_groupIndex] = _newTarget;
-				}
-			}
-
-			//see if this group has something to attack
-			if(vtolGrAttackObj[_groupIndex] != NULLOBJECT)
-			{
-				if(!friendlyPlayer(vtolGrAttackObj[_groupIndex].player))
-				{
-					dbg("VTOL Group " & _groupIndex & " attacking", me);
-
-					if(_DEBUG and (_groupIndex == 0))
-					{
-						dropBeacon(getPlayerName(me), me, me, vtolGrAttackObj[_groupIndex].x, vtolGrAttackObj[_groupIndex].y, 0);
-					}
-
-					orderGroupObj(vtolAttackGr[_groupIndex], DORDER_ATTACK, vtolGrAttackObj[_groupIndex]);
-				}
-				else
-				{
-					vtolGrAttackObj[_groupIndex] = NULLOBJECT;
-				}
-			}
-		}
-
-		_groupIndex++;
-	}
-}
-
-//make sure vtol groups are not cluttered
-function void rearrangeAttackVtols()
-{
-	local	int		_emptyGr,_fillGr;
-	local	DROID	_droid;
-
-	_emptyGr = 0;
-	while(_emptyGr < numVtolAttackGroups)
-	{
-		if((vtolAttackGr[_emptyGr].members < numAttackVtols) and	//this group is not full
-			(vtolAttackGr[_emptyGr].members > 0))
-		{
-			//try to make full groups by moving vtols from the last groups
-			_fillGr = _emptyGr + 1;	//start from the next group
-			while((_fillGr < numVtolAttackGroups) and
-				(vtolAttackGr[_emptyGr].members < numAttackVtols))
-			{
-				initIterateGroup(vtolAttackGr[_fillGr]);
-				_droid = iterateGroup(vtolAttackGr[_fillGr]);
-				while((_droid != NULLOBJECT) and
-					(vtolAttackGr[_emptyGr].members < numAttackVtols))
-				{
-					groupAddDroid(vtolAttackGr[_emptyGr], _droid);	//refill the group
-					_droid = iterateGroup(vtolAttackGr[_fillGr]);
-				}
-
-				_fillGr++;
-			}
-		}
-		_emptyGr++;
-	}
-}
-
-function BASEOBJ chooseVtolDefenceTarget(int _x, int _y, int _range, bool bExclusiveTarget)
-{
-	local	BASEOBJ		_target;
-
-	_target = getClosestEnemy(_x, _y, _range, FALSE, FALSE, me);
-
-	// make sure no one else is targeting it already if we want exclusive targets
-	if(bExclusiveTarget and vtolTargetAssigned(_target))
-	{
-		_target = NULLOBJECT;
-	}
-
-	return _target;
-}
-
-function BASEOBJ chooseVtolTarget(bool bExclusiveTarget)
-{
-	local 	int				_structTypeIndex,_enemy;
-	local	int				_bestScore,_tempScore;
-	local	BASEOBJ			_bestTarget;
-	local	STRUCTURE		_structure;
-
-	_bestScore = 0;
-	_bestTarget = NULLOBJECT;
-
-	_enemy = 0;
-	while(_enemy < MAX_PLAYERS)
-	{
-		if(!friendlyPlayer(_enemy))
-		{
-			_structTypeIndex = 0;
-			while(_structTypeIndex < numVtolTargets)
-			{
-				initEnumStruct(FALSE,vtolTarget[_structTypeIndex],_enemy,me);
-				_structure = enumStruct();
-				while(_structure != NULLOBJECT)
-				{
-
-					// in case we don't want all groups to attack the same target
-					if(not (bExclusiveTarget and vtolTargetAssigned(_structure)) )
-					{
-						_tempScore = getVtolTargetWeight(_structure);
-
-						//see if this one is better
-						if(_tempScore > _bestScore)
-						{
-							_bestScore = _tempScore;
-							_bestTarget = _structure;
-						}
-					}
-
-					_structure = enumStruct();
-				}
-
-				_structTypeIndex++;
-			}
-		}
-		_enemy++;
-	}
-
-	return _bestTarget;
-}
-
-function int getVtolTargetWeight(BASEOBJ _target)
-{
-	local 	int 		_AAPenalty,_numAA,_range,_targetWeight;
-	local 	int 		_targetType;
-	local	STRUCTURE	_structTarget;
-
-	if(_target == NULLOBJECT)
-	{
-		return 0;
-	}
-
-	if(_target.type != OBJ_STRUCTURE)
-	{
-		return 0;
-	}
-
-	_structTarget = objToStructure(_target);
-
-	_targetWeight = 0;
-
-	_AAPenalty = 9;			//penalty per aa defense
-	_range = AA_THREAT_RANGE;
-
-	// count enemy AA
-	_numAA = numEnemyAAInRange(_structTarget.x, _structTarget.y, _range);
-
-	// find tyrget type from stats
-	_targetType = 0;
-	while(_targetType < numVtolTargets)
-	{
-		if(_structTarget.stat == vtolTarget[_targetType])
-		{
-			_targetWeight = vtolTargetWeight[_targetType] - (_numAA * _AAPenalty);
-
-			_targetType = numVtolTargets;	//exit loop
-		}
-		_targetType++;
-	}
-
-	// incomplete structures get lower weight
-	if(!structureComplete(_structTarget))
-	{
-		_targetWeight = _targetWeight / 10;
-	}
-
-	return _targetWeight;
-}
-
-function int numEnemyAAInRange(int _x, int _y, int _range)
-{
-	local int _enemy,_numAA;
-
-	_numAA = 0;
-	_enemy = 0;
-	while(_enemy < MAX_PLAYERS)
-	{
-		if(!friendlyPlayer(_enemy))
-		{
-			_numAA = _numAA + numAAinRange(_enemy, me, _x, _y, _range);
-		}
-		_enemy++;
-	}
-
-	return _numAA;
-}
-
-// see if a particular target is already assigned to one of the VTOL attack groups
-function bool vtolTargetAssigned(BASEOBJ _target)
-{
-	local int _groupIndex;
-
-	if(_target == NULLOBJECT)
-	{
-		return FALSE;
-	}
-
-	_groupIndex = 0;
-	while(_groupIndex < numVtolAttackGroups)
-	{
-		if(_target == vtolGrAttackObj[_groupIndex])
-		{
-			return TRUE;
-		}
-
-		_groupIndex++;
-	}
-
-	return FALSE;
-}
-
-/////////////////////////////////////////////////////////////////////
-// watch for incoming vtols
-event vtolDefend(vtolDefendTr)
-{
-	local	int		_numBuilders,_maxBuilders;
-
-	if(baseobj != NULLOBJECT)
-	{
-		if(baseobj.type == OBJ_DROID)
-		{
-			if(isVtol(objToDroid(baseobj)))
-			{
-				_numBuilders = 0;
-				_maxBuilders = 2;
-
-				// build defenses.
-				initIterateGroup(buildGroup);		// find idle droids in build group.
-				droid = iterateGroup(buildGroup);
-				while( droid != NULLOBJECT)
-				{
-					if( (structure != NULLOBJECT) and (droid.order != DORDER_BUILD) )
-					{
-						buildX = structure.x;
-						buildY = structure.y;
-						//	if ! vtol defense already built...
-
-						//find best defense we can build.
-						count = 0;
-						count2 = -1;
-						while( count < 5)
-						{
-							if(isStructureAvailable(vtolDefStruct[count],me))
-							{
-								count2 = count;
-							}
-							count = count + 1;
-						}
-						if(count2 != (-1) )
-						{
-							boolResult = pickDroidStructLocation(droid, vtolDefStruct[count2], ref buildX, ref buildY, me, 1);
-							if (boolResult == TRUE and (_numBuilders < _maxBuilders))	// build a vtol defense near the attacked struct...
-							{
-								orderDroidStatsLoc(droid, DORDER_BUILD,vtolDefStruct[count2],buildX,buildY);
-								_numBuilders++;
-							}
-						}
-
-					}
-					droid = iterateGroup(buildGroup);
-				}
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-event vtolEnabler(vtolEnablerTr)
-{
-	if( skVtolEnableCheck(me) )					// check to see if we have vtol technologies.
-	{
-		setEventTrigger(vtolEnabler,inactive);		// turn off this event.
-		setEventTrigger(vtolStructs,vtolStructsTr);	// activate other vtol functions..
-		setEventTrigger(buildVtols,	buildVtolsTr);
-		setEventTrigger(vtolAttack,	vtolAttackTr);
-		dbg("----I CAN USE VTOLS----", me);
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// HouseKeeping
-
-function void shutDownAI()
-{
-	bRunning = false;
-
-	setEventTrigger(basedetails,	inactive);
-	setEventTrigger(buildDerrick,	inactive);
-	setEventTrigger(buildOilDefenseOrRetreat,	inactive);
-	setEventTrigger(incendry,	inactive);
-	setEventTrigger(buildPowerGenerators,	inactive);
-	setEventTrigger(buildBase,	inactive);
-	setEventTrigger(buildExpand,inactive);
-	setEventTrigger(upgradeStructures,inactive);
-	setEventTrigger(finishStructs,	inactive);
-	setEventTrigger(newfortify,	inactive);
-	setEventTrigger(droidBuiltAssign, inactive);
-	setEventTrigger(droidBuilt,	inactive);
-	setEventTrigger(structBuilt,inactive);
-	setEventTrigger(droidDestroyed,inactive);
-	setEventTrigger(conDroids,inactive);
-	setEventTrigger(repairDroids,inactive);
-	setEventTrigger(factoryEvent,	inactive);
-	setEventTrigger(cyborgFactoryEvent,	inactive);
-	setEventTrigger(chooseScoutArea,	inactive);
-	setEventTrigger(expandScoutArea,	inactive);
-	setEventTrigger(scoutMain,	inactive);
-	setEventTrigger(newObjectReport,	inactive);
-	setEventTrigger(takeover,	inactive);
-	setEventTrigger(takeoverDefend,	inactive);
-	setEventTrigger(useLassat,	inactive);
-	setEventTrigger(findEnemy,	inactive);
-	setEventTrigger(attackStuff,	inactive);
-	setEventTrigger(defendWatch,	inactive);
-	setEventTrigger(defendReturn,	inactive);
-	setEventTrigger(doResearch,	inactive);
-	setEventTrigger(formAllianceEvent,	inactive);
-	setEventTrigger(breakAllianceEvent,	inactive);
-	setEventTrigger(formHumanAlliances,	inactive);
-	setEventTrigger(consolidateEvent,	inactive);
-	setEventTrigger(vtolStructs,inactive);
-	setEventTrigger(buildVtols,inactive);
-	setEventTrigger(vtolAttack,inactive);
-	setEventTrigger(vtolDefend,inactive);
-	setEventTrigger(vtolEnabler,inactive);
-	setEventTrigger(beaconEv,	inactive);
-	setEventTrigger(multiMsgEv,	inactive);
-	setEventTrigger(manageAllyHelp,	inactive);
-	setEventTrigger(everySecEv,	inactive);
-	setEventTrigger(watchBaseThreat, inactive);
-	setEventTrigger(manageDefendLocationEv,	inactive);
-	setEventTrigger(structureDestroyed,inactive);
-	setEventTrigger(rebuildStructureEv,inactive);
-	setEventTrigger(startLevel, inactive);
-	setEventTrigger(arrived, inactive);
-	setEventTrigger(checkResearch, inactive);
-}
-
-function void reassignAI()
-{
-	bRunning = true;
-
-	setEventTrigger(basedetails,basedetailsTr);
-	setEventTrigger(buildDerrick,buildDerrickTr);
-	setEventTrigger(buildOilDefenseOrRetreat,buildOilDefenseOrRetreatTr);
-	setEventTrigger(incendry,incendryTr);
-	setEventTrigger(buildPowerGenerators,buildPowerGeneratorsTr);
-	setEventTrigger(buildBase,buildBaseTr );
-	setEventTrigger(buildExpand,buildExpandTr );
-	setEventTrigger(upgradeStructures,upgradeStructuresTr );
-	setEventTrigger(finishStructs,finishStructsTr );
-	setEventTrigger(newfortify,fortifyTr );
-	setEventTrigger(droidBuiltAssign,droidBuiltTr);
-	setEventTrigger(droidBuilt,droidBuiltTr);
-	setEventTrigger(droidDestroyed,droidDestroyedTr);
-	setEventTrigger(conDroids,conDroidsTr);
-	setEventTrigger(repairDroids,repairDroidsTr);
-	setEventTrigger(factoryEvent,factoryEventTr);
-	setEventTrigger(cyborgFactoryEvent,cyborgFactoryEventTr);
-	setEventTrigger(chooseScoutArea,chooseScoutAreaTr);
-	setEventTrigger(expandScoutArea,expandScoutAreaTr);
-	setEventTrigger(scoutMain,scoutMainTr);
-	setEventTrigger(newObjectReport,newObjectReportTr);
-	setEventTrigger(takeover,takeoverTr);
-	setEventTrigger(useLassat,useLassatTr);
-	setEventTrigger(findEnemy,attackStuffTr);
-	setEventTrigger(attackStuff,attackStuffTr);
-	setEventTrigger(doAllOutAttack,allOutAttackTr);
-	setEventTrigger(defendWatch,defendWatchTr);
-	setEventTrigger(defendReturn,defendReturnTr);
-	setEventTrigger(doResearch,doResearchTr);
-	setEventTrigger(formAllianceEvent,formAllianceEventTr);
-	setEventTrigger(breakAllianceEvent,breakAllianceEventTr);
-	setEventTrigger(consolidateEvent,consolidateEventTr);
-	setEventTrigger(vtolStructs,inactive);
-	setEventTrigger(buildVtols,inactive);
-	//setEventTrigger(vtolAttack,inactive);
-	setEventTrigger(vtolAttack,	vtolAttackTr);
-	setEventTrigger(vtolDefend,vtolDefendTr);
-	setEventTrigger(vtolEnabler,vtolEnablerTr);
-	setEventTrigger(formHumanAlliances,humanAllianceTr);
-	setEventTrigger(multiMsgEv, multiMsgTr);
-	setEventTrigger(beaconEv, beaconTr);
-	setEventTrigger(watchBaseThreat, watchBaseThreatTr);
-	setEventTrigger(manageAllyHelp, manageAllyHelpTr);
-	setEventTrigger(everySecEv, everySec);
-	//setEventTrigger(manageDefendLocationEv, manageDefendLocationTr);
-	setEventTrigger(structBuilt, structBuiltTr);
-	setEventTrigger(structureDestroyed, structureDestroyedTr);
-	setEventTrigger(rebuildStructureEv, rebuildStructureTr);
-	setEventTrigger(startLevel, startLevelTr);
-	setEventTrigger(arrived, reachedTr);
-	setEventTrigger(checkResearch, checkResearchTr);
-}
-
-/* Returns true if we just received a beacon from a certain player */
-function bool haveBeacon(int _player)
-{
-		if((tBeacon[_player] > 0) and (not beaconTimeout(_player)))
-		{
-			return TRUE;	//have beacon for this player
-		}
-
-		return FALSE;
-}
-
-/* See if last beacon was placed long ago */
-function bool beaconTimeout(int _player)
-{
-	if((tBeacon[_player] > 0) and
-		((tBeacon[_player] + BEACON_TIMEOUT) < (gameTime / 10)))	//not too long ago
-	{
-		return TRUE;	//this beacon is still 'fresh'
-	}
-
-	return FALSE;
-}
-
-/* Deal with beacons */
-event beaconEv(beaconTr)
-{
-	local	int			_players;
-	local	string		_processedString;
-
-	if(_DEBUG)
-		debug(me & ") beaconEv: from " & sender);
-
-	ASSERT(sender >= 0 and sender < MAX_PLAYERS,
-		"beaconEv: sender out of bounds: " & sender , me);
-
-	beaconX[sender] = x;
-	beaconY[sender] = y;
-	tBeacon[sender] = gameTime / 10;
-
-	processCommand(message, sender, TRUE);
-}
-
-/* Deal with a chat message */
-event multiMsgEv(multiMsgTr)
-{
-	if(_DEBUG)
-		debug(me & ") multiMsgEv: from " & sender);
-
-	if(not allianceExistsBetween(me, sender)){
-		exit;
-	}
-
-	if(sender == me){
-		exit;
-	}
-
-	processCommand(message, sender, FALSE);
-}
-
-/* Process multiplayer messages */
-function void processCommand(string _message, int _sender, bool _bBlipMessage)
-{
-	local	int 		_numMsgs,_curMsg,_addressedPlayers,_x,_y;
-	local	string		_msg,_processedString;
-
-	/* Extract semantic information */
-	_curMsg = 0;
-	_numMsgs = processChatMsg(_message);
-
-	debug(me & ") processCommand: '" & _message & "' from " & _sender);
-	dbg("processCommand: '" & _message & "' from " & _sender, me);
-	dbg("got " & _numMsgs & " commands", me);
-
-	/* Process all messages */
-	while(_curMsg < _numMsgs)
-	{
-		if(chatCmdIsPlayerAddressed(_curMsg, me))
-		{
-			dbg("i'm addressed", me);
-			_msg = getChatCmdDescription(_curMsg);
-
-			/* Someone requested help */
-			if(_msg == R_REQUEST_HELP)
-			{
-				dbg("'help' command", me);
-
-				if(haveBeacon(_sender))
-				{
-					dbg("got beacon", me);
-
-					_x = beaconX[_sender];
-					_y = beaconY[_sender];
-
-					if(attemptToHelp(_sender, _x, _y))
-					{
-						messagePlayer(ALL_ALLIES, m_affirmative(), MAX_PROBABILITY);
-					}
-				}
-				else
-				{
-					/* Ask player to drop a beacon so we would know where to help */
-					_addressedPlayers = setBit(0, _sender, TRUE);
-					messagePlayerAddressed(ALL_ALLIES, _addressedPlayers, R_REQUEST_BEACON);
-				}
-			}
-			/* Someone requested a beacon from us -
-			 * did we request help and our beacon timed out??
-			 */
-			else if(_msg == M_REQUEST_BEACON)
-			{
-				/* If our base is really in trouble drop a beacon for the requester again */
-				if(baseInTrouble()){
-					dropBeacon(getPlayerName(me), _sender, me, baseX, baseY, 0);
-				}
-			}
-			else if(_msg == R_REPORT_SAFETY)
-			{
-				dbg("helping " & lastHelpPlayer, me);
-
-				/* Make sure we were helping him */
-				if(helpingAlly() and (lastHelpPlayer == _sender))
-				{
-					stopHelpingAlly();
-					messagePlayer(ALL_ALLIES, m_affirmative(), MAX_PROBABILITY);
-				}
-				else if(defendingOwnBase())	//if we are in trouble re-request help
-				{
-					requestHelp(baseX, baseY);
-				}
-			}
-			else
-			{
-				dbg("unknown message", me);
-			}
-
-		}
-		else
-		{
-			dbg("i'm not addressed", me);
-		}
-
-		_curMsg++;
-	}
-}
-
-function bool attemptToHelp(int _playerToHelp, int _x, int _y)
-{
-	local bool _bHelpingMyself;
-
-	if(_playerToHelp < 0 or _playerToHelp >= MAX_PLAYERS){
-		return FALSE;
-	}
-
-	if(_x <= 0 or _y <= 0){
-		return FALSE;
-	}
-
-	dbg("attemptToHelp - checking", me);
-
-	_bHelpingMyself = (_playerToHelp == me);
-
-	/* Can only help allies and myself */
-	if(not friendlyPlayer(_playerToHelp)){
-		return FALSE;
-	}
-
-	if(_bHelpingMyself or !helpingAlly() or (lastHelpPlayer == _playerToHelp) )	//if not helping any other ally or it's me who needs help
-	{
-		dbg("not busy helping", me);
-
-		if(haveHelpers() or _DEBUG)
-		{
-			dbg("got attackers", me);
-			//if(allyBaseAtLoc(_playerToHelp, _x, _y))	//is he just trying to misuse us?
-			//{
-				helpPlayer(_playerToHelp, _x, _y);
-				return TRUE;
-			//}
-			//else
-			//{
-			//	dbg("ally needs no help", me);
-			//	messagePlayer(ALL_ALLIES, M_ANNOYED, MAX_PROBABILITY / 2);
-			//}
-		}
-		else
-		{
-			messagePlayer(ALL_ALLIES, M_HELP_NO_UNITS, MAX_PROBABILITY);
-		}
-	}
-	else if((lastHelpPlayer >= 0) and (lastHelpPlayer < MAX_PLAYERS))
-	{
-		if(!_bHelpingMyself){
-			messagePlayer(ALL_ALLIES, "helping " & getPlayerName(lastHelpPlayer) & " already", MAX_PROBABILITY);
-		}
-	}
-
-	return FALSE;
-}
-
-/* Start helping player */
-function void helpPlayer(int _playerToHelp, int _helpX, int _helpY)
-{
-	local int _tTravelTime;
-
-	dbg("helping " & _playerToHelp, me);
-
-	if(_DEBUG)
-		debug(me & ") helpPlayer: '" & _playerToHelp);
-
-	/* Move scoutes to attackers */
-	groupAddGroup(attackGroup, scoutGroup);
-
-	//Calculate travel time, assume ~ 150 tiles in 4 minutes
-	if(attackGroup.members == 0){
-		_tTravelTime = (int)((float)(distBetweenTwoPoints(baseX, baseY, _helpX, _helpY) / 128 ) * 1.7);
-	}else{
-		_tTravelTime = (int)((float)(distBetweenTwoPoints(attackGroup.x, attackGroup.y, _helpX, _helpY) / 128 ) * 1.7);
-	}
-
-	tHelp = gameTime / 10;
-	tHelpTimeout = (gameTime / 10) + BASE_DEFEND_DURATION + _tTravelTime;
-	lastHelpPlayer = _playerToHelp;
-	helpX = _helpX;
-	helpY = _helpY;
-
-	/* Scouts and attackers go to help */
-	defendLocation(_helpX, _helpY, tHelpTimeout, (_playerToHelp == me));
-}
-
-/* Returns a random affirmative responce */
-function string m_affirmative()
-{
-	local int _rnd;
-
-	_rnd = random(4);
-	if(_rnd == 3)
-	{
-		return M_AFFIRMATIVE_ROGER;
-	}
-
-	return M_AFFIRMATIVE_OK;
-}
-
-/* See if there are any base structures belonging to ally at a certain location */
-function bool allyBaseAtLoc(int _ally, int _x, int _y)
-{
-	local int _structIndex;
-
-	if(_x <= 0 or _y <= 0){
-		return FALSE;
-	}
-
-	if(_ally < 0 or _ally >= MAX_PLAYERS){
-		return FALSE;
-	}
-
-	_structIndex = 0;
-	while(_structIndex < numBaseStruct)
-	{
-		if(numStructsByStatInRange(baseStruct[_structIndex], _x, _y, (7 * 128), me, _ally) > 0 )
-		{
-			return TRUE;
-		}
-
-		_structIndex++;
-	}
-
-	return FALSE;
-}
-
-event manageAllyHelp(manageAllyHelpTr)
-{
-	if(helpingAlly())
-	{
-		if(canStopHelpingAlly())
-		{
-			stopHelpingAlly();
-		}
-	}
-}
-
-event everySecEv(everySec)
-{
-	/* Check if we were helping long enough */
-	if(helpingAlly())
-	{
-		if(helpAllyTimeout())
-		{
-			stopHelpingAlly();
-		}
-	}
-
-	if(defendingLocation())
-	{
-		if(defendLocationTimeout())
-		{
-			stopDefendingLocation();
-		}
-	}
-}
-
-/* Do we have any units we can send to help ally ? */
-function bool haveHelpers()
-{
-	if(attackGroup.members == 0){
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-function bool helpingAlly()
-{
-	if(lastHelpPlayer >= 0){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-/* Returns true if we were helping long enough */
-function bool helpAllyTimeout()
-{
-	if(tHelpTimeout < (gameTime / 10) ){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-function bool canStopHelpingAlly()
-{
-	if(lastHelpPlayer < 0)
-	{
-		ASSERT(FALSE, "canStopHelpingAlly: lastHelpPlayer < 0", me);
-		return TRUE;
-	}
-
-	/* Were helping long enough or someone's backstabbing */
-	if(!friendlyPlayer(lastHelpPlayer)){
-		return TRUE;
-	}
-
-	/* Nothing to defend anymore */
-	//if(!allyBaseAtLoc(lastHelpPlayer, helpX, helpY)){
-	//	return TRUE;
-	//}
-
-	return FALSE;
-}
-
-function void stopHelpingAlly()
-{
-	dbg("stopped helping", me);
-
-	tHelp = -1;
-	tHelpTimeout = -1;
-	lastHelpPlayer = -1;
-	helpX = -1;
-	helpY = -1;
-
-	stopDefendingLocation();
-}
-
-/* Send a multiplayer message to an ally */
-function void messagePlayer(int _playerToMessage, string _message, int _probability)
-{
-	local int	_player;
-
-	ASSERT(_playerToMessage >= -1 && _playerToMessage < MAX_PLAYERS,
-		"messagePlayer: player out of bounds: " & _playerToMessage, me);
-
-	// throw the dice
-	if( random(MAX_PROBABILITY) >= _probability ){
-		return;
-	}
-
-	_player = 0;
-	if(_playerToMessage == ALL_ALLIES)	//everyone
-	{
-		while(_player < MAX_PLAYERS)
-		{
-			/* Send message (allies only)) */
-			if(allianceExistsBetween(me, _player))
-			{
-				msg(_message, me, _player);
-			}
-
-			_player++;
-		}
-	}
-	else	//a certain player
-	{
-		/* Send message (allies only)) */
-		if(allianceExistsBetween(me, _playerToMessage))
-		{
-			msg(_message, me, _playerToMessage);
-		}
-	}
-}
-
-function int numBitsSet(int _integer)
-{
-	local	int		_position,_result;
-
-	_position = 0;
-	_result = 0;
-	while(_position < 8)
-	{
-		if(getBit(_integer, _position))
-		{
-			_result++;
-		}
-		_position++;
-	}
-
-	return _result;
-}
-
-/* Send a multiplayer message, addressing some player(s) */
-function void messagePlayerAddressed(int _playerToMessage, int _playersToAddress, string _message)
-{
-	local	int		_player,_totalAddressed,_curAddressed;
-	local	string	_adrMessage;
-
-	_totalAddressed = numBitsSet(_playersToAddress);
-
-	ASSERT(_totalAddressed > 0, "messagePlayerAddressed: no players addressed", me);
-
-	_adrMessage = " ";
-
-	_player = 0;
-	_curAddressed = 0;
-	while(_player < MAX_PLAYERS)
-	{
-		if(getBit(_playersToAddress, _player))
-		{
-			_curAddressed++;
-
-			_adrMessage = _adrMessage & getPlayerName(_player);
-
-			//if(_totalAddressed == 1){	//one only
-			//	_adrMessage = getPlayerName(_player);
-			//}else
-
-			if(_totalAddressed > 1)
-			{
-				if(_curAddressed == _totalAddressed){		//end
-					_adrMessage = _adrMessage & " and " & getPlayerName(_player);
-				}else{
-					_adrMessage = _adrMessage & ", " & getPlayerName(_player);
-				}
-			}
-
-		}
-		_player++;
-	}
-
-	_message = _adrMessage &  " " & _message;
-
-	//Now send the message to all players addressed
-	messagePlayer(_playerToMessage, _message, MAX_PROBABILITY);
-}
-
-/* Returns true if we can see our allies on the map */
-function bool canSeeAllies()
-{
-	local STRUCTURE _uplink;
-
-	/* Can see allies when team mode is on */
-	if(multiPlayerAlliancesType == ALLIANCES_TEAMS)
-	{
-		return TRUE;
-	}
-
-	/* Can see whole map if we have uplink */
-	_uplink = getStructure(uplink, me);
-	if(_uplink != NULLOBJECT)
-	{
-		/* Make sure finished building */
-		if(structureComplete(_uplink))
-		{
-			return TRUE;
-		}
-	}
-
-	return FALSE;
-}
-
-function bool defendingOwnBase()
-{
-	if(helpingAlly() && lastHelpPlayer == me){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-/* Call for help when our base is in danger */
-event watchBaseThreat(watchBaseThreatTr)
-{
-	/* See if we can stop defending */
-	if(defendingOwnBase())
-	{
-		if(numEnemiesInBase(FALSE) == 0)
-		{
-			stopHelpingAlly();	//stop defending our own base
-
-			/* Let allies know we don't need their help anymore */
-			messagePlayer(ALL_ALLIES, R_REPORT_SAFETY, MAX_PROBABILITY);
-			exit;
-		}
-	}
-
-	/* See if our base is in trouble and we need help */
-	if(baseInTrouble())
-	{
-		if(!defendingOwnBase())	//make sure not already defending the base
-		{
-			if(_DEBUG)
-				debug(me & ") watchBaseThreat: base in trouble");
-
-			dbg("watchBaseThreat: base in trouble", me);
-
-			/* Bring our forces back if needed */
-			if(helpingAlly())
-			{
-				stopHelpingAlly();
-			}
-
-			/* Defend my own base */
-			helpPlayer(me, baseX, baseY);
-		}
-
-		/* Request help once in a while */
-		requestHelp(baseX, baseY);
-		exit;
-	}
-}
-
-function int numAlliesInBase(bool _bVtols)
-{
-	local int _numAllies;
-
-	_numAllies = numFriendlyWeapDroidsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, _bVtols);
-	_numAllies = _numAllies +
-					numFriendlyWeapStructsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, true) / 3;
-
-	return _numAllies;
-}
-
-function int numEnemiesInBase(bool _bVtols)
-{
-	local int _numEnemies;
-
-	_numEnemies = numEnemyWeapDroidsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, _bVtols);
-	_numEnemies = _numEnemies +
-				numEnemyWeapStructsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, true) / 4;
-
-	return _numEnemies;
-}
-
-/* Returns true if our base is in trouble */
-function bool baseInTrouble()
-{
-	local int _enemyForce,_friendlyForce;
-
-	_friendlyForce = numAlliesInBase(FALSE);
-	_enemyForce = numEnemiesInBase(FALSE);
-
-	/* See if we are in trouble */
-	if((_enemyForce > 0) && (_enemyForce >= _friendlyForce)){
-		dbg("baseInTrouble: " & _enemyForce & " >= " & _friendlyForce, me);
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-/* Request help from allies */
-function void requestHelp(int _helpX, int _helpY)
-{
-	/* Don't do this too frequently */
-	if(tLastHelpRequest + HELP_REQUEST_INTERVAL > (gameTime / 10) ){
-		return;
-	}
-
-	doRequestHelp(_helpX, _helpY);
-}
-
-function void doRequestHelp(int _helpX, int _helpY)
-{
-	local int _ally;
-
-	/* Remember when we requested help last time */
-	tLastHelpRequest = gameTime / 10;
-
-	/* Drop beacon for all allies so they would know where to help */
-	_ally = 0;
-	while(_ally < MAX_PLAYERS)
-	{
-		if(allianceExistsBetween(me, _ally)){
-			if(_DEBUG)
-				debug(me & ") requestHelp: " & _ally);
-
-			dropBeacon(getPlayerName(me), _ally, me, _helpX, _helpY, 0);
-		}
-		_ally++;
-	}
-
-	/* Now send message with help request */
-	messagePlayer(ALL_ALLIES, M_REQUEST_HELP, MAX_PROBABILITY);
-}
-
-function void defendLocation(int _defendX, int _defendY, int _tDefendTimeout, bool _bMove)
-{
-	local int defendRadius;
-
-	defendRadius = 15 * TILE;
-
-	dbg("starting defending for " & _tDefendTimeout - (gameTime / 10) & " secs, with defend radius " & defendRadius, me);
-
-	defendX = _defendX;
-	defendY = _defendY;
-
-	tDefendStart = gameTime / 10;
-
-	/* Should already include travel time */
-	tDefendTimeout = _tDefendTimeout;
-
-	/* See if we have to move or scout */
-	defendMoveType = DORDER_SCOUT;
-	if(_bMove){
-		defendMoveType = DORDER_MOVE;
-	}
-
-	/* Send attackers */
-	if(attackGroup.members > 0)
-	{
-		if(distBetweenTwoPoints(attackGroup.x, attackGroup.y, _defendX, _defendY) > defendRadius)
-		{
-			orderGroupLoc(attackGroup, defendMoveType, _defendX, _defendY);
-		}
-	}
-
-	setEventTrigger(manageDefendLocationEv,	manageDefendLocationTr);
-}
-
-function void stopDefendingLocation()
-{
-	dbg("stopped defending location", me);
-
-	defendX = -1;
-	defendY = -1;
-
-	tDefendStart = -1;
-	tDefendTimeout = -1;
-
-	defendMoveType = -1;
-
-	setEventTrigger(manageDefendLocationEv,	inactive);
-
-	orderGroupLoc(attackGroup, DORDER_SCOUT,baseX,baseY);
-}
-
-function bool defendingLocation()
-{
-	if(defendX > 0 and defendY > 0){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-event manageDefendLocationEv(inactive)
-{
-	local int defendRadius;
-	local DROID _droid;
-
-	if (not defendingLocation())
-	{
-		exit;
-	}
-
-	defendRadius = 15 * TILE;
-
-	dbg("manageDefendLocationEv", me);
-
-	ASSERT(defendMoveType == DORDER_MOVE || defendMoveType == DORDER_SCOUT,
-		"manageDefendLocationEv: wrong move order:" & defendMoveType, me);
-
-	ASSERT(defendX > 0 && defendY > 0,
-		"manageDefendLocationEv: x/y coordinates:" & defendX & "/" & defendY, me);
-
-	/* Collect attackers */
-	initIterateGroup(attackGroup);
-	_droid = iterateGroup(attackGroup);
-	while(_droid != NULLOBJECT)
-	{
-		if(distBetweenTwoPoints(_droid.x,_droid.y,defendX,defendY) > defendRadius)	//too far from defend location
-		{
-			if(distBetweenTwoPoints(_droid.orderx,_droid.ordery,defendX,defendY) > defendRadius)	//not already on its way to the defend location
-			{
-				orderDroidLoc(_droid, defendMoveType, defendX, defendY);
-			}
-		}
-		_droid = iterateGroup(attackGroup);
-	}
-}
-
-function bool defendLocationTimeout()
-{
-	if(tDefendTimeout < (gameTime / 10) ){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-/* Returns true if player in question is my ally or if it's me */
-function bool friendlyPlayer(int _playerToCheck)
-{
-	if(allianceExistsBetween(_playerToCheck, me) or (_playerToCheck == me)){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-function bool insideBase(int _x, int _y)
-{
-	if(_x < minx){
-		return FALSE;
-	}
-
-	if(_x > maxx){
-		return FALSE;
-	}
-
-	if(_y < miny){
-		return FALSE;
-	}
-
-	if(_y > maxy){
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-event watchMenu(everySec)
-{
-	if(_DEBUG)
-	{
-		if(vtolGrAttackObj[0] == NULLOBJECT){
-			setDebugMenuEntry("0 - " & vtolAttackGr[0].members, 0);
-		}else{
-			setDebugMenuEntry("0 " & vtolAttackGr[0].members & " - " & (vtolGrAttackObj[0].x / TILE) & "-" & (vtolGrAttackObj[0].y / TILE), 0);
-		}
-
-		if(vtolGrAttackObj[1] == NULLOBJECT){
-			setDebugMenuEntry("1 - " & vtolAttackGr[1].members, 1);
-		}else{
-			setDebugMenuEntry("1 " & vtolAttackGr[1].members & " - " & (vtolGrAttackObj[1].x / TILE) & "-" & (vtolGrAttackObj[1].y / TILE), 1);
-		}
-
-		if(vtolGrAttackObj[2] == NULLOBJECT){
-			setDebugMenuEntry("2 - " & vtolAttackGr[2].members, 2);
-		}else{
-			setDebugMenuEntry("2 " & vtolAttackGr[2].members & " - " & (vtolGrAttackObj[2].x / TILE) & "-" & (vtolGrAttackObj[2].y / TILE), 2);
-		}
-
-		if(vtolGrAttackObj[3] == NULLOBJECT){
-			setDebugMenuEntry("3 - " & vtolAttackGr[3].members, 3);
-		}else{
-			setDebugMenuEntry("3 " & vtolAttackGr[3].members & " - " & (vtolGrAttackObj[3].x / TILE) & "-" & (vtolGrAttackObj[3].y / TILE), 3);
-		}
-
-		if(vtolGrAttackObj[4] == NULLOBJECT){
-			setDebugMenuEntry("4 - " & vtolAttackGr[4].members, 4);
-		}else{
-			setDebugMenuEntry("4 " & vtolAttackGr[4].members & " - " & (vtolGrAttackObj[4].x / TILE) & "-" & (vtolGrAttackObj[4].y / TILE), 4);
-		}
-
-		if(vtolGrAttackObj[5] == NULLOBJECT){
-			setDebugMenuEntry("5 - " & vtolAttackGr[5].members, 5);
-		}else{
-			setDebugMenuEntry("5 " & vtolAttackGr[5].members & " - " & (vtolGrAttackObj[5].x / TILE) & "-" & (vtolGrAttackObj[5].y / TILE), 5);
-		}
-
-	/*
-		setDebugMenuEntry("total " & countRebuildStruct, 0);
-		setDebugMenuEntry("x1=" & rebuildStructX[0], 1);
-		setDebugMenuEntry("y1=" & rebuildStructY[0], 2);
-		setDebugMenuEntry("x2=" & rebuildStructX[1], 3);
-		setDebugMenuEntry("y2=" & rebuildStructY[1], 4);
-		setDebugMenuEntry("x3=" & rebuildStructX[2], 5);
-		setDebugMenuEntry("y3=" & rebuildStructY[2], 6);
-		setDebugMenuEntry("x4=" & rebuildStructX[3], 7);
-		setDebugMenuEntry("y4=" & rebuildStructY[3], 8);*/
-	}
-}
-
-//---------------------------------------------------------------
-//Returns how many droids are already on the way to build the
-//same structure on the same spot (like helpbuild)
-//---------------------------------------------------------------
-function int numBuildSameBuilding(STRUCTURESTAT _checkStat, int _x, int _y)
-{
-	local	int		_numSameBuilding;
-	local	DROID	_truck;
-
-	_numSameBuilding = 0;
-
-	initIterateGroup(buildGroup);
-	_truck = iterateGroup(buildGroup);
-	while(_truck != NULLOBJECT)
-	{
-		if((_truck.order == DORDER_BUILD) or (_truck.order == DORDER_HELPBUILD) or (_truck.order == DORDER_LINEBUILD))
-		{
-			if((_checkStat == NULLSTRUCTURESTAT) or (_truck.stat == _checkStat))	//Same struct type
-			{
-				//Within some range
-				if((_x < 0) or (distBetweenTwoPoints(_x, _y, _truck.orderx , _truck.ordery) <= TILE))
-				{
-					_numSameBuilding++;
-				}
-			}
-		}
-		_truck = iterateGroup(buildGroup);
-	}
-
-	return _numSameBuilding;
-}
-
-// returns number of droids in a certain group with the same order
-function int numGroupSameOrder(GROUP _group, int _orderIndex)
-{
-	local		int 		_numDroids;
-	local		DROID		_droid;
-
-	_numDroids = 0;
-
-	initIterateGroup(_group);
-	_droid = iterateGroup(_group);
-	while(_droid != NULLOBJECT)
-	{
-		if(_droid.order == _orderIndex)	//right order type
-		{
-			_numDroids++;
-		}
-		_droid = iterateGroup(_group);
-	}
-
-	return _numDroids;
-}
-
-// Remember certain destroyed structures so we can rebuild them later
-event structureDestroyed(structureDestroyedTr)
-{
-	local	int	_count;
-
-	// add certain structures to the rebuild list
-	_count = 0;
-	while(_count < numRebuildStat[curTech])
-	{
-		if(structure.stat == rebuildStat[curTech][_count])
-		{
-			if(countRebuildStruct < MAX_REBUILD_STRUCT)
-			{
-				rebuildStructX[countRebuildStruct] = structure.x;
-				rebuildStructY[countRebuildStruct] = structure.y;
-				rebuildStructStat[countRebuildStruct] = structure.stat;
-				countRebuildStruct++;
-
-				dbg("remembered structure (" & countRebuildStruct & ") - " & structure.x & "/" & structure.y, me);
-
-				exit;
-			}
-		}
-		_count++;
-	}
-}
-
-// Rebuild structures that were destroyed
-event rebuildStructureEv(rebuildStructureTr)
-{
-	rebuildStructures();
-}
-
-function void rebuildStructures()
-{
-	local	int				_count,_threatRange,_x,_y;
-	local	DROID			_truck;
-	local	STRUCTURESTAT	_stat;
-
-	_threatRange = (TILE * 8);
-
-	_count = 0;
-	while(_count < countRebuildStruct)
-	{
-		if(!threatInRange(me, rebuildStructX[_count], rebuildStructY[_count], _threatRange, FALSE))
-		{
-			if(getTileStructure(_x / TILE, _y  / TILE) == NULLOBJECT)
-			{
-				_stat = rebuildStructStat[_count];
-				_x = rebuildStructX[_count];
-				_y = rebuildStructY[_count];
-
-				if (isStructureAvailable(_stat, me))
-				{
-					_truck = closestIdleTruck(_x, _y);
-
-					if (_truck != NULLOBJECT)
-					{
-						if (numBuildSameBuilding(_stat, _x, _y) == 0)	//make sure no one is building already
-						{
-							buildOnExactLocation(_truck, _x, _y, _stat);
-						}
-					}
-				}
-			}
-		}
-		_count++;
-	}
-}
-
-function void buildOnExactLocation(DROID _truck, int _x, int _y, STRUCTURESTAT _stat)
-{
-	local	int	_newX,_newY;
-
-	if(_truck == NULLOBJECT)
-	{
-		return;
-	}
-
-	_newX = _x;
-	_newY = _y;
-
-	if (pickDroidStructLocation(_truck, _stat, ref _newX, ref _newY, me, -1))
-	{
-		dbg("trying to rebuild on (" & _newX & "/" & _newY & ")", me);
-
-		if ((_x != _newX) or (_y != _newY))
-		{
-			return;
-		}
-
-		orderDroidStatsLoc(_truck, DORDER_BUILD, _stat, _x, _y);
-		//dbg("rebuilding structure after!! (" & _x & "/" & _y & ")", me);
-	}
-}
-
-// Get idle truck closest to some location
-function DROID closestIdleTruck(int _x, int _y)
-{
-	local DROID _closestTruck, _tempTruck;
-	local int _closestDist, _tempDist;
-
-	_closestTruck = NULLOBJECT;
-	_closestDist = 99999;
-
-	initIterateGroup(buildGroup);
-	_tempTruck = iterateGroup(buildGroup);
-	while(_tempTruck != NULLOBJECT)
-	{
-		if((_tempTruck.order == DORDER_NONE) or (_tempTruck.order == DORDER_RTB))
-		{
-			_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y);
-			if(_tempDist < _closestDist)
-			{
-				_closestDist = _tempDist;
-				_closestTruck = _tempTruck;
-			}
-		}
-		_tempTruck = iterateGroup(buildGroup);
-	}
-
-	return _closestTruck;
-}
-
-event consoleEv(consoleTr)
-{
-	//turn on 'autogame'
-	if(message == "autogame on" && (sender == me))
-	{
-		if(debugModeEnabled())
-		{
-			if(myResponsibility(me))
-			{
-				if(not bRunning)		//make sure current machine is responsible for this AI and it's not already active
-				{
-					console(getPlayerName(me) & " is active");
-					reassignAI();
-					setEventTrigger(startLevel, chainloadTr);
-				}
-			}
-		}
-	}
-
-	//turn off 'autogames'
-	if(message == "autogame off" && debugModeEnabled()  && (sender == me))
-	{
-		if(bRunning)		//make sure this AI is active
-		{
-			console(getPlayerName(me) & " is deactivated");
-			
-			shutDownAI();
-		}
-	}
-
-	if(message == "aidebug on")
-	{
-		console(getPlayerName(me) & " ai debug is on");
-		_DEBUG = TRUE;
-		dbgMsgOn(me, _DEBUG);
-	}
-	else if(message == "aidebug off")
-	{
-		console(getPlayerName(me) & " ai debug is off");
-		_DEBUG = FALSE;
-		dbgMsgOn(me, _DEBUG);
-	}
-}
diff --git a/data/mp/multiplay/skirmish/nexus.vlo b/data/mp/multiplay/skirmish/nexus.vlo
deleted file mode 100644
index f96e7c0..0000000
--- a/data/mp/multiplay/skirmish/nexus.vlo
+++ /dev/null
@@ -1,422 +0,0 @@
-/////////////////////////////////////////////////////////////////////
-// ai for skirmish game
-/////////////////////////////////////////////////////////////////////
-
-script "nexus.slo"
-run
-{
-	// research branches
-	branchDefault	int					0
-	branchVTOL		int					1
-
-	//default branch
-	numScouts[0]	int					3			// min number of droids in group to aim for.
-	numDefenders[0]	int					4
-	numAttackers[0]	int					8
-	numCyborgs[0]	int					15			// build cyborgs until scouts contains x droids
-
-	//vtol branch
-	numScouts[1]	int					3			// min number of droids in group to aim for.
-	numDefenders[1]	int					12
-	numAttackers[1]	int					0
-	numCyborgs[1]	int					25			// build cyborgs until scouts contains x droids
-
-	
-	//default branch
-	maxScouts[0]	int					3			// min number of droids in group to aim for.
-	maxDefenders[0]	int					5
-	maxAttackers[0]	int					-1
-	maxCyborgs[0]	int					35			// build cyborgs until scouts contains x droids
-
-	//vtol branch
-	maxScouts[1]	int					3			// min number of droids in group to aim for.
-	maxDefenders[1]	int					20
-	maxAttackers[1]	int					0
-	maxCyborgs[1]	int					50			// build cyborgs until scouts contains x droids
-	
-	tileExpand		int					12			// approx minutes to expand over the map.
-
-	/////////////////////////////////////////////////////////////////////
-	/////////////////////////////////////////////////////////////////////
-	// structures
-
- 	// generic names, often used.
-	oilRes			FEATURESTAT			"OilResource"
-	resLab			STRUCTURESTAT		"A0ResearchFacility"
-	powGen			STRUCTURESTAT		"A0PowerGenerator"
-	factory			STRUCTURESTAT		"A0LightFactory"
-	derrick			STRUCTURESTAT		"A0ResourceExtractor"
-	cybFactory		STRUCTURESTAT		"A0CyborgFactory"
-	playerHQ		STRUCTURESTAT		"A0CommandCentre"
-	vtolPad			STRUCTURESTAT		"A0VtolPad"
-	vtolFactory		STRUCTURESTAT		"A0VTolFactory1"
-	sensorTower		STRUCTURESTAT		"Sys-SensoTower02"
-	lassat			STRUCTURESTAT		"A0LasSatCommand"
-	nexusDefence	RESEARCHSTAT		"R-Sys-Resistance-Circuits"
-	uplink			STRUCTURESTAT		"A0Sat-linkCentre"
-
-	//number of research topics for each research branch
-	techCount[0]	int					6
-	
-	//how many res facilities to use when finished researching all specified research topics
-	maxIdleRes[0]	int					-1
-	
-	tech[0][0]		RESEARCHSTAT		"R-Wpn-MG3Mk1"			//HMG
-	tech[0][1]		RESEARCHSTAT		"R-Vehicle-Prop-Halftracks"	//half-tracks
-	tech[0][2]		RESEARCHSTAT		"R-Wpn-Rocket02-MRL"	//mini rocket artillery
-	tech[0][3]		RESEARCHSTAT		"R-Wpn-Rocket-ROF03"
-	tech[0][4]		RESEARCHSTAT		"R-Wpn-MG-Damage03"
-	tech[0][5]		RESEARCHSTAT		"R-Defense-Pillbox06"		//lancer bunker
-
-	//other tech: R-Vehicle-Prop-VTOL, R-Struc-VTOLPad, R-Struc-VTOLFactory
-	techCount[1]	int					19
-	
-	//how many res facilities to use when finished researching all specified research topics
-	maxIdleRes[1]	int					3
-	
-	tech[1][0]		RESEARCHSTAT		"R-Struc-VTOLFactory"
-	tech[1][1]		RESEARCHSTAT		"R-Struc-VTOLPad"
-	tech[1][2]		RESEARCHSTAT		"R-Wpn-MG3Mk1"				//HMG
-	
-	tech[1][3]		RESEARCHSTAT		"R-Wpn-Rocket02-MRL"	//mini rocket artillery
-	tech[1][4]		RESEARCHSTAT		"R-Wpn-Rocket-ROF03"
-	
-	tech[1][5]		RESEARCHSTAT		"R-Wpn-Flamer-Damage03"		//flamer damage 03
-	tech[1][6]		RESEARCHSTAT		"R-Wpn-Flamer-ROF03"		//flamer ROF 03
-	
-	tech[1][7]		RESEARCHSTAT		"R-Wpn-Rocket01-LtAT"		//Lancer
-	tech[1][8]		RESEARCHSTAT		"R-Vehicle-Body08"			//Scorpion body
-	tech[1][9]		RESEARCHSTAT		"R-Struc-Power-Upgrade03a"	//power upgrade 03a
-	tech[1][10]		RESEARCHSTAT		"R-Wpn-Missile-Accuracy02"	//lancer accuracy
-	tech[1][11]		RESEARCHSTAT		"R-Wpn-Missile-Damage03"	//lancer damage
-	
-	tech[1][12]		RESEARCHSTAT		"R-Wpn-Rocket03-HvAT"		//BB
-	tech[1][13]		RESEARCHSTAT		"R-Struc-VTOLPad-Upgrade06"
-	tech[1][14]		RESEARCHSTAT		"R-Struc-Factory-Upgrade04"
-	tech[1][15]		RESEARCHSTAT		"R-Sys-Autorepair-General"		//autorepair
-	tech[1][16]		RESEARCHSTAT		"R-Sys-Sensor-UpLink"
-	tech[1][17]		RESEARCHSTAT		"R-Sys-VTOLCBS-Turret01"
-	tech[1][18]		RESEARCHSTAT		"R-Sys-VTOLStrike-Tower01"
-
-	maxVtolFacs[0]	int					1
-	maxVtolFacs[1]	int					4
-
-	maxVTOLs[0]		int					5
-	maxVTOLs[1]		int					70
-
-	// incendry emplacements.
-	numIncendrys	int					8
-	incendrys[0]	STRUCTURESTAT		"Emplacement-MortarPit01"
-	incendrys[1]	STRUCTURESTAT		"Emplacement-MortarPit02"
-	incendrys[2]	STRUCTURESTAT		"Emplacement-MortarPit-Incenediary"
-	incendrys[3]	STRUCTURESTAT		"Emplacement-RotMor"
-	incendrys[4]	STRUCTURESTAT		"Emplacement-Howitzer105"
-	incendrys[5]	STRUCTURESTAT		"Emplacement-Howitzer150"
-	incendrys[6]	STRUCTURESTAT		"Emplacement-Howitzer-Incenediary"
-	incendrys[7]	STRUCTURESTAT		"Emplacement-RotHow"
-
-	//anti a.
-	vtolDefStruct[0] STRUCTURESTAT		"AASite-QuadMg1"	//1
-	vtolDefStruct[1] STRUCTURESTAT		"AASite-QuadBof" 	//2
-	vtolDefStruct[2] STRUCTURESTAT		"AASite-QuadRotMg"
-	vtolDefStruct[3] STRUCTURESTAT		"P0-AASite-SAM1" 	//3
-	vtolDefStruct[4] STRUCTURESTAT		"P0-AASite-SAM2"
-
-	// upgrade structures
-	powModule		STRUCTURESTAT		"A0PowMod1"
-	facModule		STRUCTURESTAT		"A0FacMod1"
-	resModule		STRUCTURESTAT		"A0ResearchModule1"
-
- 	// Essential and fundamental structs. Fundamental => what you build on level start
-	numStructs		int					13
-	numFundamental		int					5
-	structs[0]		STRUCTURESTAT		"A0LightFactory"
-	structs[1]		STRUCTURESTAT		"A0ResearchFacility"
-	structs[2]		STRUCTURESTAT		"A0PowerGenerator"
-	structs[3]		STRUCTURESTAT		"A0CommandCentre"
-	structs[4]		STRUCTURESTAT		"A0CyborgFactory"
-
-	structs[5]		STRUCTURESTAT		"Sys-CB-Tower01"
-	structs[6]		STRUCTURESTAT		"Sys-SpyTower"
-
-	structs[7]		STRUCTURESTAT		"A0LasSatCommand"
-	structs[8]		STRUCTURESTAT		"A0Sat-linkCentre"
-	structs[9]		STRUCTURESTAT		"X-Super-Rocket"
-	structs[10]		STRUCTURESTAT		"X-Super-Cannon"
-	structs[11]		STRUCTURESTAT		"X-Super-MassDriver"
-	structs[12]		STRUCTURESTAT		"X-Super-Missile"
-
-	/* Base structures */
-	numBaseStruct	int					8
-	baseStruct[0]	STRUCTURESTAT		"A0PowerGenerator"
-	baseStruct[1]	STRUCTURESTAT		"A0LightFactory"
-	baseStruct[2]	STRUCTURESTAT		"A0CommandCentre"
-	baseStruct[3]	STRUCTURESTAT		"A0ResearchFacility"
-	baseStruct[4]	STRUCTURESTAT		"A0CyborgFactory"
-	baseStruct[5]	STRUCTURESTAT		"A0LasSatCommand"
-	baseStruct[6]	STRUCTURESTAT		"A0Sat-linkCentre"
-	baseStruct[7]	STRUCTURESTAT		"A0VTolFactory1"
-
-	// defensive structs.
-	numDefStructs	int					22
-	defStructs[0]	STRUCTURESTAT		"PillBox1"
-	defStructs[1]	STRUCTURESTAT		"Pillbox-RotMG"
-	defStructs[3]	STRUCTURESTAT		"GuardTower6"
-	defStructs[2]	STRUCTURESTAT		"PillBox4"		//LC
-	defStructs[4]	STRUCTURESTAT		"GuardTower5"		//Lancer
-	defStructs[5]	STRUCTURESTAT		"Sys-SensoTower02"
-	defStructs[6]	STRUCTURESTAT		"WallTower03"		//MC
-	defStructs[7]	STRUCTURESTAT		"WallTower04"		//HC
-	defStructs[8]	STRUCTURESTAT		"GuardTower5"		//Lancer
-
-	defStructs[9]	STRUCTURESTAT		"WallTower04"		//HC
-	defStructs[10]	STRUCTURESTAT		"WallTower-HPVcannon"
-	defStructs[11]	STRUCTURESTAT		"Emplacement-Howitzer105"
-	defStructs[12]	STRUCTURESTAT		"Emplacement-HvyATrocket"
-	defStructs[13]	STRUCTURESTAT		"Emplacement-MortarPit02"
-	defStructs[14]	STRUCTURESTAT		"WallTower06"
-	defStructs[15]	STRUCTURESTAT		"Emplacement-PulseLaser"	// Campaign 3 Defensive Structures
-	defStructs[16]	STRUCTURESTAT		"Emplacement-Rail2"
-
-	defStructs[17]	STRUCTURESTAT		"WallTower-HvATrocket"	//TK
-	defStructs[18]	STRUCTURESTAT		"WallTower-Atmiss"	//Scourge
-	defStructs[19]	STRUCTURESTAT		"WallTower-PulseLas"
-	defStructs[20]	STRUCTURESTAT		"WallTower-Rail2"
-	defStructs[21]	STRUCTURESTAT		"WallTower-Rail3"
-
-	// wall structs (4)
-	numWallWeaps	int					10
-	wall			STRUCTURESTAT		"A0HardcreteMk1Wall"
-	cornerWall		STRUCTURESTAT		"A0HardcreteMk1CWall"
-	wallWeaps[0]	STRUCTURESTAT		"WallTower01"
-	wallWeaps[1]	STRUCTURESTAT		"WallTower02"
-	wallWeaps[2]	STRUCTURESTAT		"WallTower03"
-	wallWeaps[3]	STRUCTURESTAT		"WallTower04"
-	wallWeaps[4]	STRUCTURESTAT		"WallTower06"
-	wallWeaps[5]	STRUCTURESTAT		"WallTower06"
-	wallWeaps[6]	STRUCTURESTAT		"WallTower-Rail2"
-	wallWeaps[7]	STRUCTURESTAT		"WallTower-PulseLas"
-	wallWeaps[8]	STRUCTURESTAT		"WallTower-Atmiss"
-	wallWeaps[9]	STRUCTURESTAT		"WallTower-HPVcannon"
-
-
-	// extra structs
-	numExtraStructs[0]	int					4
-	extraStructs[0][0]	STRUCTURESTAT		"A0LightFactory"
-	extraStructs[0][1]	STRUCTURESTAT		"A0LightFactory"
-	extraStructs[0][2]	STRUCTURESTAT		"A0ResearchFacility"
-	extraStructs[0][3]	STRUCTURESTAT		"A0CyborgFactory"
-	
-	numExtraStructs[1]	int					5
-	extraStructs[1][0]	STRUCTURESTAT		"A0VTolFactory1"
-	extraStructs[1][1]	STRUCTURESTAT		"A0VTolFactory1"
-	extraStructs[1][2]	STRUCTURESTAT		"A0CyborgFactory"
-	extraStructs[1][3]	STRUCTURESTAT		"A0VtolPad"
-	extraStructs[1][4]	STRUCTURESTAT		"A0LightFactory"
-
-	/////////////////////////////////////////////////////////////////////
-	/////////////////////////////////////////////////////////////////////
-	// SKIRMISH TEMPLATES
-
-	// COMBAT TEMPLATES
-
-	//branchDefault
-	numTemplates[0]	int			48
-
-	tmpl[0][0]	TEMPLATE	"ViperMG01Wheels"		//MG
-	tmpl[0][1]	TEMPLATE	"ViperMG02Wheels"		//TMG
-	tmpl[0][2]	TEMPLATE	"ViperHMGWheels"		//HMG
-	tmpl[0][3]	TEMPLATE	"ViperPODWheels"		//POD
-	tmpl[0][4]	TEMPLATE	"ViperLtA-Twheels"		//Lancer
-	tmpl[0][5]	TEMPLATE	"ViperFlameWheels"		//Flamer
-	tmpl[0][6]	TEMPLATE	"ViperLtA-Twheels"		//Lancer
-	tmpl[0][7]	TEMPLATE	"CobraMRLHalftrack"		//MRL
-	tmpl[0][8]	TEMPLATE	"ViperLtCannonWheels"	//LC
-	tmpl[0][9]	TEMPLATE	"ViperPODWheels"		//POD
-	tmpl[0][10]	TEMPLATE	"ViperLtCannonHTracks"	//LC
-
-	tmpl[0][11]	TEMPLATE	"CobraLtA-Thalftrack"	//Lancer	HT
-	tmpl[0][12]	TEMPLATE	"CobraMRLHalftrack"		//MRL 	HT
-	tmpl[0][13]	TEMPLATE	"CobraInfernoHTracks"	//Inferno	HT
-	tmpl[0][14]	TEMPLATE	"SK-Cobra-Hover-Lancer"	//Lancer	H
-	tmpl[0][15]	TEMPLATE	"Sk-CobraBBHover"		//BB		H
-	tmpl[0][16]	TEMPLATE	"CobraMedCnTrks"		//MC		Tr
-	tmpl[0][17]	TEMPLATE	"SK-Cobra-Track-HVC"	//HVC	Tr
-	tmpl[0][18]	TEMPLATE	"CobraHvyCnTrks"		//HC		Tr
-
-	//tmpl[0][19]	TEMPLATE	"SK-Python-Hover-Mcannon"
-	//tmpl[0][20]	TEMPLATE	"PythonMedCnTrks"
-	//tmpl[0][21]	TEMPLATE	"SK-Python-Hover-Lancer"
-	//tmpl[0][22]	TEMPLATE	"SK-Python-Hover-Hcannon"
-
-	//Campaign 2
-	tmpl[0][19]	TEMPLATE	"PythonHoverHVC"		//HVC Hover
-	tmpl[0][20]	TEMPLATE	"SK-Cobra-Track-TK"
-	tmpl[0][21]	TEMPLATE	"Sk-PythonHvCanTrack"
-	tmpl[0][22]	TEMPLATE	"Sk-PythonHvCanTrack"
-
-	tmpl[0][23]	TEMPLATE	"SK-Panther-Hover-HVC"
-	tmpl[0][24]	TEMPLATE	"SK-Panther-Hover-TK"
-
-	tmpl[0][25]	TEMPLATE	"SK-Tiger-Track-Hcannon"
-	tmpl[0][26]	TEMPLATE	"SK-Tiger-Track-HVC"
-	tmpl[0][27]	TEMPLATE	"SK-Tiger-Track-Hcannon"
-	tmpl[0][28]	TEMPLATE	"SK-Tiger-Hover-TK"
-
-	//Campaign 3
-	tmpl[0][29]	TEMPLATE	"SK-Leopard-Htrk-Needle"
-	tmpl[0][30]	TEMPLATE	"SK-Tiger-Track-Hcannon"
-	tmpl[0][31]	TEMPLATE	"SK-Panther-Track-RailGun"
-	tmpl[0][32]	TEMPLATE	"SK-Panther-Hover-TK"
-	tmpl[0][33]	TEMPLATE	"SK-Tiger-Track-Scourge"
-	tmpl[0][34]	TEMPLATE	"SK-Tiger-Track-Gauss"
-	tmpl[0][35]	TEMPLATE	"SK-Tiger-Hover-Gauss"
-	tmpl[0][36]	TEMPLATE	"SK-Retre-Track-PulseLsr"
-	tmpl[0][37]	TEMPLATE	"SK-Retre-Track-FlashLight"
-
-	tmpl[0][38]	TEMPLATE	"SK-Retre-Track-RailGun"
-	tmpl[0][39]	TEMPLATE	"SK-Veng-Track-Scourge"
-	tmpl[0][40]	TEMPLATE	"SK-Retre-Hover-RailGun"
-	tmpl[0][41]	TEMPLATE	"SK-Retre-Track-Scourge"
-	tmpl[0][42]	TEMPLATE	"SK-Veng-Track-Gauss"
-	tmpl[0][43]	TEMPLATE	"SK-Veng-Hover-Gauss"
-	tmpl[0][44]	TEMPLATE	"SK-Veng-Track-PulseLsr"
-	tmpl[0][45]	TEMPLATE	"SK-Veng-Hover-Scourge"
-
-	tmpl[0][46]	TEMPLATE	"SK-Veng-Hover-Seraph"
-	tmpl[0][47]	TEMPLATE	"Dragon-Hover-SeraphGauss"
-	
-	
-	//branchVTOL
-	numTemplates[1]	int			18
-
-	tmpl[1][0]		TEMPLATE	"ViperMG01Wheels"
-	tmpl[1][1]		TEMPLATE	"ViperMG02Wheels"
-	tmpl[1][2]		TEMPLATE	"ViperHMGWheels"
-	tmpl[1][3]		TEMPLATE	"ViperHMGWheels"
-	tmpl[1][4]		TEMPLATE	"ViperLtA-Twheels"
-	tmpl[1][5]		TEMPLATE	"ViperHMGTracks"
-	tmpl[1][6]		TEMPLATE	"ViperLtA-Twheels"
-	tmpl[1][7]		TEMPLATE	"ViperLtA-Twheels"
-	tmpl[1][8]		TEMPLATE	"ViperHMGTracks"
-	tmpl[1][9]		TEMPLATE	"ViperHMGTracks"
-	tmpl[1][10]		TEMPLATE	"ViperMedCnTrks"
-
-	tmpl[1][11]		TEMPLATE	"SK-Cobra-Hover-HMG"
-	tmpl[1][12]		TEMPLATE	"SK-Cobra-Hover-Lancer"
-	
-	tmpl[1][13]		TEMPLATE	"H-Scorp-Trk-Lancer"
-	tmpl[1][14]		TEMPLATE	"H-Scorp-Trk-HC"
-	tmpl[1][15]		TEMPLATE	"H-Scorp-Trk-Lancer"
-	tmpl[1][16]		TEMPLATE	"H-Scorp-Trk-HC"
-	tmpl[1][17]		TEMPLATE	"H-Scorp-Trk-Lancer"
-	
-	/////////////////////////////////////////////////////////////////////
-	// SENSORS / REPAIR TEMPLATES
-
-	constructor	TEMPLATE	"ConstructorDroid"
-	hovertruck	TEMPLATE	"ScorpHoverTruck"
-	repairUnit	TEMPLATE	"ViperRepairHalftrack"
-
-	numSenseTemplates		int		10
-
-	//Campaign 1
-	sense[0]	TEMPLATE	"ViperRepairWheels"
-	sense[1]	TEMPLATE	"ViperRepairHalftrack"
-	sense[2]	TEMPLATE	"CobraSensorHalftrack"
-	//Campaign 2
-	sense[3]	TEMPLATE	"SK-Bug-Hover-Sensor"
-	sense[4]	TEMPLATE	"SK-Bug-Hover-Repair"
-	sense[5]	TEMPLATE	"SK-Leopard-Hover-Sensor"
-	sense[6]	TEMPLATE	"SK-Leopard-Hover-Repair"
-	sense[7]	TEMPLATE	"SK-Panther-Track-Repair"
-	//Campaign 3
-	sense[8]	TEMPLATE	"SK-Retal-Hover-Sensor"
-	sense[9]	TEMPLATE	"SK-Retal-Hover-Repair"
-
-	/////////////////////////////////////////////////////////////////////
-	// cyborg templates
-	numLightCyborgs	int			6
-	cybTempl[0]		TEMPLATE	"CyborgChain01Ground"
-	cybTempl[1]		TEMPLATE	"CyborgCannon01Grd"		//heavy gunner
-	cybTempl[2]		TEMPLATE	"CyborgFlamer01Grd"
-	cybTempl[3]		TEMPLATE	"CyborgRkt01Ground"
-	cybTempl[4]		TEMPLATE	"MP-Cyb-Needle-GRD"
-	cybTempl[5]		TEMPLATE	"MP-Cyb-Needle-GRD"
-	
-	cybMechanic		TEMPLATE	"Cyb-Mechanic"
-	cybEngineer		TEMPLATE	"Cyb-ComEng"
-
-	superCyb[0]		TEMPLATE	"Cyb-Hvy-Mcannon"
-	superCyb[1]		TEMPLATE	"Cyb-Hvy-HPV"
-	superCyb[2]		TEMPLATE	"Cyb-Hvy-Acannon"
-	superCyb[3]		TEMPLATE	"Cyb-Hvy-TK"
-
-
-	/////////////////////////////////////////////////////////////////////
-	// VTOL TEMPLATES
-
-	numVtolTemplates		int		8
-
-	vtols[0]	TEMPLATE	"P6-L-LTAT-V"		//Viper Lancer
-	vtols[1]	TEMPLATE	"P6-L-Bomb1-V"		//Viper Cluster Bombs Bay
-	vtols[2]	TEMPLATE	"SK-Bug-VTOL-CLBomb"
-	vtols[3]	TEMPLATE	"SK-Scorpion-VTOL-Hbomb"
-	vtols[4]	TEMPLATE	"H-Scorp-VTOL-Lancer"
-	vtols[5]	TEMPLATE	"H-Scorp-VTOL-BB"
-	vtols[6]	TEMPLATE	"H-Scorp-VTOL-Lancer"
-	vtols[7]	TEMPLATE	"SK-Retre-VTOL-Thermite"
-
-	/*
-	vtols[7]	TEMPLATE	"SK-Mantis-VTOL-BB"
-	vtols[8]	TEMPLATE	"SK-Leopard-VTOL-BB"
-	vtols[9]	TEMPLATE	"SK-Leopard-VTOL-PhosBomb"
-	vtols[10]	TEMPLATE	"SK-Panther-VTOL-Thermite"
-	vtols[11]	TEMPLATE	"SK-Panther-VTOL-BB"
-	vtols[12]	TEMPLATE	"SK-Panther-VTOL-Phosbomb"
-	vtols[13]	TEMPLATE	"SK-Panther-VTOL-TK"
-	//Campaign 3
-	vtols[14]	TEMPLATE	"SK-Retal-VTOL-Phosbomb"
-	vtols[16]	TEMPLATE	"SK-Retre-VTOL-PulseLsr"
-	vtols[17]	TEMPLATE	"SK-Retre-VTOL-Scourge"
-	*/
-
-
-	numVtolTargets		int				10
-
-	vtolTarget[0]		STRUCTURESTAT	"A0CommandCentre"
-	vtolTargetWeight[0]	int				10
-	vtolTarget[1]		STRUCTURESTAT	"A0LightFactory"
-	vtolTargetWeight[1]	int				80
-	vtolTarget[2]		STRUCTURESTAT	"A0CyborgFactory"
-	vtolTargetWeight[2]	int				60
-	vtolTarget[3]		STRUCTURESTAT	"A0VTolFactory1"
-	vtolTargetWeight[3]	int				100
-	vtolTarget[4]		STRUCTURESTAT	"A0LasSatCommand"
-	vtolTargetWeight[4]	int				90
-	vtolTarget[5]		STRUCTURESTAT	"A0Sat-linkCentre"
-	vtolTargetWeight[5]	int				10
-	vtolTarget[6]		STRUCTURESTAT	"A0ResearchFacility"
-	vtolTargetWeight[6]	int				10
-	vtolTarget[7]		STRUCTURESTAT	"A0PowerGenerator"
-	vtolTargetWeight[7]	int				15
-	vtolTarget[8]		STRUCTURESTAT	"A0ResourceExtractor"
-	vtolTargetWeight[8]	int				20
-	vtolTarget[9]		STRUCTURESTAT	"A0RepairCentre3"
-	vtolTargetWeight[9]	int				10
-	
-	
-	// Structure types AI will rebuild when they get destroyed (per tech branch basis)
-	
-	// branchDefault
-	numRebuildStat[0]	int				2
-	rebuildStat[0][0]	STRUCTURESTAT	"A0HardcreteMk1Wall"
-	rebuildStat[0][1]	STRUCTURESTAT	"A0HardcreteMk1CWall"
-
-	// branchVTOL
-	numRebuildStat[1]	int				2
-	rebuildStat[1][0]	STRUCTURESTAT	"A0HardcreteMk1Wall"
-	rebuildStat[1][1]	STRUCTURESTAT	"A0HardcreteMk1CWall"
-
-	/////////////////////////////////////////////////////////////////////
-}
diff --git a/data/mp/multiplay/skirmish/semperfi-js.json b/data/mp/multiplay/skirmish/semperfi-js.json
deleted file mode 100644
index 1546c28..0000000
--- a/data/mp/multiplay/skirmish/semperfi-js.json
+++ /dev/null
@@ -1,7 +0,0 @@
-{
-    "AI": {
-        "js": "semperfi.js",
-        "name": "Semperfi JS",
-        "tip": "Testing AI"
-    }
-}
diff --git a/data/mp/multiplay/skirmish/semperfi.js b/data/mp/multiplay/skirmish/semperfi.js
deleted file mode 100644
index b06cd04..0000000
--- a/data/mp/multiplay/skirmish/semperfi.js
+++ /dev/null
@@ -1,746 +0,0 @@
-// -- definitions
-
-const oilRes = "OilResource";
-const resLab = "A0ResearchFacility";
-const powGen = "A0PowerGenerator";
-const factory = "A0LightFactory";
-const derrick = "A0ResourceExtractor";
-const cybFactory = "A0CyborgFactory";
-const playerHQ = "A0CommandCentre";
-const vtolPad = "A0VtolPad";
-const vtolFactory = "A0VTolFactory1";
-const sensorTower = "Sys-SensoTower02";
-const powModule = "A0PowMod1";
-const facModule = "A0FacMod1";
-const resModule = "A0ResearchModule1";
-
-// -- globals
-
-var attackGroup;
-var vtolGroup;
-var attackRun = 0;
-var researchDone = false;
-var fundamentalsTriggered = false; // avoid triggering it multiple times
-
-// --- utility functions
-
-function log(message)
-{
-	dump(gameTime + " : " + message);
-}
-
-function logObj(obj, message)
-{
-	dump(gameTime + " [" + obj.name + " id=" + obj.id + "] > " + message);
-}
-
-function buildAttacker(struct)
-{
-	// For now, only build long range stuff, easier to handle for an AI. Reusing bodies from
-	// the VTOLs -- reconsider this.
-	var bodylist = [
-		"Body14SUP", // dragon
-		"Body7ABT", // retribution
-		"Body6SUPP", // panther
-		"Body8MBT", // scorpion
-		"Body5REC", // cobra
-		"Body1REC", // viper
-	];
-	var proplist = [
-		"HalfTrack", // half-track
-		"wheeled01", // wheels
-	];
-	var weaplist = [
-		"Missile-MdArt", // Seraph
-		"Missile-A-T", // Scourge
-		"Rocket-HvyA-T", // Tank-killer
-		"Rocket-LtA-T", // Lancer
-		"Rocket-MRL", // MRL
-		"Rocket-Pod", // mini-pod
-		"MG3Mk1", // heavy mg
-		"MG2Mk1", // twin mg
-		"MG1Mk1", // mg, initial weapon
-	];
-	if (!buildDroid(struct, "Ranged Attacker", bodylist, proplist, null, null, weaplist, weaplist))
-	{
-		logObj(struct, "Failed to construct new attacker");
-	}
-}
-
-function buildTruck(struct)
-{
-	var bodylist = [
-		"Body7ABT", // retribution
-		"Body6SUPP", // panther
-		"Body8MBT", // scorpion
-		"Body5REC", // cobra
-		"Body1REC", // viper
-	];
-	var proplist = [
-		"hover01", // hover
-		"wheeled01", // wheels
-	];
-	if (!buildDroid(struct, "Constructor", bodylist, proplist, null, null, "Spade1Mk1"))
-	{
-		log("Failed to construct new truck");
-	}
-}
-
-function buildCyborg(struct)
-{
-	// Cyborg templates are special -- their bodies, legs and weapons are linked. We should fix this one day...
-	if (!buildDroid(struct, "Cyborg Thermite", "CyborgLightBody", "CyborgLegs", null, null, "Cyb-Wpn-Thermite"))
-	{
-		if (!buildDroid(struct, "Cyborg Flamer", "CyborgLightBody", "CyborgLegs", null, null, "CyborgFlamer01"))
-		{
-			if (!buildDroid(struct, "Cyborg MG", "CyborgLightBody", "CyborgLegs", null, null, "CyborgChaingun"))
-			{
-				log("Failed to construct new cyborg");
-			}
-		}
-	}
-}
-
-function buildVTOL(struct)
-{
-	var bomblist = [
-		"Bomb3-VTOL-LtINC",	// phosphor bomb
-		"Bomb4-VTOL-HvyINC",	// thermite bomb
-		"Bomb5-VTOL-Plasmite",	// plasmite bomb
-	];
-	var bodylist = [
-		    "Body7ABT", // retribution
-		    "Body8MBT", // scorpion
-		    "Body5REC", // cobra
-		    "Body4ABT", // bug
-		    "Body1REC", // viper
-	];
-	if (!buildDroid(struct, "Bomber", bodylist, "V-Tol", null, null, bomblist))
-	{
-		log("Failed to construct new VTOL");
-	}
-}
-
-// If positive, there are oil derricks that unused due to lack of power generators.
-// If negative, we have too many power generator (usually not a problem in itself).
-function numUnusedDerricks()
-{
-	return countStruct(derrick) - countStruct(powGen) * 4;
-}
-
-function conCanHelp(mydroid, bx, by)
-{
-	return (mydroid.order != DORDER_HELPBUILD 
-	        && mydroid.order != DORDER_BUILD
-	        && mydroid.order != DORDER_LINEBUILD
-	        && droidCanReach(mydroid, bx, by));
-}
-
-function grabTrucksAndBuild(range, bstats, maxBlockingTiles)
-{
-	var closestDroid, bx, by, mydroid, i;
-	var builders = enumDroid(me, DROID_CONSTRUCT);
-	var closestDist = 99999;
-	var droidlist = [];
-	var found = false;
-
-	// Find truck closest to our base
-	for (i = 0; i < builders.length; i++)
-	{
-		mydroid = builders[i];
-		var currDist = distBetweenTwoPoints(startPositions[me].x, startPositions[me].y, mydroid.x, mydroid.y);
-		if (conCanHelp(mydroid, startPositions[me].x, startPositions[me].y))
-		{
-			if (currDist < range)
-			{
-				logObj(mydroid, "added to build list");
-				droidlist.push(mydroid);
-			}
-			else if (currDist < closestDist)
-			{
-				logObj(mydroid, "is closest to build");
-				closestDroid = mydroid;	// record this droid as being closest so far
-				closestDist = currDist;
-			}
-		}
-		else logObj(mydroid, "cannot help, sorry; order is " + mydroid.order + " and can reach? " + conCanHelp(mydroid, startPositions[me].x, startPositions[me].y));
-	}
-	if (droidlist.length == 0 && closestDroid) droidlist.push(closestDroid);
-	for (i = 0; i < droidlist.length; i++)
-	{
-		mydroid = droidlist[i];
-		var result = pickStructLocation(mydroid, bstats, startPositions[me].x, startPositions[me].y, maxBlockingTiles);
-		if (result)
-		{
-			logObj(mydroid, "Construction work");
-			orderDroidBuild(mydroid, DORDER_BUILD, bstats, result.x, result.y);
-			found = true;
-		}
-		else
-		{
-			logObj(mydroid, "Pick struct location failed");
-			log("Pick struct location failed for droid " + mydroid.id);
-		}
-	}
-	return found;
-}
-
-// --- custom triggers
-
-function buildPowerGenerators()
-{
-	if (isStructureAvailable(powGen))
-	{
-		if (!grabTrucksAndBuild(20, powGen, 1))
-		{
-			log("Needed power generator but could not build one");
-		}
-	}
-}
-
-function checkLocalJobs(truck, structlist)
-{
-	if (!structlist)
-	{
-		structlist = enumStruct(me);
-	}
-	// Find closest unfinished structure
-	var bestStruct;
-	var bestDist = 99999;
-	for (var i = 0; i < structlist.length; i++)
-	{
-		var struct = structlist[i];
-		if (struct.status != BUILT && conCanHelp(truck, struct.x, struct.y))
-		{
-			var dist = distBetweenTwoPoints(truck.x, truck.y, struct.x, struct.y);
-			if (dist < 50 && (dist < bestDist || struct.stattype == POWER_GEN))
-			{
-				bestDist = dist;
-				bestStruct = struct;
-			}
-		}
-	}
-	if (bestStruct)
-	{
-		orderDroidObj(truck, DORDER_HELPBUILD, bestStruct);
-		logObj(truck, "Go help construction");
-		return true;
-	}
-	return false;
-}
-
-function sortByDistToBase(obj1, obj2)
-{
-	var dist1 = distBetweenTwoPoints(startPositions[me].x, startPositions[me].y, obj1.x, obj1.y);
-	var dist2 = distBetweenTwoPoints(startPositions[me].x, startPositions[me].y, obj2.x, obj2.y);
-	return (dist1 - dist2);
-}
-
-function lookForOil(droids)
-{
-	var droids = enumDroid(me, DROID_CONSTRUCT);
-	var oils = enumFeature(-1, oilRes);
-	var bestDroid = null;
-	var bestDist = 99999;
-	log("looking for oil... " + oils.length + " available");
-	if (oils.length > 0)
-	{
-		oils.sort(sortByDistToBase); // grab closer oils first
-		for (var i = 0; i < oils.length; i++)
-		{
-			for (var j = 0; j < droids.length; j++)
-			{
-				var dist = distBetweenTwoPoints(droids[j].x, droids[j].y, oils[i].x, oils[i].y);
-				if (droidCanReach(droids[j], oils[i].x, oils[i].y)
-				    && safeDest(me, oils[i].x, oils[i].y)
-				    && droids[j].order != DORDER_BUILD  // but can snatch from HELPBUILD
-				    && droids[j].order != DORDER_LINEBUILD
-				    && bestDist > dist
-				    && !droids[j].busy)
-				{
-					bestDroid = droids[j];
-					bestDist = dist;
-				}
-			}
-			if (bestDroid)
-			{
-				bestDroid.busy = true;
-				orderDroidBuild(bestDroid, DORDER_BUILD, derrick, oils[i].x, oils[i].y);
-				bestDist = 99999;
-				bestDroid = null;
-			}
-		}
-	}
-	return bestDroid;
-}
-
-function buildFundamentals()
-{
-	log("build fundamentals");
-	var needPwGen = false;
-
-	fundamentalsTriggered = false;
-
-	// Do we need power generators?
-	if (playerPower(me) < 1000 && numUnusedDerricks() > 0)
-	{
-		needPwGen = true;
-		log("More power generators needed");
-	}
-	if (!needPwGen && playerPower(me) < 500) // check for more income
-	{
-		if (lookForOil())
-		{
-			log("Now looking for oil");
-			return; // do not build anything else
-		}
-		log("No oil found");
-	}
-	// Help build unfinished buildings
-	var structlist = enumStruct(me);
-	var droids = enumDroid(me, DROID_CONSTRUCT);
-	for (var j = 0; j < droids.length; j++)
-	{
-		if (droids[j].order != DORDER_BUILD)
-		{
-			checkLocalJobs(droids[j], structlist);
-		}
-	}
-	// If we need power generators, try to queue up production of them with any idle trucks
-	if (needPwGen && isStructureAvailable(powGen) && grabTrucksAndBuild(20, powGen, 1))
-	{
-		return; // exit early
-	}
-	queue("buildFundamentals2"); // go on to the next level
-}
-
-function buildFundamentals2()
-{
-	log("build fundamentals2");
-	var factcount = countStruct(factory);
-	// Build as many research labs as factories
-	if (!researchDone && isStructureAvailable(resLab))
-	{
-		if (countStruct(resLab) < factcount && grabTrucksAndBuild(20, resLab, 1))
-		{
-			return;	// done here
-		}
-	}
-	// Build as many factories as we can afford
-	if (playerPower(me) > factcount * 750 && isStructureAvailable(factory) && grabTrucksAndBuild(20, factory, 1))
-	{
-		return; // done here
-	}
-	// Build power generator if missing
-	if (isStructureAvailable(powGen) && countStruct(powGen) == 0 && grabTrucksAndBuild(20, powGen, 1))
-	{
-		return;
-	}
-	// Build HQ if missing
-	if (isStructureAvailable(playerHQ) && countStruct(playerHQ) == 0 && grabTrucksAndBuild(20, playerHQ, 1))
-	{
-		return;
-	}
-	// Build cyborg factory if we don't have one
-	if (isStructureAvailable(cybFactory))
-	{
-		if (countStruct(cybFactory) == 0 && playerPower(me) > 500 && grabTrucksAndBuild(20, cybFactory, 1))
-		{
-			return;
-		}
-	}
-	// Build VTOL factory if we don't have one
-	if (isStructureAvailable(vtolFactory))
-	{
-		if (countStruct(vtolFactory) == 0 && playerPower(me) > 750 && grabTrucksAndBuild(20, vtolFactory, 1))
-		{
-			return;
-		}
-	}
-	log("All fundamental buildings built -- proceed to military stuff");
-	// FIXME ... but instead look for oil
-	lookForOil();
-	// queue("buildDefenses");
-}
-
-function maintenance()
-{
-	log("Maintenance check");
-
-	var struct = null, module = "";
-	if (isStructureAvailable(powModule))
-	{
-		var structlist = enumStruct(me, POWER_GEN);
-		for (i = 0; i < structlist.length; i++)
-		{
-			if (structlist[i].modules < 1) 
-			{
-				struct = structlist[i];
-				module = powModule;
-				break;
-			}
-		}
-	}
-	if (!struct && isStructureAvailable(facModule))
-	{
-		var structlist = enumStruct(me, FACTORY);
-		for (i = 0; i < structlist.length; i++)
-		{
-			if (structlist[i].modules < 2) 
-			{
-				struct = structlist[i];
-				module = facModule;
-				break;
-			}
-		}
-	}
-	if (!struct && isStructureAvailable(facModule))
-	{
-		var structlist = enumStruct(me, VTOL_FACTORY);
-		for (i = 0; i < structlist.length; i++)
-		{
-			if (structlist[i].modules < 2) 
-			{
-				struct = structlist[i];
-				module = facModule;
-				break;
-			}
-		}
-	}
-	if (isStructureAvailable(resModule))
-	{
-		var structlist = enumStruct(me, RESEARCH_LAB);
-		for (i = 0; i < structlist.length; i++)
-		{
-			if (structlist[i].modules < 1) 
-			{
-				struct = structlist[i];
-				module = resModule;
-				break;
-			}
-		}
-	}
-	if (struct) 
-	{
-		log("Found a structure to upgrade");
-		var builders = enumDroid(me, DROID_CONSTRUCT);
-		for (j = 0; j < builders.length; j++)
-		{
-			mydroid = builders[j];
-			var currDist = distBetweenTwoPoints(struct.x, struct.y, mydroid.x, mydroid.y);
-			if (conCanHelp(mydroid, struct.x, struct.y) && currDist < 20)
-			{
-				orderDroidBuild(mydroid, DORDER_BUILD, module, struct.x, struct.y);
-			}
-		}
-		return;
-	}
-	
-	var reslist = enumResearch();
-	if (reslist.length == 0)
-	{
-		log("Done researching - salvage unusable buildings");
-
-		// No research left, salvage res lab
-		researchDone = true; // and do not rebuild them
-		var lablist = enumStruct(me, resLab);
-		var builders = enumDroid(me, DROID_CONSTRUCT);
-		for (i = 0; i < lablist.length; i++)
-		{
-			var lab = lablist[i];
-			// TODO - find closest truck!
-			for (var j = 0; j < builders.length; j++)
-			{
-				var droid = builders[j];
-				if (droid.order != DORDER_DEMOLISH && droid.order != DORDER_BUILD
-				    && droid.order != DORDER_LINEBUILD && !droid.busy)
-				{
-					logObj(droid, "Ordered to salvage research lab");
-					orderDroidObj(droid, DORDER_DEMOLISH, lab);
-					droid.busy = true;
-					break;
-				}
-			}
-		}
-	}
-	// Check for idle trucks
-	if (!fundamentalsTriggered)
-	{
-		queue("buildFundamentals");
-		fundamentalsTriggered = true;
-	}
-	// Check for idle structures (eg factories, labs...)
-	var faclist = enumStruct(me);
-	for (var j = 0; j < faclist.length; j++)
-	{
-		if (structureIdle(faclist[j]))
-		{
-			eventStructureBuilt(faclist[j], null);
-		}
-	}
-}
-
-// --- game events
-
-function eventResearched(tech, labparam)
-{
-	if (playerPower(me) < 100)
-	{
-		return; // wait
-	}
-	var techlist = [
-		"R-Defense-Tower01",	// mg tower
-		"R-Vehicle-Prop-Halftracks",	// halftracks
-		"R-Defense-Tower06", // pod tower
-		"R-Vehicle-Body09", // tiger body (implies python and factory module)
-		"R-Struc-Power-Upgrade03a", // final power upgrade
-		"R-Cyborg-Armor-Heat07", // some cyborg armor
-		"R-Vehicle-Body14", // dragon body (implies vengeance)
-	];
-	var anyfound = true; // assume success
-	var lablist;
-	if (labparam) // check if called with parameter or not
-	{
-		lablist = [];
-		lablist[0] = labparam;
-	}
-	else
-	{
-		lablist = enumStruct(me, resLab);
-	}
-	for (i = 0; i < lablist.length; i++)
-	{
-		var lab = lablist[i];
-		if (lab.status == BUILT && structureIdle(lab))
-		{
-			var found = pursueResearch(lab, techlist);
-			if (!found)
-			{
-				// Look for missile tech (and test string parameter)
-				found = pursueResearch(lab, "R-Wpn-MdArtMissile");
-				if (!found)
-				{
-					// Find a random research item
-					var reslist = enumResearch();
-					if (reslist.length > 0)
-					{
-						var idx = Math.floor(Math.random() * reslist.length);
-						pursueResearch(lab, reslist[idx].name);
-					}
-				}
-			}
-		}
-	}
-}
-
-function eventStructureBuilt(struct, droid)
-{
-	if (struct.stattype == RESEARCH_LAB)
-	{
-		// HACK -- we cannot call eventResearched directly from eventStartLevel for some
-		// reason, since then research messages are dropped on the floor... FIXME
-		queue("eventResearched");
-	}
-	else if (struct.stattype == FACTORY || struct.stattype == CYBORG_FACTORY || struct.stattype == VTOL_FACTORY)
-	{
-		eventDroidBuilt(null, struct);
-	}
-	if (!fundamentalsTriggered)
-	{
-		queue("buildFundamentals"); // see if we should build something else
-		fundamentalsTriggered = true;
-	}
-}
-
-function eventDroidBuilt(droid, struct)
-{
-	var sensorlist = enumBlips(me);
-
-	if (struct && structureIdle(struct))
-	{
-		if (struct.stattype == FACTORY && playerPower(me) > 100)
-		{
-			if (countDroid(DROID_CONSTRUCT) < 5)
-			{
-				buildTruck(struct);
-			}
-			else
-			{
-				buildAttacker(struct);
-			}
-		}
-		else if (struct.stattype == CYBORG_FACTORY)
-		{
-			buildCyborg(struct);
-		}
-		else if (struct.stattype == VTOL_FACTORY)
-		{
-			buildVTOL(struct);
-		}
-	}
-	if (droid)
-	{
-		if (isVTOL(droid))
-		{
-			groupAdd(vtolGroup, droid);
-		}
-		else if (droid.droidType == DROID_WEAPON || droid.droidType == DROID_CYBORG)
-		{
-			groupAdd(attackGroup, droid);
-
-			// HUUUGE hack here :) -- naive attack code nested up in here, 'cos i'm so lazy
-			// Only attack once every four minutes
-			if (groupSizes[attackGroup] > 20 && gameTime > attackRun + 4 * 60 * 1000)
-			{
-				log("-- Military offensive --");
-
-				var attackers = enumGroup(attackGroup);
-				// Attack! Find a random enemy, since that is more fun.
-				var numEnemies = 0;
-				for (var i = 0; i < maxPlayers; i++)
-				{
-					if (!allianceExistsBetween(me, i))
-					{
-						numEnemies++; // count 'em, then kill 'em :)
-					}
-				}
-				var selectedEnemy = Math.round(Math.random() * (numEnemies - 1));
-				for (var i = 0; i < maxPlayers; i++)
-				{
-					if (!allianceExistsBetween(me, i) && selectedEnemy === 0)
-					{
-						for (var j = 0; j < attackers.length; j++)
-						{
-							orderDroidLoc(attackers[j], DORDER_SCOUT, startPositions[i].x, startPositions[i].y);
-							logObj(attackers[j], "sent to attack");
-						}
-						var vtols = enumGroup(vtolGroup);
-						for (var j = 0; j < vtols.length; j++)
-						{
-							if (vtols[j].armed == 100) // only if fully armed
-							{
-								orderDroidLoc(vtols[j], DORDER_SCOUT, startPositions[i].x, startPositions[i].y);
-								logObj(vtols[j], "sent to attack");
-							}
-						}
-						log("ATTACKING player " + i);
-						attackRun = gameTime;
-						return;
-					}
-					selectedEnemy--; // not this enemy, but maybe next one?
-				}
-			}
-		}
-		else if (droid.droidType == DROID_CONSTRUCT)
-		{
-			if (!checkLocalJobs(droid) && !fundamentalsTriggered)
-			{
-				queue("buildFundamentals");
-				fundamentalsTriggered = true;
-			}
-		}
-	}
-}
-
-function eventDroidIdle(droid)
-{
-	// TBD
-}
-
-function eventStructureReady(struct)
-{
-	// TBD
-	//activateStructure(struct, target);
-}
-
-function eventGameInit()
-{
-	attackGroup = newGroup();
-	vtolGroup = newGroup();
-}
-
-function eventAttacked(victim, attacker)
-{
-	// TBD, for now -- SEND EVERYONE!!!
-	if (attacker && victim && victim.type == STRUCTURE && attacker.player != me)
-	{
-		log("Defend!");
-		var i;
-		var defenders = enumDroid(me, DROID_WEAPON);
-		for (i = 0; i < defenders.length; i++)
-		{
-			orderDroidObj(defenders[i], DORDER_ATTACK, attacker);
-		}
-		var cyborgs = enumDroid(me, DROID_CYBORG);
-		for (i = 0; i < cyborgs.length; i++)
-		{
-			orderDroidObj(cyborgs[i], DORDER_ATTACK, attacker);
-		}
-	}
-}
-
-function eventStartLevel()
-{
-	// Pretend like all buildings were just produced, to initiate productions
-	var structlist = enumStruct(me);
-	for (var i = 0; i < structlist.length; i++)
-	{
-		eventStructureBuilt(structlist[i]);
-	}
-	attackRun = gameTime;
-
-	// Make missing buildings
-	if (!fundamentalsTriggered)
-	{
-		queue("buildFundamentals");
-		fundamentalsTriggered = true;
-	}
-
-	// Maintenance calls - to fix quirks
-	setTimer("maintenance", 1000 * 15); // every 15 seconds, call it to check if anything left to do
-
-	dump("== level started ==");
-}
-
-function eventDroidIdle(droid)
-{
-	if (droid.droidType == DROID_CONSTRUCT)
-	{
-		if (!checkLocalJobs(droid) && !fundamentalsTriggered)
-		{
-			queue("buildFundamentals"); // build something
-			fundamentalsTriggered = true;
-		}
-	}
-}
-
-function eventGroupLoss(droid, group, size)
-{
-	log("lost " + droid.id + " in group " + group + " which is now size " + size);
-}
-
-function eventChat(from, to, message)
-{
-	if (to != me || to == from)
-	{
-		return; // not for me
-	}
-	if (message == "donatetruck" && allianceExistsBetween(from, to))
-	{
-		// donate first truck
-		var droids = enumDroid(me, DROID_CONSTRUCT);
-		for (var i = 0; i < droids.length; i++)
-		{
-			donateObject(droids[i], from);
-			return;
-		}
-	}
-	else if (message == "donatepower" && allianceExistsBetween(from, to))
-	{
-		donatePower(playerPower(me) / 2, from);
-	}
-	else if (message == "crazycolours")
-	{
-		setSunIntensity(0.6, 0.4, 0.3,  1.0, 0.8, 0.7,  1.2, 0.9, 0.8);
-	}
-}
diff --git a/data/mp/multiplay/skirmish/semperfi.json b/data/mp/multiplay/skirmish/semperfi.json
deleted file mode 100644
index 38ce759..0000000
--- a/data/mp/multiplay/skirmish/semperfi.json
+++ /dev/null
@@ -1,8 +0,0 @@
-{
-    "AI": {
-        "name": "Semperfi",
-        "slo": "semperfi.slo",
-        "tip": "Experimental AI",
-        "vlo": "semperfi.vlo"
-    }
-}
diff --git a/data/mp/multiplay/skirmish/semperfi.slo b/data/mp/multiplay/skirmish/semperfi.slo
deleted file mode 100644
index 7488d5b..0000000
--- a/data/mp/multiplay/skirmish/semperfi.slo
+++ /dev/null
@@ -1,4514 +0,0 @@
-/////////////////////////////////////////////////////////////////////
-// general ai for skirmish game
-/////////////////////////////////////////////////////////////////////
-// Warzone2100, Pumpkin Studios,
-// alex lee.98/99.
-//
-/////////////////////////////////////////////////////////////////////
-
-//Tile in world units
-#define	TILE					128
-#define	NONE					(-1)
-
-// These are final rules of the lexical parser
-#define	R_REQUEST_HELP			"help me"
-#define	R_REQUEST_BEACON		"drop a beacon"
-#define	R_REPORT_SAFETY			"i'm ok"
-#define R_REQUEST_ALLY			"ally me"
-
-// These are our own messages - lexical parser should be able to handle them
-#define M_REQUEST_HELP			"help me!!"
-#define M_REQUEST_BEACON		"drop a beacon"
-#define M_AFFIRMATIVE_OK		"ok"
-#define M_AFFIRMATIVE_ROGER		"roger"
-#define M_ANNOYED				"bug off"
-#define M_HELPERS_KILLED		"that was all I had.."
-#define M_HELP_NO_UNITS			"I don't have anything"
-
-#define	MAX_PROBABILITY			100
-
-// Base threat range in world units
-#define	W_BASE_THREAT_RANGE		((17 + (mapWidth + mapHeight) / 2 / 35) * TILE)
-#define ALL_ALLIES				-1
-
-#define	BASE_DEFEND_DURATION	(3 * 60)
-
-// Delay before we repeat our request, in seconds
-#define HELP_REQUEST_INTERVAL	(3 * 60)
-
-//in secs
-#define BEACON_TIMEOUT			30
-
-#define	MAX_DROIDS				150
-
-//don't try to build on oil if there's threat within this range
-#define	OIL_THREAT_RANGE		(9 * TILE)
-
-#define	MAX_TRUCKS				9
-#define	MIN_TRUCKS				5
-
-//Enter power saving mode when lower than this
-#define	LOW_POWER				250
-
-// Start spending spree when above this
-#define HIGH_POWER				1250
-
-//Target type values
-#define	NO_TARGET_VALUE			0
-#define	DROID_TARGET_VALUE		1
-#define	OTHER_TARGET_VALUE		2
-#define	DEFENSE_TARGET_VALUE	3
-#define	RESEARCH_TARGET_VALUE	4
-#define	HQ_TARGET_VALUE			5
-#define	OIL_TARGET_VALUE		6
-#define	FACTORY_TARGET_VALUE	7
-
-#define	UNLIMITED 				(-1)
-
-#define	AA_THREAT_RANGE			(TILE * 12)
-
-#define	MAX_DEFENDERS_RADIUS	(TILE * 40)
-
-#define	MAX_VTOL_DEFEND_RADIUS	(TILE * 25)
-
-// AI will remember max this number of structures
-#define	MAX_REBUILD_STRUCT		100
-
-//Total number of technology branches
-#define	TECHS					2
-
-//How many best templates to choose from when deciding what template to build
-#define	MAX_RANDOM_TEMPLATES	4
-
-private	int				me;			// player for this instance.
-public	int				tileExpand;			// rate of exploration
-
-public	int				numScouts,maxScouts;			// aim for...
-public	int				numDefenders[TECHS],maxDefenders[TECHS];
-public	int				numAttackers[TECHS],maxAttackers[TECHS];
-public	int				numCyborgs,maxCyborgs;
-
-public	BODY				bugBody, viperBody, cobraBody, scorpionBody, leopardBody, pythonBody, retributionBody, tigerBody, vengeanceBody, wyvernBody, dragonBody;
-public	PROPULSION			vtolPropulsion, trackPropulsion, wheelPropulsion, hoverPropulsion, halftrackPropulsion;
-public	WEAPON				atWeapon[5], asWeapon[5], mdWeapon[5];
-public	int				numAtWeapons, numAsWeapons, numMdWeapons;
-
-public	int				branchDefault,branchVTOL,techCount[TECHS],maxVtolFacs[TECHS],maxIdleRes,
-						maxVTOLs[TECHS],numVtolTargets,vtolTargetWeight[10],numRebuildStat;
-public	RESEARCHSTAT	tech[TECHS][30];		//technology for different research branches
-public	STRUCTURESTAT	vtolTarget[10],rebuildStat[4];
-
-// structures
-private int				baseX,baseY,minx,miny,maxx,maxy;
-public	int				numStructs,numIncendrys,numDefStructs,numWallWeaps,numBaseStruct,numLightCyborgs,numFundamental;
-private	STRUCTURESTAT	structChoice[5];
-public	STRUCTURESTAT	incendrys[20],structs[13],defStructs[26],wallWeaps[11];
-public	STRUCTURESTAT	sensorTower,wall,cornerWall,resLab,powGen,playerHQ,lassat,factory,derrick,cybFactory,
-						vtolDefStruct[6],vtolPad,vtolFactory,uplink,baseStruct[8];
-public	STRUCTURESTAT	powModule,facModule,resModule,vtolModule;
-public	int				extraStruct;
-
-// unit templates
-public	int				numTemplates;
-public	TEMPLATE		tmpl[70];
-private	TEMPLATE		tmplChoice[5];
-
-public	TEMPLATE		cybTempl[10],superCyb[4],cybMechanic,cybEngineer,hovertruck;
-
-public	TEMPLATE		sense[11];
-public	int				numSenseTemplates;
-
-public	TEMPLATE		constructor,repairUnit;
-public	int				numRepairUnits;
-
-//defend
-private GROUP			defendGroup;
-private bool			defendbusy;
-private BASEOBJ			defendObj;
-
-public  RESEARCHSTAT		nexusDefence;
-private  RESEARCHSTAT		research;
-
-//build
-private GROUP			buildGroup, rushGroup;
-private int			buildX, buildY;
-public	FEATURESTAT		oilRes;
-
-// scout
-private GROUP			scoutGroup;
-private int				scoutX,scoutY;
-private int				scoutTLX,scoutTLY,scoutW,scoutH;
-
-// attack
-private GROUP			attackGroup;
-private BASEOBJ			attackObj,allOutAttack,vtolGrAttackObj[10];
-
-// vtols
-private GROUP			vtolDefendGr,vtolAttackGr[10];
-
-// generic
-private STRUCTURE		structure,rebuildObj[100];
-private DROID			droid;
-private FEATURE			feature;
-private BASEOBJ			baseobj,baseobj2;
-private int				count,count2,result;
-
-private bool			powerSave,_DEBUG,bRunning;
-// Hopefully this will be at least as large as MAX_PLAYERS... Why can't I just use MAX_PLAYERS as the array size?!
-#define MAX_PLAYERS_HACK 17
-private	int				allianceTime[MAX_PLAYERS_HACK];
-private int				sender,x,y,beaconX[MAX_PLAYERS_HACK],beaconY[MAX_PLAYERS_HACK],tBeacon[MAX_PLAYERS_HACK],
-						tLastHelpRequest,lastHelpPlayer,tHelp,tHelpTimeout,helpX,helpY;
-private string			message;
-
-private	int				defendX,defendY,__defendRadiusUnused,tDefendStart,tDefendTimeout,
-						defendMoveType,curTech,numVtolAttackGroups,numAttackVtols,
-						numDefendVtols,rebuildStructX[MAX_REBUILD_STRUCT],rebuildStructY[MAX_REBUILD_STRUCT],countRebuildStruct;
-private	STRUCTURESTAT	rebuildStructStat[MAX_REBUILD_STRUCT];
-
-private int			order;	// callback global
-private bool			seenAnyAA;
-
-/////////////////////////////////////////////////////////////////////
-// triggers.
-
-#region triggers
-trigger reachedTr				(CALL_DROID_REACH_LOCATION, me, ref droid, ref order);
-trigger fortifyTr					(every,	1000);
-trigger conDroidsTr					(every, 900);	// was 1400
-trigger repairDroidsTr				(every, 2600);
-trigger basedetailsTr				(every, 600	);
-trigger droidBuiltTr				(CALL_NEWDROID,me, ref droid,ref structure);
-trigger	structBuiltTr				(CALL_STRUCTBUILT, me, ref droid, ref structure);
-trigger droidDestroyedTr			(CALL_DROID_DESTROYED,  me, ref droid);
-trigger	structureDestroyedTr		(CALL_STRUCT_DESTROYED, me, ref structure);
-trigger	rebuildStructureTr			(every, 50);
-trigger consolidateEventTr			(every,	3100);
-trigger factoryEventTr				(every, 170	);
-trigger cyborgFactoryEventTr		(every, 170	);
-trigger chooseScoutAreaTr			(every,	200	);
-trigger expandScoutAreaTr			(every,	600	);
-trigger scoutMainTr					(every,	150	);
-trigger newObjectReportTr			(CALL_OBJ_SEEN, me, ref baseobj, ref baseobj2);
-trigger attackStuffTr				(every, 300	);
-trigger allOutAttackTr				(every, 4000);
-trigger defendWatchTr				(CALL_STRUCT_ATTACKED, me, ref structure, ref baseobj);
-trigger defendReturnTr				(every,	500	);
-trigger doResearchTr				(CALL_RESEARCHCOMPLETED, ref research, ref structure, me);
-trigger vtolDefendTr				(CALL_STRUCT_ATTACKED, me, ref structure, ref baseobj);
-trigger vtolStructsTr				(every, 290);
-trigger buildVtolsTr				(every, 360);
-trigger vtolAttackTr				(every, 150);
-trigger vtolEnablerTr				(every, 700);
-trigger takeoverTr					(CALL_UNITTAKEOVER, ref droid);
-trigger useLassatTr					(every, 3000);
-trigger reassignTr					(CALL_PLAYERLEFT,ref count);
-trigger formAllianceEventTr			(every,170);
-trigger breakAllianceEventTr		(every,3000);
-trigger humanAllianceTr				(CALL_ALLIANCEOFFER,ref count, ref count2);
-trigger multiMsgTr					(CALL_AI_MSG, me, ref sender, ref message);
-trigger	beaconTr					(CALL_BEACON, me, ref sender, ref x, ref y, ref message);
-trigger consoleTr					(CALL_CONSOLE, ref sender, ref message);
-trigger watchBaseThreatTr			(every, 120);
-trigger manageAllyHelpTr			(every, 80);
-trigger everySec					(every, 10);
-trigger manageDefendLocationTr		(every, 70);
-trigger startLevelTr				(CALL_START_NEXT_LEVEL);
-trigger chainloadTr				(wait, 1);
-trigger slowloadTr				(wait, 13);
-trigger checkActivitiesTr			(every, 400);
-trigger selectedDroidTr				(CALL_DROID_SELECTED, ref droid);
-trigger hostileAATr				(every, 600);	// check for AA each minute
-trigger vtolRetargetTr				(CALL_VTOL_RETARGET, me, ref droid);
-
-/* Events */
-event	checkForHostileAA;
-event	manicWalls;
-event	buildFundamentals;
-event	newfortify;
-event	buildOilDefenseOrRetreat;
-event	buildPowerGenerators;
-event	conDroids;
-event	multiMsgEv;
-event	beaconEv;
-event	watchBaseThreat;
-event	manageAllyHelp;
-event	everySecEv;
-event	manageDefendLocationEv;
-event	structureDestroyed;
-event	rebuildStructureEv;
-event	doResearch;
-event	buildDerrick;
-event	buildExpand;
-
-/* Function prototypes */
-function int numUnusedDerricks();
-function bool haveBeacon(int _player);
-function bool beaconTimeout(int _player);
-function void processCommand(string _message, int _sender, bool _bBlipMessage);
-function bool haveHelpers();
-function bool attemptToHelp(int _playerToHelp, int _x, int _y);
-function void helpPlayer(int _playerToHelp, int _helpX, int _helpY);
-function bool canStopHelpingAlly();
-function void stopHelpingAlly();
-function bool helpingAlly();
-function bool helpAllyTimeout();
-function void requestHelp(int _helpX, int _helpY);
-function void doRequestHelp(int _helpX, int _helpY);
-function bool allyBaseAtLoc(int _ally, int _x, int _y);
-function void messagePlayer(int _playerToMessage, string _message, int _probability);
-function void messagePlayerAddressed(int _playerToMessage, int _playersToAddress, string _message);
-function bool canSeeAllies();
-function bool baseInTrouble();
-function string m_affirmative();
-function void defendLocation(int _defendX, int _defendY, int _tDefendTimeout, bool _bMove);
-function void stopDefendingLocation();
-function bool defendingLocation();
-function bool defendLocationTimeout();
-function bool friendlyPlayer(int _playerToCheck);
-function void factoryBuildDroid(STRUCTURE _factory);
-function void cybFactorBuildCyborg(STRUCTURE _factory);
-function void vtolFactoryBuildVtol(STRUCTURE _factory);
-function bool insideBase(int _x, int _y);
-function int numAlliesInBase(bool _bVtols);
-function int numEnemiesInBase(bool _bVtols);
-function bool defendingOwnBase();
-function int targetTypeValue(BASEOBJ _target);
-function int numBitsSet(int _integer);
-function int findResearch(int _searchStart, int _techTree);
-function void buildRearmPads();
-function int numEnemyAAInRange(int _x, int _y, int _range);
-function BASEOBJ chooseVtolTarget(bool bExclusiveTarget);
-function int getVtolTargetWeight(BASEOBJ _target);
-function bool vtolTargetAssigned(BASEOBJ _target);
-function int numBuildSameBuilding(STRUCTURESTAT _checkStat, int _x, int _y);
-function int totalVtols();
-function bool needTank();
-function void setTechBranch(int _tech);
-function DROID closestIdleTruck(int _x, int _y);
-function void buildOnExactLocation(DROID _truck, int _x, int _y, STRUCTURESTAT _stat);
-function void rebuildStructures();
-function BASEOBJ chooseVtolDefenceTarget(int _x, int _y, int _range, bool bExclusiveTarget);
-function int numGroupSameOrder(GROUP _group, int _orderIndex);
-function void rearrangeAttackVtols();
-function int numStructBusyByType(STRUCTURESTAT _busyStructType);
-function bool aiResponsibleForPlayer(int _player);
-function void reassignAI();
-function void shutDownAI();
-function bool buildUnit(TEMPLATE _tankTemplate, STRUCTURE _factory, STRUCTURESTAT _factoryType, bool _bIdleOnly);
-function STRUCTURE findIdleStructure(STRUCTURESTAT _structType, bool _bIdleOnly);
-#endregion triggers
-
-/////////////////////////////////////////////////////////////////////
-// HouseKeeping
-event initialisedEvent(CALL_GAMEINIT)
-{
-	local int player;
-	// initialise
-	me = getPlayer("Semperfi");
-	_DEBUG = FALSE;
-	dbgMsgOn(me, _DEBUG);
-
-	extraStruct = 0;
-	numRepairUnits = 0;
-	allOutAttack = NULLOBJECT;
-
-	tLastHelpRequest = -1;	//when we requested help for the last time
-	lastHelpPlayer = -1;		//we are not currently helping anyone
-	tHelp = -1;					//when we started helping last time
-	tHelpTimeout = -1;			//time when help times out
-	helpX = -1;
-	helpY = -1;
-	defendX = -1;
-	defendY = -1;
-	tDefendStart = -1;
-	tDefendTimeout = -1;
-	defendMoveType = -1;		//move or scout
-	seenAnyAA = false;
-
-	// set current research branch
-	setTechBranch(-1);
-
-	numVtolAttackGroups = 10;
-	numAttackVtols = 10;	//num vtols in an attack group
-	numDefendVtols = 5;	//num vtols in an attack group
-
-	// setup build group - all initial droids are in buildgroup!
-	groupAddArea(buildGroup, me, 0, 0, (mapWidth*128), (mapHeight*128));
-
-	// note where our base is.
-	getPlayerStartPosition(me, ref baseX, ref baseY);
-
-	// defence.
-	defendbusy = FALSE;
-
-	// setup scouts
-	structure = getStructure(factory, me);
-	if(structure != NULLOBJECT)
-	{
-		scoutTLX		= structure.x;
-		scoutTLY		= structure.y;
-	}
-	else
-	{
-		scoutTLX		= baseX;
-		scoutTLY		= baseY;
-	}
-	scoutW			= 256;
-	scoutH			= 256;
-	scoutX			= scoutTLX;
-	scoutY			= scoutTLY;
-
-	// clear the alliance array...
-	player = 0;
-	while (player != MAX_PLAYERS)
-	{
-		allianceTime[player] = 0;
-		player = player + 1;
-	}
-
-	if(aiResponsibleForPlayer(me))
-	{
-		bRunning = true;
-	}
-	else
-	{
-		bRunning = false;
-		shutDownAI();
-	}
-}
-
-// check whether we have at least one structure of that type
-function bool haveStructure(STRUCTURESTAT type) 
-{
-	return getStructure(type, me) != NULLOBJECT;
-}
-
-// check if we are getting any income
-function bool havePowerSource()
-{
-	// we don't check buildings being finished here
-	return haveStructure(powGen) and haveStructure(derrick);
-}
-
-function void dbgPlr(string message)
-{
-	if (me == selectedPlayer)
-	{
-		console(message);
-	}
-}
-
-function void dbgObj(DROID obj, string message)
-{
-	if (obj.selected)
-	{
-		console(message);
-	}
-}
-
-event retargetVtol(vtolRetargetTr)
-{
-	local	BASEOBJ _obj;
-
-	if (droid != NULLOBJECT)
-	{
-		_obj = getClosestEnemy(droid.x, droid.y, MAX_VTOL_DEFEND_RADIUS, false, false, me);
-		if (_obj != NULLOBJECT)
-		{
-			orderDroidObj(droid, DORDER_ATTACK, _obj);
-		}
-	}
-}
-
-// for debugging
-event selectedDroid(selectedDroidTr)
-{
-	local int groupcount;
-
-	if (!bRunning or me != selectedPlayer)
-	{
-		exit;
-	}
-	if (!hasGroup(droid))
-	{
-		console("Not in any group");
-	}
-	if (groupMember(buildGroup, droid))
-	{
-		console("In build group");
-	}
-	if (groupMember(rushGroup, droid))
-	{
-		console("In rush (forward defense construction) group");
-	}
-	if (groupMember(defendGroup, droid))
-	{
-		console("In defend group");
-	}
-	if (groupMember(attackGroup, droid))
-	{
-		console("In attack group");
-	}
-	if (groupMember(scoutGroup, droid))
-	{
-		console("In scout group");
-	}
-	if (groupMember(vtolDefendGr, droid))
-	{
-		console("In VTOL defend group");
-	}
-	groupcount = 0;
-	while (groupcount < 10)
-	{
-		if (groupMember(vtolAttackGr[groupcount], droid))
-		{
-			console("In VTOL attack group " & groupcount);
-		}
-		groupcount = groupcount + 1;
-	}
-}
-
-function bool conCanHelp(DROID mydroid, int bx, int by)
-{
-	return (mydroid.order != DORDER_HELPBUILD and mydroid.order != DORDER_BUILD and mydroid.order != DORDER_LINEBUILD and droidCanReach(mydroid, bx, by));
-}
-
-// I am not sure why we need this hack, but the AI can still end up not researching anything at times
-// Also add hack in case trucks get idle
-event checkActivities(checkActivitiesTr)
-{
-	setEventTrigger(doResearch, chainloadTr);
-	setEventTrigger(buildFundamentals, slowloadTr);
-}
-
-// Count factories. TODO: Cache this value.
-function int numFactories()
-{
-	initEnumStruct(FALSE, factory, me, me);
-	structure = enumStruct();
-	count = 0;
-	while (structure != NULLOBJECT)
-	{
-		count = count + 1;
-		structure = enumStruct();
-	}
-	return count;
-}
-
-// Count VTOL factories. TODO: Cache this value.
-function int numVtolFactories()
-{
-	initEnumStruct(FALSE, vtolFactory, me, me);
-	structure = enumStruct();
-	count = 0;
-	while (structure != NULLOBJECT)
-	{
-		count = count + 1;
-		structure = enumStruct();
-	}
-	return count;
-}
-
-// Count cyborg factories. TODO: Cache this value.
-function int numCyborgFactories()
-{
-	initEnumStruct(FALSE, cybFactory, me, me);
-	structure = enumStruct();
-	count = 0;
-	while (structure != NULLOBJECT)
-	{
-		count = count + 1;
-		structure = enumStruct();
-	}
-	return count;
-}
-
-// Count research labs. TODO: Cache this value.
-function int numResearchLabs()
-{
-	initEnumStruct(FALSE, resLab, me, me);
-	structure = enumStruct();
-	count = 0;
-	while (structure != NULLOBJECT)
-	{
-		count = count + 1;
-		structure = enumStruct();
-	}
-	return count;
-}
-
-// Build something on specific position, grab trucks to do it within tiles range
-function bool grabTrucksAndBuildAt(int bx, int by, int range, STRUCTURESTAT bstats)
-{
-	local DROID	mydroid, closestDroid;
-	local int	closestDist, currDist, numHelpDroids, tilerange;
-
-	initIterateGroup(buildGroup);				// find idle droids in build group.
-	mydroid = iterateGroup(buildGroup);
-	closestDist = 99999;
-	closestDroid = NULLOBJECT;
-	numHelpDroids = 0;
-	tilerange = range * TILE;
-	while (mydroid != NULLOBJECT)
-	{
-		currDist = distBetweenTwoPoints(bx, by, mydroid.x, mydroid.y);
-		if (conCanHelp(mydroid, bx, by))
-		{
-			if (currDist < tilerange)
-			{
-				orderDroidStatsLoc(mydroid, DORDER_BUILD, bstats, bx, by);	// close, so help build it
-				numHelpDroids = numHelpDroids + 1;
-				dbgObj(mydroid, "Asked to do short distance construction at (" & bx & ", " & by & ")");
-			}
-			else if (currDist < closestDist)
-			{
-				closestDroid = mydroid;	// record this droid as being closest so far
-				closestDist = currDist;
-			}
-		}
-		mydroid = iterateGroup(buildGroup);
-	}
-	if (numHelpDroids == 0 and closestDroid != NULLOBJECT)	// found none within help radius, so force someone to go long distance traveling
-	{
-		dbgObj(closestDroid, "Asked to do long distance construction work at (" & bx & ", " & by & ")");
-		orderDroidStatsLoc(closestDroid, DORDER_BUILD, bstats, bx, by);	// you, book a plane ticket and go!
-		return true;
-	}
-	return (numHelpDroids > 0);
-}
-
-// Build something in main base, grab trucks to do it within tiles range
-function bool grabTrucksAndBuild(int range, STRUCTURESTAT bstats, int maxBlockingTiles)
-{
-	local DROID	mydroid, closestDroid;
-	local int	closestDist, currDist, numHelpDroids, tilerange, bx, by;
-
-	initIterateGroup(buildGroup);				// find idle droids in build group.
-	mydroid = iterateGroup(buildGroup);
-	closestDist = 99999;
-	closestDroid = NULLOBJECT;
-	numHelpDroids = 0;
-	tilerange = range * TILE;
-	while (mydroid != NULLOBJECT)
-	{
-		if (conCanHelp(mydroid, baseX, baseY))
-		{
-			bx = baseX;
-			by = baseY;
-			if (pickDroidStructLocation(mydroid, bstats, ref bx, ref by, me, maxBlockingTiles))
-			{
-				currDist = distBetweenTwoPoints(bx, by, mydroid.x, mydroid.y);
-				if (currDist < tilerange)
-				{
-					orderDroidStatsLoc(mydroid, DORDER_BUILD, bstats, bx, by);	// close, so help build it
-					numHelpDroids = numHelpDroids + 1;
-					dbgObj(mydroid, "Asked to do short distance construction at (" & bx & ", " & by & ")");
-				}
-				else if (currDist < closestDist)
-				{
-					closestDroid = mydroid;	// record this droid as being closest so far
-					closestDist = currDist;
-				}
-			}
-		}
-		mydroid = iterateGroup(buildGroup);
-	}
-	if (numHelpDroids == 0 and closestDroid != NULLOBJECT)	// found none within help radius, so force someone to go long distance traveling
-	{
-		dbgObj(closestDroid, "Asked to do long distance construction work at (" & bx & ", " & by & ")");
-		orderDroidStatsLoc(closestDroid, DORDER_BUILD, bstats, bx, by);	// you, book a plane ticket and go!
-		return true;
-	}
-	return (numHelpDroids > 0);
-}
-
-event arrived(reachedTr)
-{
-	local bool found;
-	local STRUCTURESTAT myChoice;
-
-	if (groupMember(rushGroup, droid))
-	{
-		dbgObj(droid, "Failed to build where we should - (re)start wall building");
-		setEventTrigger(manicWalls, chainloadTr);
-		exit;
-	}
-
-	if (droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT && getDifficulty(me) > EASY)
-	{
-		dbgObj(droid, "Failed to build where we should - attempt to screw up enemy oil derrick");
-
-		// Check if at oil well, and it was taken by enemy
-		structure = structureBuiltInRange(derrick, droid.x, droid.y, (5 * 128), -1);
-		if (structure != NULLOBJECT)
-		{
-			if (not friendlyPlayer(structure.player) and droid.health == 100)
-			{
-				// Ok, at enemy derrick, and nobody has hurt us yet. Start being nasty.
-				count = 0;
-				found = false;
-				// find simplest/cheapest one available to build
-				while (count < numDefStructs and not found)
-				{
-					if (isStructureAvailable(defStructs[count], me))
-					{
-						found = true;
-					}
-					else
-					{
-						count++;
-					}
-				}
-				if (found)
-				{
-					buildX = droid.x;
-					buildY = droid.y;
-					if (pickDroidStructLocation(droid, defStructs[count], ref buildX, ref buildY, me, -1))
-					{
-						dbgObj(droid, "Building defense at enemy oil derrick - just to be nasty");
-						orderDroidStatsLoc(droid, DORDER_BUILD, defStructs[count], buildX, buildY);
-					}
-					else
-					{
-						dbgObj(droid, "Wanted to be nasty, but found nowhere to build defense");
-						orderDroid(droid, DORDER_RTB);		// nothing more to do here.
-					}
-				}
-				else
-				{
-					dbgObj(droid, "Wanted to be nasty, but had nothing nasty to build - returning to base");
-					orderDroid(droid, DORDER_RTB);		// oh, well. nothing more to do here.
-				}
-				exit;
-			}
-			else if (droid.health < 100 and !insideBase(droid.x, droid.y))
-			{
-				dbgObj(droid, "Under fire - bolting back to repair!");
-				orderDroid(droid, DORDER_RTR);		// bolt back to base now!
-				exit;
-			}
-		}
-	}
-}
-
-function bool tryUpgrade()
-{
-	local	STRUCTURE	struct;
-	
-	if (not havePowerSource())
-	{
-		return false;
-	}
-
-	if (isStructureAvailable(powModule, me))
-	{
-		initEnumStruct(FALSE, powGen, me, me);
-		struct = enumStruct();
-		while (struct != NULLOBJECT)
-		{
-			if (not testStructureModule(me, struct, 0))
-			{
-				return grabTrucksAndBuildAt(struct.x, struct.y, 8, powModule);
-			}
-			struct = enumStruct();
-		}
-	}
-	if (isStructureAvailable(facModule, me))
-	{
-		initEnumStruct(FALSE, factory, me, me);
-		struct = enumStruct();
-		while (struct != NULLOBJECT)
-		{
-			if (not testStructureModule(me, struct, 0))
-			{
-				return grabTrucksAndBuildAt(struct.x, struct.y, 10, facModule);
-			}
-			struct = enumStruct();
-		}
-
-		initEnumStruct(FALSE, vtolFactory, me, me);
-		struct = enumStruct();
-		while (struct != NULLOBJECT)
-		{
-			if (not testStructureModule(me, struct, 0))
-			{
-				return grabTrucksAndBuildAt(struct.x, struct.y, 10, facModule);
-			}
-			struct = enumStruct();
-		}
-	}
-	if (isStructureAvailable(resModule, me))
-	{
-		initEnumStruct(FALSE, resLab, me, me);
-		struct = enumStruct();
-		while (struct != NULLOBJECT)
-		{
-			if (not testStructureModule(me, struct, 0))
-			{
-				return grabTrucksAndBuildAt(struct.x, struct.y, 6, resModule);
-			}
-			struct = enumStruct();
-		}
-	}
-	return false;	// did not succeed in getting ANY droids busy!
-}
-
-// Manage trucks and other constructors
-event buildFundamentals(inactive)
-{
-	local FEATURE	_oil;
-	local bool	needPwGen;
-	local STRUCTURE	iterstruct, closeststruct;
-	local int	closest, proximity;
-
-	needPwGen = false;
-	setEventTrigger(buildFundamentals, inactive);
-
-	// Do we need power generators?
-	if ((playerPower(me) < HIGH_POWER * 2 or numFactories() > 1) and numUnusedDerricks() > 0)
-	{
-		needPwGen = true;
-		dbgPlr("More power generators needed");
-	}
-
-	// Do we need to get oil?
-	if (not needPwGen and playerPower(me) < LOW_POWER)
-	{
-		// Any available?
-		initGetFeature(oilRes, -1, me);
-		_oil = getFeatureB(me);
-		if (_oil != NULLOBJECT)
-		{
-			dbgPlr("More oil needed - candidate found");
-			setEventTrigger(buildDerrick, chainloadTr);
-			exit;
-		}
-	}
-
-	// Help build unfinished buildings
-	initIterateGroup(buildGroup);				// find idle droids in build group.
-	droid = iterateGroup(buildGroup);
-	while (droid != NULLOBJECT)
- 	{
-		initEnumUnbuilt(me);
-		iterstruct = enumUnbuilt();
-		closeststruct = NULLOBJECT;
-		closest = 99999;
-		while (iterstruct != NULLOBJECT)
-		{
-			proximity = distBetweenTwoPoints(droid.x, droid.y, iterstruct.x, iterstruct.y);
-			if (conCanHelp(droid, iterstruct.x, iterstruct.y)
-			    and (!needPwGen or iterstruct.stattype == REF_POWER_GEN or iterstruct.stattype == REF_POWER_MODULE)
-			    and (proximity < 50 * TILE)
-			    and (proximity < closest))
-			{
-				closeststruct = iterstruct;
-				closest = proximity;
-			}
-			iterstruct = enumUnbuilt();
-		}
-		if (closeststruct != NULLOBJECT)
- 		{
-			orderDroidObj(droid, DORDER_HELPBUILD, closeststruct);
-			dbgObj(droid, "Aid construction at (" & closeststruct.x & ", " & closeststruct.y & ")");
-			if (closeststruct.stattype == REF_POWER_GEN || closeststruct.stattype == REF_POWER_MODULE)
- 			{
-				needPwGen = false;	// in progress
- 			}
- 		}
-		droid = iterateGroup(buildGroup);
- 	}
-
-	if (idleGroup(buildGroup) == 0)
-	{
-		exit;
-	}
-
-	if (needPwGen)
-	{
-		setEventTrigger(buildPowerGenerators, chainloadTr);
-		exit;
-	}
-
-	// If we have power, build up base basics
-	if (playerPower(me) >= LOW_POWER)
-	{
-		count = 0;
-		while (count < numFundamental)
-		{
-			// check that struct.
-			structure = getStructure(structs[count], me);
-			if (structure == NULLOBJECT)				// if missing build it.
-			{
-				if (isStructureAvailable(structs[count], me))
-				{
-					if (grabTrucksAndBuild(100, structs[count], 0))
-					{
-						exit;
-					}
-				}
-			}
-			count = count + 1;
-		}
-	}
-
-	if (playerPower(me) < LOW_POWER)
-	{
-		exit;	// not much more we can (or should) do - except maybe upgrade?
-	}
-	else if (playerPower(me) < HIGH_POWER or numFactories() > 1)
-	{
-		// Ok, basics are done. Now go offensive! We first check for oil derricks to build on, to deny
-		// them to the enemy. Then that calls for building defenses there. Failing that, we expand our base.
-		// TODO - build at nearby, undefended enemy oil wells
-		setEventTrigger(buildDerrick, chainloadTr);
-		exit;
-	}
-	else	// if lots of power or too few factories to replace high-risk oil hunting trucks
-	{
-		dbgPlr("Too much power - EXPAND!");
-		setEventTrigger(buildExpand, chainloadTr);
-		exit;
-	}
-}
-
-event truckRush(inactive)
-{
-	local int	plr, target, curdist, mindist, checkX, checkY, startX, startY;
-	local FEATURE	_oil, _closestOil;
-	local bool	found;
-
-	setEventTrigger(truckRush, inactive);
-
-	// Find closest enemy
-	plr = 0;
-	target = -1;
-	mindist = 999999;
-	while (plr < MAX_PLAYERS)
-	{
-		if (!friendlyPlayer(plr))
-		{
-			if (getPlayerStartPosition(plr, ref checkX, ref checkY))
-			{
-				curdist = distBetweenTwoPoints(baseX, baseY, checkX, checkY);
-				if (curdist < mindist)
-				{
-					startX = checkX;
-					startY = checkY;
-					mindist = curdist;
-					target = plr;
-				}
-			}
-		}
-		plr = plr + 1;
-	}
-	if (target == -1)
-	{
-		dbgPlr("Failed to find an enemy!");
-		exit;	// oops.
-	}
-	dbgPlr("Rushing player " & target);
-
-	// Reserve droids
-	groupAddGroup(rushGroup, buildGroup);
-
-	// Find oil well closest to closest enemy
-	mindist = 999999;
-	_closestOil = NULLOBJECT;
-	initIterateGroup(rushGroup);
-	droid = iterateGroup(rushGroup);
-	initGetFeature(oilRes, -1, me);
-	_oil = getFeatureB(me);
-	while (droid != NULLOBJECT and _oil != NULLOBJECT)
-	{
-		curdist = distBetweenTwoPoints(startX, startY, _oil.x, _oil.y);
-		// Find the closest oil to target player that we can reach safely, and that he can reach safely as well
-		if (curdist < mindist and droidCanReach(droid, _oil.x, _oil.y) and safeDest(me, _oil.x, _oil.y) && safeDest(target, _oil.x, _oil.y))
-		{
-			mindist = curdist;
-			_closestOil = _oil;
-		}
-		_oil = getFeatureB(me);
-	}
-	if (_closestOil == NULLOBJECT)
-	{
-		dbgPlr("No hostile oil found to rush (or no trucks available)");
-		groupAddGroup(buildGroup, rushGroup); // reverse
-		exit;
-	}
-
-	// Pick best defense
-	mindist = numDefStructs - 1;	// reusing this var to find best def
-	found = false;
-	while (mindist > 0 and not found)
-	{
-		if (isStructureAvailable(defStructs[mindist], me))
-		{
-			found = true;
-		}
-		else
-		{
-			mindist = mindist - 1;
-		}
-	}
-
-	// Pick location for defensive building near for our trucks
-	buildX = _closestOil.x;
-	buildY = _closestOil.y;
-	if (!found || !pickDroidStructLocation(droid, defStructs[mindist], ref buildX, ref buildY, me, -1))
-	{
-		dbgPlr("Failed to find defense, or failed to find placement for it");
-		groupAddGroup(buildGroup, rushGroup); // reverse
-		exit;
-	}
-
-	// Build hostilities
-	while (droid != NULLOBJECT)
-	{
-		orderDroidStatsLoc(droid, DORDER_BUILD, defStructs[mindist], buildX, buildY);
-		droid = iterateGroup(rushGroup);
-	}
-}
-
-// Try to wall in the enemy with wall defenses at random gateways
-event manicWalls(inactive)
-{
-	local int weap, tempx, tempy;
-	local bool found;
-
-	setEventTrigger(manicWalls, inactive);
-
-	// choose best hardpoint type
-	weap = numWallWeaps - 1;
-	found = false;
-	while (weap > 0 and !found)
-	{
-		if (isStructureAvailable(wallWeaps[weap], me))
-		{
-			found = true;
-		}
-		else
-		{
-			weap = weap - 1;
-		}
-	}
-	if (!found)
-	{
-		dbgPlr("Had no wall weapons to build to wall in enemy");
-		groupAddGroup(buildGroup, rushGroup); // reverse
-		exit;
-	}
-
-	// Go build on gateways near enemy base
-	initIterateGroup(rushGroup);
-	droid = iterateGroup(rushGroup);
-	while (droid != NULLOBJECT)
-	{
-		tempx = droid.x;
-		tempy = droid.y;
-		if (!skDefenseLocationB(ref tempx, ref tempy, wall, wallWeaps[weap], droid, me))
-		{
-			dbgPlr("Manic wall building ran into an error - stopped");
-			groupAddGroup(buildGroup, rushGroup); // reverse
-			exit;
-		}
-		droid = iterateGroup(rushGroup);
-	}
-}
-
-event startLevel(startLevelTr)
-{
-	setEventTrigger(conDroids, chainloadTr);
-	setEventTrigger(doResearch, chainloadTr);
-	if (numFactories() > 1 and isStructureAvailable(defStructs[0], me) and getDifficulty(me) > MEDIUM)
-	{
-		dbgPlr("TRUCK RUSH!");
-		setEventTrigger(truckRush, chainloadTr);
-	}
-	else
-	{
-		setEventTrigger(buildFundamentals, slowloadTr);
-	}
-	setEventTrigger(startLevel, inactive);
-}
-
-// decide what technology branch we will use
-function void setTechBranch(int _tech)
-{
-	local float		_y2,_y1,_x2,_x1,_a,_y,_m,_rnd,_mapSize;
-
-	_mapSize = (float)((mapWidth + mapHeight) / 2);
-
-	if(_tech != -1)
-	{
-		curTech = _tech;
-	}
-	else
-	{
-		//probability to choose vtol branch for map size 90 = 0; probability for map size 200 = 45
-		//build a linear function: y = ((y2 - y1) / (x2 - x1)) * x + a depending on two values given (short: y = mx+a)
-		_x1 = 90.0; _y1 = 0.0;
-		_x2 = 200.0; _y2 = 45.0;
-		_m = ((_y2 - _y1) / (_x2 - _x1));
-		_a = -(_m * _x1);
-
-		//calculate probability for the current map
-		_y = _m * _mapSize + _a;
-
-		dbg("_m = " & _m & ", a = " & _a, me);
-
-		_rnd = (float)random(100);
-		if(_rnd  < _y)
-		{
-			curTech = branchVTOL;
-			dbgPlr("going air (" & _y & "/" & _rnd & ")");
-		}
-		else
-		{
-			curTech = branchDefault;
-			dbgPlr("going land (" & _y & "/" & _rnd & ")");
-		}
-	}
-}
-
-/* returns TRUE if AI is responsible for the _player */
-function bool aiResponsibleForPlayer(int _player)
-{
-	if(not _DEBUG and ((_player == selectedPlayer) or not myResponsibility(_player)))
-	{
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-/////////////////////////////////////////////////////////////////////
-// keep details about the size and postion of the ai players base
-event basedetails(basedetailsTr)
-{
-	local int result, baseRange;
-
-	// clear old extremities.
-	maxy = 0;
-	maxx = 0;
-	miny = (mapHeight*128);
-	minx = (mapWidth*128);
-
-	baseRange = 4 * TILE;
-
-	// now find the extremities of our vital structures.
-	count = 0;
-	while(count < numBaseStruct)
-	{
-		initEnumStruct(FALSE,baseStruct[count],me,me);
-		structure= enumStruct();
-		while(structure != NULLOBJECT)
-		{
-			if(structure.x < minx)
-			{
-				minx = structure.x;
-			}
-			if(structure.x > maxx)
-			{
-				maxx = structure.x;
-			}
-			if(structure.y < miny)
-			{
-				miny = structure.y;
-			}
-			if(structure.y > maxy)
-			{
-				maxy = structure.y;
-			}
-
-			result = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
-
-			if(result > baseRange){
-				baseRange = result;
-			}
-
-			structure= enumStruct();
-		}
-
-		count = count + 1;
-	}
-
-	result = 3 * 128;
-	minx = minx - result;
-	maxx = maxx + result;
-	miny = miny - result;
-	maxy = maxy + result;
-
-	baseRange = baseRange + (4 * 128);
-}
-
-// If positive, there are oil derricks that unused due to lack of power generators.
-// If negative, we have too many power generator (usually not a problem in itself).
-function int numUnusedDerricks()
-{
-	initEnumStruct(FALSE, derrick, me, me);					// count = numderricks
-	structure = enumStruct();
-	count = 0;
-	while (structure != NULLOBJECT)
-	{
-		count = count + 1;
-		structure = enumStruct();
-	}
-	initEnumStruct(FALSE, powGen, me, me);					// count2 = numpowgens
-	structure = enumStruct();
-	count2 = 0;
-	while (structure != NULLOBJECT)
-	{
-		count2 = count2 + 1;
-		structure = enumStruct();
-	}
-	return (count - (count2 * 4));
-}
-
-/////////////////////////////////////////////////////////////////////
-// structure building rules
-
-// build derricks on oil.
-event buildDerrick(inactive)
-{
-	local bool	foundOne, _same;
-	local FEATURE	_oil, _closestOil;
-	local int	_bestDist, _newDist;
-	local DROID	_search;
-
-	// what if we can't waste power on building derricks because we don't have a gen yet?
-	if (playerPower(me) < 300 and haveStructure(derrick) and not haveStructure(powGen))
-	{
-		setEventTrigger(buildDerrick, slowloadTr);
-		exit;
-	}
-
-	_bestDist = 99999;
-	_closestOil = NULLOBJECT;
-	foundOne = false;
-	initIterateGroup(buildGroup);				// find all units in build group
-	droid = iterateGroup(buildGroup);
-	while (droid != NULLOBJECT && !foundOne)
-	{
-		if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.order != DORDER_HELPBUILD)
-		{
-			foundOne = true;
-		}
-		else
-		{
-			droid = iterateGroup(buildGroup);
-		}
-	}
-	if (droid != NULLOBJECT)
-	{
-		initGetFeature(oilRes, -1, me);
-		_oil = getFeatureB(me);
-		while (_oil != NULLOBJECT)
-		{
-			_newDist = distBetweenTwoPoints(droid.x, droid.y, _oil.x, _oil.y);
-			_same = false;
-
-			if (_newDist < _bestDist and droidCanReach(droid, _oil.x, _oil.y) and safeDest(me, _oil.x, _oil.y))	// this one is closer
-			{
-				initIterateGroup(buildGroup);				// find all units in build group.
-				_search = iterateGroup(buildGroup);
-				foundOne = false;
-				while (_search != NULLOBJECT && !foundOne)
-				{
-					if (_search.orderx == _oil.x and _search.ordery == _oil.y and _search != droid)
-					{
-						_same = true;
-						foundOne = true;
-					}
-					_search = iterateGroup(buildGroup);
-				}
-				if (!_same)	// do not go to same spot as another droid
-				{
-					_bestDist = _newDist;
-					_closestOil = _oil;
-				}
-			}
-			_oil = getFeatureB(me);
-		}
-		if (_closestOil != NULLOBJECT)
-		{
-			orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _closestOil.x, _closestOil.y); // build a derick
-			dbgObj(droid, "Off to build derrick at ("& _closestOil.x & ", " & _closestOil.y & ")");
-			if (idleGroup(buildGroup) > 0)
-			{
-				setEventTrigger(buildDerrick, slowloadTr);	// do it again for next droid
-				exit;
-			}
-		}
-		else
-		{
-			if (!tryUpgrade())	// try upgrading buildings
-			{
-				setEventTrigger(buildOilDefenseOrRetreat, chainloadTr);	// need defense?
-			}
-		}
-	}
-	setEventTrigger(buildDerrick, inactive);
-}
-
-/////////////////////////////////////////////////////////////////////
-// if idle and derrick in range and no defense then build defense, else ret to base .
-event buildOilDefenseOrRetreat(inactive)
-{
-	local	int		_numBuilders,_maxBuilders;
-
-	_maxBuilders = 1;
-
-	// check idle.
-	initIterateGroup(buildGroup);					// find idle droids in build group.
-	droid = iterateGroup(buildGroup);
-	while(droid != NULLOBJECT)
-	{
-		if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.order != DORDER_HELPBUILD)
-		{
-			// if in range of a derrick
-			structure = structureBuiltInRange(derrick, droid.x, droid.y, (5*128), me);
-
-			// if inside base limits then presume ok..
-			if( structure != NULLOBJECT)
-			{
-				if((structure.x > minx) and (structure.y > miny) and (structure.x < maxx) and (structure.y <maxy))
-				{
-					structure = NULLOBJECT;
-				}
-			}
-
-			if(structure != NULLOBJECT)
-			{
-				buildX = structure.x;
-				buildY = structure.y;
-
-				// not many defenses nearby
-				if(numFriendlyWeapStructsInRange(me, buildX, buildY, (3*128), FALSE) < 2)
-				{
-					count = numDefStructs - 1;							//pick a struct to build..
-					count2 = 0;
-					while( (count2 < 5) and (count >= 0) )
-					{
-						if( isStructureAvailable(defStructs[count],me))
-						{
-							structChoice[count2] = defStructs[count];
-							count2 = count2 + 1;
-						}
-						count = count - 1;
-					}
-					count =0;
-					if(count2 > 0)
-					{
-						count = random(count2);						 //count = choice!
-
-						// pick a location
-						if (pickDroidStructLocation(droid, structChoice[count], ref buildX, ref buildY, me, 1))
-						{
-							_numBuilders = numBuildSameBuilding(NULLSTRUCTURESTAT, buildX, buildY);
-
-							if (_numBuilders < _maxBuilders)
-							{
-								// build it.
-								orderDroidStatsLoc(droid, DORDER_BUILD,structChoice[count], buildX,buildY);
-								_numBuilders++;
-							}
-						}
-					}
-				}
-				else
-				{
-					structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), me);
-					if(structure == NULLOBJECT)
-					{
-						if(!insideBase(droid.x, droid.y))
-						{
-							orderDroid(droid,DORDER_RTB);				// return to base;
-						}
-					}
-				}
-			}
-			else
-			{
-				structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), me);
-				if(structure == NULLOBJECT)
-				{
-					if(!insideBase(droid.x, droid.y))
-					{
-						orderDroid(droid,DORDER_RTB);					// return to base;
-					}
-				}
-			}
-		}
-		droid = iterateGroup(buildGroup);
-	}
-	if (idleGroup(buildGroup) > 0)
-	{
-		// Fundamental base already built, so start expanding it if we have too much power. It will call all kinds
-		// of wasteful spending routines. Nothing is worse than losing with the coffers full! This event will
-		// allow us to spend more, and failing that will call the build defense event instead.
-		setEventTrigger(buildExpand, chainloadTr);	// not enough to do, start expanding in depth instead
-	}
-	setEventTrigger(buildOilDefenseOrRetreat, inactive);
-}
-
-/////////////////////////////////////////////////////////////////////
-//mortar etc.. rules. build sensor towers and emplacements.
-event incendry(inactive)
-{
-	local int result;
-	local bool boolResult;
-	local STRUCTURE structure2;
-
-	if (not isStructureAvailable(sensorTower, me))
-	{
-		exit;
-	}
-
-	initEnumStruct(FALSE,sensorTower,me,me);
-
-	count = 0;
-	structure = enumStruct();
-	while(structure != NULLOBJECT)
-	{
-		count = count + 1;
-		structure = enumStruct();
-	}
-
-	if(count < (gameTime/4200) )		// every 7 mins
-	{
-		// if not found build a sensor tower.
-		// find a place to build.
-		buildX = 0;
-		buildY = 0;
-		initEnumStruct(FALSE,derrick,me,me);
-		structure= enumStruct();
-		while(structure != NULLOBJECT)
-		{
-			count = 0;
-			result = 0;
-			while(count < numDefStructs)
-			{
-				structure2 = structureBuiltInRange(defStructs[count], structure.x, structure.y,(4*128), me);
-				if(structure2 != NULLOBJECT)
-				{
-					result = result + 1;
-				}
-				count = count + 1;
-			}
-
-			// check for sensor nearby,
-			structure2 = structureBuiltInRange(sensorTower, structure.x, structure.y,(5*128), me);
-			if(structure2 != NULLOBJECT)
-			{
-				result = 4;
-			}
-
-			if(result < 3)
-			{
-				buildX = structure.x;
-				buildY = structure.y;
-				structure = NULLOBJECT;
-			}
-			else
-			{
-				structure = enumStruct();
-			}
-		}
-
-		if(buildX != 0)
-		{
-			boolResult = pickStructLocation(sensorTower, ref buildX, ref buildY,me);	// pick spot.
-			if(boolResult == TRUE)
-			{
-				// find unit
-				initIterateGroup(buildGroup);
-				droid = iterateGroup(buildGroup);
-				while(droid != NULLOBJECT)
-				{
-					if ((droid.order == DORDER_NONE or droid.order == DORDER_RTB) and droidCanReach(droid, buildX, buildY))
-					{
-						orderDroidStatsLoc(droid, DORDER_BUILD, sensorTower, buildX, buildY);
-						droid = NULLOBJECT;
-					}
-					else
-					{
-						droid = iterateGroup(buildGroup);
-					}
-				}
-			}
-		}
-	}
-	else
-	{
-		// find a sensor tower with least incencdry structs around it..
-		buildX = 0;
-		buildY = 0;
-
-		initEnumStruct(FALSE,sensorTower,me,me);
-		structure= enumStruct();
-		count = 999;
-		while(structure != NULLOBJECT)
-		{
-			// count incendrys near this tower.
-			result = 0;
-			count2 = 0;
-			while(count2 < numIncendrys)
-			{
-				structure2 = structureBuiltInRange(incendrys[count2], structure.x, structure.y,(4*128), me);
-				if(structure2 != NULLOBJECT)
-				{
-					result = result + 1;
-				}
-				count2 = count2 + 1;
-			}
-
-			if((result < 6) and (result < count))		// lowest found yet. only sites with <6 too.
-			{
-				buildX = structure.x;
-				buildY = structure.y;
-				count  = result;
-			}
-			structure = enumStruct();
-		}
-
-		if(buildX != 0)
-		{
-			// choose a device
-			count = numIncendrys - 1;
-			result = 99;
-			while(count >= 0 )
-			{
-				if(isStructureAvailable(incendrys[count],me))
-				{
-					result = count;
-					count = -1;
-				}
-				else
-				{
-					count = count - 1;
-				}
-			}
-
-			// find a unit and build an incendry device.
-			if(result != 99)
-			{
-				boolResult = pickStructLocation(incendrys[result], ref buildX, ref buildY,me);	// pick spot.
-				if(boolResult == TRUE)
-				{
-					initIterateGroup(buildGroup);
-					droid = iterateGroup(buildGroup);
-
-					boolResult = (numBuildSameBuilding(incendrys[result], buildX, buildY) > 0);	//anyone building there already?
-
-					while(droid != NULLOBJECT and (not boolResult))
-					{
-						if ((droid.order == DORDER_NONE or droid.order == DORDER_RTB) and droidCanReach(droid, buildX, buildY))
-						{
-							orderDroidStatsLoc(droid, DORDER_BUILD,incendrys[result], buildX,buildY);
-							boolResult = TRUE;	//only 1 truck
-						}
-						droid = iterateGroup(buildGroup);
-					}
-				}
-			}
-		}
-	}
-	setEventTrigger(incendry, inactive);
-}
-
-/////////////////////////////////////////////////////////////////////
-// build a power gen for every 4 derricks. VITAL!
-event buildPowerGenerators(inactive)
-{
-	if (isStructureAvailable(powGen, me))
-	{
-		if (not grabTrucksAndBuild(20, powGen, 1))
-		{
-			dbgPlr("Needed power generator but could not build one");
-		}
-	}
-	setEventTrigger(buildPowerGenerators, inactive);
-}
-
-/////////////////////////////////////////////////////////////////////
-//  build other stuff, grow the base slowly...
-event buildExpand(inactive)
-{
-	local int factories, reslabs, vtolfacs, cybfacs, total;
-
-	setEventTrigger(buildExpand, inactive);
-
-	if (playerPower(me) < LOW_POWER)
-	{
-		exit;	// do not expand base with low power
-	}
-
-	// Try to keep some balance to the madness
-	factories = numFactories();
-	reslabs = numResearchLabs();
-	vtolfacs = numVtolFactories();
-	cybfacs = numCyborgFactories();
-	total = factories + reslabs + vtolfacs + cybfacs;
-
-	if (playerPower(me) > LOW_POWER * total)
-	{
-		dbgPlr("EXPAND! factories=" & factories & " vtolfacs=" & vtolfacs & " cybfacs=" & cybfacs & " reslabs=" & reslabs);
-		buildX = baseX;
-		buildY = baseY;
-		if (isStructureAvailable(cybFactory, me) and (cybfacs < factories))
-		{
-			if (grabTrucksAndBuild(10, cybFactory, 0))
-			{
-				dbgPlr("Building more cyborg factories");
-			}
-			exit;
-		}
-		if (isStructureAvailable(resLab, me) and (reslabs < factories))
-		{
-			if (grabTrucksAndBuild(10, resLab, 0))
-			{
-				dbgPlr("Building more research labs");
-			}
-			exit;
-		}
-		if (isStructureAvailable(vtolFactory, me) and (vtolfacs < factories))
-		{
-			if (grabTrucksAndBuild(10, vtolFactory, 0))
-			{
-				dbgPlr("Building more VTOL factories");
-			}
-			exit;
-		}
-		if (isStructureAvailable(factory, me) and (factories < vtolfacs + cybfacs + reslabs + 1))
-		{
-			if (grabTrucksAndBuild(25, factory, 0))
-			{
-				dbgPlr("Building more factories");
-			}
-			exit;
-		}
-	}
-
-	if (idleGroup(buildGroup) > 0)
-	{
-		setEventTrigger(newfortify, slowloadTr);
-	}
-
-	extraStruct = extraStruct + 1;
-}
-
-/////////////////////////////////////////////////////////////////////
-//  fortify base by builiding defensive structs on the edge of the base.
-// rewrote fortify to use scrSkDefenseLocation(baseX,baseY,me);
-event newfortify(inactive)
-{
-	local int _numBuilders,_maxBuilders, tempx, tempy;
-	local bool boolResult;
-
-	_maxBuilders = 1;
-	setEventTrigger(newfortify, inactive);
-
-	if (numGroupSameOrder(buildGroup, DORDER_LINEBUILD) < _maxBuilders)	// only gateway fortifications use line build
-	{
-		boolResult = FALSE;
-		initIterateGroup(buildGroup);				// find idle an idle veh.in build group.
-		droid = iterateGroup(buildGroup);
-		while((boolResult == FALSE) and (droid != NULLOBJECT))
-		{
-			if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.order != DORDER_HELPBUILD)
-			{
-				boolResult = TRUE;					// dont do this again!
-
-				tempx = baseX;
-				tempy = baseY;
-
-				// choose a suitable turret.
-				count = numWallWeaps - 1;
-				count2 = 0;
-				while ((count2 < 3) and (count >= 0))
-				{
-					if (isStructureAvailable(wallWeaps[count], me))
-					{
-						structChoice[count2] = wallWeaps[count];
-						count2 = count2 + 1;
-					}
-					count = count - 1;
-				}
-				count = 0;
-				if ((count2 > 0) and (_numBuilders < _maxBuilders))
-				{
-					count = random(count2);
-					skDefenseLocationB(ref tempx, ref tempy, wall, structChoice[count], droid, me);
-					_numBuilders++;
-				}
-
-			}
-			droid = iterateGroup(buildGroup);
-		}
-	}
-	if (idleGroup(buildGroup) > 0 and !tryUpgrade())
-	{
-		dbgPlr("No more base defenses to build - trying to build incedry");
-		setEventTrigger(incendry, slowloadTr);
-	}
-}
-
-
-/////////////////////////////////////////////////////////////////////
-// droid building rules
-/////////////////////////////////////////////////////////////////////
-// deal with a droid being built
-event droidBuiltAssign(droidBuiltTr)
-{
-	if(isVtol(droid))
-	{
-		if(vtolDefendGr.members < numDefendVtols)
-		{
-			groupAddDroid(vtolDefendGr, droid);
-		}
-		else
-		{
-			count = 0;
-			while(count < numVtolAttackGroups)
-			{
-				if(vtolAttackGr[count].members < numAttackVtols)
-				{
-					dbg("added new vtol to group " & count, me);
-					groupAddDroid(vtolAttackGr[count], droid);
-					count = numVtolAttackGroups;
-				}
-				count++;
-			}
-		}
-	}
-	else if((droid.droidType != DROID_TRANSPORTER) and (droid.droidType != DROID_COMMAND))
-	{
-
-		if((droid.droidType == DROID_REPAIR)
-			or (droid.droidType == DROID_CYBORG_REPAIR))
-		{
-			numRepairUnits = numRepairUnits + 1;
-		}
-		
-		if((droid.droidType == DROID_CONSTRUCT)
-			or (droid.droidType == DROID_CYBORG_CONSTRUCT))				// if constructor droid
-		{
-			groupAddDroid(buildGroup, droid);
-		}
-		else
-		{
-			if(droid.droidType == DROID_CYBORG)
-			{
-				if (random(2) == 1) 
-				{
-					groupAddDroid(attackGroup, droid);
-				}
-				else
-				{
-					groupAddDroid(defendGroup, droid);
-				}
-			}
-			else
-			{
-				if(scoutGroup.members < numScouts)
-				{
-					groupAddDroid(scoutGroup, droid);
-				}
-				else if(attackGroup.members < numAttackers[curTech])
-				{
-					groupAddDroid(attackGroup, droid);
-				}
-				else if( defendGroup.members < numDefenders[curTech])
-				{
-					groupAddDroid(defendGroup, droid);
-				}
-				else
-				{
-					if(scoutGroup.members < maxScouts)
-					{
-						groupAddDroid(scoutGroup, droid);
-					}
-					else if(attackGroup.members < maxAttackers[curTech])
-					{
-						groupAddDroid(attackGroup, droid);
-					}
-					else if( defendGroup.members < maxDefenders[curTech])
-					{
-						groupAddDroid(defendGroup, droid);
-					}
-					else	//make them attack
-					{
-						groupAddDroid(attackGroup, droid);
-					}
-				}
-			}
-		}
-	}
-}
-
-//When droid built: check emergency jobs, start building next droid
-event droidBuilt(droidBuiltTr)
-{
-	local STRUCTURE _fundie;
-
-	if (droid.droidType == DROID_CONSTRUCT)
-	{
-		setEventTrigger(buildFundamentals, slowloadTr);	// activate
-	}
-
-	/* Start building next droid */
-	if(structure != NULLOBJECT)
-	{
-		if (droid.droidType == DROID_CONSTRUCT && structure.stattype == REF_FACTORY)
-		{
-			setEventTrigger(conDroids, chainloadTr);	// consider building more
-		}
-		// Continue building new droids right away
-		else if(structure.stattype == REF_FACTORY)
-		{
-			factoryBuildDroid(structure);
-		}
-		else if(structure.stattype == REF_CYBORG_FACTORY)
-		{
-			cybFactorBuildCyborg(structure);
-		}
-		else if(structure.stattype == REF_VTOL_FACTORY)
-		{
-			vtolFactoryBuildVtol(structure);
-		}
-	}
-}
-
-/* Gets triggered when structure was built */
-event structBuilt(structBuiltTr)
-{
-	local	FEATURE	_oilResource;
-	local	int		_count,_count2;
-
-	if (structure == NULLOBJECT || droid == NULLOBJECT)
-	{
-		exit;
-	}
-
-	// Try to do more nasty things with rush group
-	if (groupMember(rushGroup, droid))
-	{
-		if (isStructureAvailable(wallWeaps[0], me))
-		{
-			dbgPlr("Manic wall code triggered");
-			setEventTrigger(manicWalls, chainloadTr);	// try to wall in enemy
-			exit;
-		}
-		else
-		{
-			dbgPlr("Nothing more to do for rush group - disbanding it!");
-			groupAddGroup(buildGroup, rushGroup);
-			setEventTrigger(buildFundamentals, slowloadTr);
-			exit;
-		}
-	}
-
-	/* factory or factory module */
-	if(structure.stattype == REF_FACTORY)
-	{
-		if (isStructureAvailable(facModule, me) and (skGetFactoryCapacity(structure) < 2 ) and (getDroidCount(me) > 4))
-		{
-			orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.
-		}
-		else
-		{
-			setEventTrigger(conDroids, chainloadTr);
-		}
-	}
-	/* vtol factory or vtol factory module */
-	else if(structure.stattype == REF_VTOL_FACTORY)
-	{
-		if( isStructureAvailable(facModule,me) and (skGetFactoryCapacity(structure) < 2 ))
-		{
-			orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.
-		}
-	}
-	else if(structure.stattype == REF_RESOURCE_EXTRACTOR)
-	{
-		setEventTrigger(buildDerrick, chainloadTr);
-		exit;
-	}
-	else if (structure.stattype == REF_RESEARCH)
-	{
-		if (isStructureAvailable(resModule, me))
-		{
-			orderDroidStatsLoc(droid, DORDER_BUILD, resModule, structure.x, structure.y);	// upgrade it.
-		}
-		else
-		{
-			setEventTrigger(doResearch, chainloadTr);
-		}
-	}
-	else if (structure.stattype == REF_POWER_GEN)
-	{
-		if (isStructureAvailable(powModule, me))
-		{
-			orderDroidStatsLoc(droid, DORDER_BUILD, powModule, structure.x, structure.y);	// upgrade it.
-		}
-	}
-
-	// Check if available trucks need to build more absolute necessities right away. We need a trigger here because
-	// droids involved in building have not yet come out of their build orders.
-	setEventTrigger(buildFundamentals, slowloadTr);
-
-	//see if we have just rebuilt a destroyed structure
-	_count = 0;
-	while(_count < countRebuildStruct)
-	{
-		if(structure.x == rebuildStructX[_count] and
-		   structure.y == rebuildStructY[_count] and
-		   ( (structure.stat == rebuildStructStat[_count]) or //walls can end up as corner walls
-		   ( (structure.stat == wall or structure.stat == cornerWall) and
-		   (rebuildStructStat[_count] == wall or rebuildStructStat[_count] == cornerWall))
-		   ))
-		{
-			dbg("finished rebuilding destroyed structure - " & _count, me);
-
-			//resort destroyed structures
-			_count2 = _count;
-			while(_count2 < (countRebuildStruct - 1))
-			{
-				rebuildStructX[_count2] = rebuildStructX[_count2 + 1];
-				rebuildStructY[_count2] = rebuildStructY[_count2 + 1];
-				rebuildStructStat[_count2] = rebuildStructStat[_count2 + 1];
-
-				_count2++;
-			}
-
-			//clear last entry
-			rebuildStructX[countRebuildStruct - 1] = 0;
-			rebuildStructY[countRebuildStruct - 1] = 0;
-			rebuildStructStat[countRebuildStruct - 1] = NULLSTRUCTURESTAT;
-
-			countRebuildStruct--;	//we just built one structure
-
-			//_count = countRebuildStruct;	//exit outer loop
-		}
-		_count++;
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// deal with attacks.
-event droidDestroyed(droidDestroyedTr)
-{
-
-	if(droid.droidType == DROID_REPAIR)
-	{
-		numRepairUnits = numRepairUnits - 1;
-	}
-
-	if(droid.droidType == DROID_CONSTRUCT)					// if constructor droid
-	{
-		initEnumStruct(FALSE,factory,me,me);
-		structure= enumStruct();							// find factory.
-
-		if( (structure != NULLOBJECT) and (getDroidCount(me) < MAX_DROIDS) )
-		{
-			buildDroid(constructor, structure, me, 1);	// build constructor
-		}
-
-	}
-}
-
-
-/////////////////////////////////////////////////////////////////////
-// build more con droids.
-event conDroids(conDroidsTr)
-{
-	local 	int			_maxTrucks;
-	local 	STRUCTURE	_factory;
-	local	int 		_numBuilding,_haveTrucks,_maxTruckFactories,_totalTrucks;
-	local	bool		_bStartedBuilding;
-
-	_maxTrucks = MAX_TRUCKS;
-	if (playerPower(me) < LOW_POWER)
-	{
-		_maxTrucks = MIN_TRUCKS;
-	}
-
-	_maxTruckFactories = 3; 		//max factories to use for truck production
-
-	_haveTrucks = buildGroup.members;
-	
-	//Find out how many trucks and combat engineers are already in production
-	_numBuilding = numTemplatesInProduction(constructor,me);	//trucks
-	_numBuilding = _numBuilding + numTemplatesInProduction(cybEngineer,me);	//engineers
-
-	_totalTrucks = _numBuilding + _haveTrucks;
-	
-	initEnumStruct(FALSE,factory,me,me);
-	_factory = enumStruct();
-	
-	while ((_factory != NULLOBJECT) and (_numBuilding < _maxTruckFactories) and (_totalTrucks < _maxTrucks))
-	{
-		//Try to build a truck
-		if (skCanBuildTemplate(me, _factory, hovertruck))
-		{
-			_bStartedBuilding = buildUnit(hovertruck, _factory, factory, FALSE);	//build truck even if not idle
-		}
-		else
-		{
-			_bStartedBuilding = buildUnit(constructor, _factory, factory, FALSE);	//build truck even if not idle
-		}
-		
-		//Update statistics if started building a truck
-		if(_bStartedBuilding)
-		{
-			_numBuilding++;
-			_totalTrucks++;
-		}
-		
-		_factory = enumStruct();
-	}
-	
-	//build cyborg engineers if needed, no building structure limit here
-	initEnumStruct(FALSE,cybFactory,me,me);
-	_factory = enumStruct();
-	while((_factory != NULLOBJECT) and (_totalTrucks < _maxTrucks))
-	{
-		//Try to build a truck
-		if( skCanBuildTemplate(me,_factory, cybEngineer) )	//make sure we have researched cyb engineer
-		{
-			_bStartedBuilding = buildUnit(cybEngineer, _factory, cybFactory, FALSE);	//build a cyb eng even if not idle
-			
-			//Update statistics if started building a cyborg engineer
-			if(_bStartedBuilding)
-			{
-				_numBuilding++;
-				_totalTrucks++;
-			}
-		}
-
-		_factory = enumStruct();
-	}
-	setEventTrigger(conDroids, conDroidsTr);
-}
-
-//Build a droid
-function bool buildUnit(TEMPLATE _tankTemplate, STRUCTURE _factory, STRUCTURESTAT _factoryType, bool _bIdleOnly)
-{
-	//Factory was not provided, find an factory
-	if(_factory == NULLOBJECT)
-	{
-		_factory = findIdleStructure(_factoryType, _bIdleOnly);
-	}
-
-	//Build if got a factory
-	if(_factory != NULLOBJECT)
-	{
-		if(structureComplete(_factory) and (getDroidCount(me) < MAX_DROIDS))
-		{
-			if( !(_bIdleOnly and !structureIdle(_factory)) )	//don't build if only allowed to build whe idle and fac is not idle
-			{
-				buildDroid(_tankTemplate, _factory, me, 1);	// build a tank
-				return TRUE;	//success
-			}
-		}
-	}
-
-	return FALSE;		//failed
-}
-
-//Returns an idle structure of the provided type or NULLOBJECT if none found
-function STRUCTURE findIdleStructure(STRUCTURESTAT _structType, bool _bIdleOnly)
-{
-	local	STRUCTURE	_structure;
-
-	initEnumStruct(FALSE,_structType,me,me);
-	_structure = enumStruct();
-	while(_structure != NULLOBJECT)
-	{
-		if(structureComplete(_structure))
-		{
-			if( !(_bIdleOnly and !structureIdle(_structure)) )
-			{
-				return _structure;
-			}
-		}
-
-		_structure = enumStruct();
-	}
-	
-	return NULLOBJECT;	//none found
-}
-
-/////////////////////////////////////////////////////////////////////
-// build repair droids.
-event repairDroids(repairDroidsTr)
-{
-	// if we're running low on repair droids, build some..
-	if(numRepairUnits <3)
-	{
-		initEnumStruct(FALSE,factory,me,me);
-		structure= enumStruct();							// find factory.
-		if (structure != NULLOBJECT)
-		{
-			if ((getDroidCount(me) < MAX_DROIDS) and (skCanBuildTemplate(me, structure, repairUnit)))
-			{
-				buildDroid(repairUnit, structure, me, 1);	// build repairunit.
-			}
-		}
-	}
-}
-
-
-/////////////////////////////////////////////////////////////////////
-event factoryEvent(factoryEventTr)
-{
-	// for each factory....
-	initEnumStruct(FALSE,factory,me,me);
-	structure = enumStruct();								// find factory.
-	if(getDroidCount(me) < MAX_DROIDS)
-	{
-		while(structure != NULLOBJECT)
-		{
-			if( structureIdle(structure) )
-			{
-				factoryBuildDroid(structure);
-			}
-
-			structure = enumStruct();
-		}
-	}
-}
-
-function bool needTank()
-{
-	if(not havePowerSource())
-	{
-		return FALSE;
-	}
-	
-	if((defendGroup.members < maxDefenders[curTech]) or (maxDefenders[curTech] == UNLIMITED))
-	{
-		return TRUE;
-	}
-
-	if((scoutGroup.members < maxScouts) or (maxScouts == UNLIMITED))
-	{
-		return TRUE;
-	}
-
-	if((attackGroup.members < maxAttackers[curTech]) or (maxAttackers[curTech] == UNLIMITED))
-	{
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-function void factoryBuildDroid(STRUCTURE _factory)
-{
-	local int _count,_count2;
-
-	if(_factory == NULLOBJECT){
-		dbgPlr("factoryBuildDroid: factory is NULLOBJECT");
-		return;
-	}
-
-	if(not needTank())
-	{
-		dbgPlr("factoryBuildDroid: NEED NO TANKS!! limit=" & maxDefenders[curTech]);
-		return;
-	}
-
-	if( structureIdle(_factory) )
-	{
-		_count = numTemplates - 1;
-		_count2 = 0;
-		while( (_count2 < MAX_RANDOM_TEMPLATES) and (_count >= 0) )
-		{
-			if( skCanBuildTemplate(me,_factory, tmpl[_count]) )
-			{
-				tmplChoice[_count2] = tmpl[_count];
-				_count2 = _count2 + 1;
-			}
-			_count = _count - 1;
-		}
-
-		if(_count2 > 0)
-		{
-			buildDroid(tmplChoice[random(_count2)],_factory,me,1);
-		}
-	}
-	else
-	{
-		dbgPlr("factoryBuildDroid: Factory is busy!");
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// put cyborg factories to work
-event cyborgFactoryEvent(cyborgFactoryEventTr)
-{
-	if(not ((defendGroup.members < maxCyborgs) or (maxCyborgs == UNLIMITED)))
-	{
-		exit;		//we need no cyborgs
-	}
-
-	initEnumStruct(FALSE,cybFactory,me,me);
-	structure= enumStruct();								// find factory.
-
-	while(structure != NULLOBJECT)
-	{
-		if( structureIdle(structure) == TRUE)
-		{
-			cybFactorBuildCyborg(structure);
-		}
-		structure= enumStruct();							// find factory.
-	}
-}
-
-function void cybFactorBuildCyborg(STRUCTURE _factory)
-{
-	if(_factory == NULLOBJECT){
-		dbg("cybFactorBuildCyborg: factory is NULLOBJECT", me);
-		return;
-	}
-
-	if( structureIdle(_factory) )
-	{
-		if( (defendGroup.members < maxCyborgs) and (getDroidCount(me) < MAX_DROIDS) )
-		{
-			if(random(5) == 1)
-			{
-				buildDroid(cybMechanic,_factory,me,1);
-			}
-			else
-			{
-				count = 3;
-				count2 = 0;
-				while( count >= 0 )
-				{
-					if( skCanBuildTemplate(me,_factory, superCyb[count]) )
-					{
-						tmplChoice[count2] = superCyb[count];
-						count2 = count2 + 1;
-					}
-					count = count - 1;
-				}
-
-				if(count2 > 0)
-				{
-					buildDroid(tmplChoice[random(count2)],_factory,me,1);
-				}
-				else	//try light cyborgs
-				{
-					count = numLightCyborgs - 1;
-					count2 = 0;
-					while( (count >= 0) and (count2 < 2) )
-					{
-						if( skCanBuildTemplate(me,_factory, cybTempl[count]) )
-						{
-							tmplChoice[count2] = cybTempl[count];
-							count2++;
-						}
-						count--;
-					}
-					if(count2 > 0)
-					{
-						buildDroid(tmplChoice[random(count2)], _factory, me, 1);
-					}
-				}
-			}
-
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// scouting rules
-
-// scout an area
-event chooseScoutArea(chooseScoutAreaTr)
-{
-	scoutX = scoutTLX + random(scoutW);
-	scoutY = scoutTLY + random(scoutH);
-}
-
-/////////////////////////////////////////////////////////////////////
-// visit new places
-
-event expandScoutArea(expandScoutAreaTr)
-{
-	//expand the scouting area slightly
-	scoutTLX	= scoutTLX - ((mapWidth*128)/ tileExpand);
-	scoutTLY	= scoutTLY - ((mapHeight*128)/ tileExpand);
-	scoutW		= scoutW + (2*((mapWidth*128)/ tileExpand));
-	scoutH		= scoutH + (2*((mapHeight*128)/ tileExpand));
-
-	// check & restrain.
-	if(scoutTLX <1)
-	{
-		scoutTLX = 1;
-	}
-	if(scoutTLY <1)
-	{
-		scoutTLY = 1;
-	}
-
-	if(scoutTLX >(mapWidth*128))
-	{
-		scoutTLX = (mapWidth*128) - 128;
-	}
-	if(scoutTLY >(mapHeight*128))
-	{
-		scoutTLY = (128*mapHeight) - 128;
-	}
-
-	if( (scoutTLX + scoutW) > (128 * mapWidth) )
-	{
-		scoutW = ( (128 * mapWidth) - scoutTLX) - 128;
-	}
-	if( (scoutTLY + scoutH) > (128 *mapHeight) )
-	{
-		scoutH = ( (128*mapHeight) - scoutTLY) - 128;
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// order scouts
-
-event scoutMain(scoutMainTr)
-{
-	// find any new scouts
-	// if scouts aren't busy, send them to a new spot.
-	if( idleGroup(scoutGroup) >= (scoutGroup.members /2) )
-	{
-		orderGroupLoc(scoutGroup, DORDER_MOVE,scoutX,scoutY);
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// process new visibility reports
-event newObjectReport(newObjectReportTr)
-{
-	if(!friendlyPlayer(baseobj.player))
-	{
-		if(targetTypeValue(baseobj) > targetTypeValue(attackObj))
-		{
-			attackObj = baseobj;// got a new unseen  target from a scout.
-
-			if(	attackObj.type == OBJ_STRUCTURE)
-			{
-				if(not allianceExistsBetween(attackObj.player,me))	// an enemy
-				{
-					structure = objToStructure(attackObj);
-					if(structure.stat == factory)
-					{
-						allOutAttack = attackObj;
-					}
-				}
-			}
-		}
-	}
-}
-
-function int targetTypeValue(BASEOBJ _target)
-{
-	local STRUCTURE _strTarget;
-
-	if(_target == NULLOBJECT){
-		return NO_TARGET_VALUE;
-	}
-
-	if(_target.type == OBJ_DROID)
-	{
-		return DROID_TARGET_VALUE;
-	}
-	else if(_target.type == OBJ_STRUCTURE)
-	{
-		_strTarget = objToStructure(_target);
-
-		if(_strTarget.stattype == REF_DEFENSE)
-		{
-			return DEFENSE_TARGET_VALUE;
-		}
-		else if(_strTarget.stattype == REF_RESEARCH or
-				_strTarget.stattype == REF_POWER_GEN)
-		{
-			return RESEARCH_TARGET_VALUE;
-		}
-		else if(_strTarget.stattype == REF_HQ or
-				_strTarget.stattype == REF_COMMAND_CONTROL)
-		{
-			return HQ_TARGET_VALUE;
-		}
-		else if(_strTarget.stattype == REF_RESOURCE_EXTRACTOR)
-		{
-			return OIL_TARGET_VALUE;
-		}
-		else if(_strTarget.stattype == REF_FACTORY or
-				_strTarget.stattype == REF_CYBORG_FACTORY or
-				_strTarget.stattype == REF_VTOL_FACTORY)
-		{
-			return FACTORY_TARGET_VALUE;
-		}
-		else	//walls, rearm pads etc
-		{
-			return OTHER_TARGET_VALUE;
-		}
-	}
-
-	return NO_TARGET_VALUE;
-}
-
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// spy technologies
-//event takeover( CALL_UNITTAKEOVER , ref droid  )
-
-event takeover(takeoverTr)
-{
-	if( droid.player == me )
-	{
-		if(droid.droidType == DROID_CONSTRUCT or
-				droid.droidType == DROID_CYBORG_CONSTRUCT)
-		{
-			groupAddDroid( buildGroup, droid );
-		}
-		else if (droid.droidType != DROID_TRANSPORTER
-		      && droid.droidType != DROID_COMMAND)
-		{
-			groupAddDroid( attackGroup, droid );
-		}
-	}
-}
-
-event takeoverDefend(takeoverTr)
-{
-	if( droid.player != me )
-	{
-		completeResearch(nexusDefence,me);
-		setEventTrigger(takeoverDefend,	inactive);
-	}
-}
-
-
-event useLassat(useLassatTr)
-{
-	// find my lassat
-	// fire it at my attack objective.
-	if(allOutAttack != NULLOBJECT)
-	{
-		initEnumStruct(FALSE,lassat,me,me);
-		structure= enumStruct();
-		while(structure != NULLOBJECT)
-		{
-			if(structureComplete(structure) == TRUE)
-			{
-				skFireLassat(me,allOutAttack);
-			}
-			structure= enumStruct();
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// attack rules
-
-event findEnemy(attackStuffTr)
-{
-	if(attackObj == NULLOBJECT)
-	{
-		count = random(8);
-		count2 = 100;
-		while( friendlyPlayer(count) && (count2 > 0) )
-		{
-			count = random(8);
-			count2--;
-		}
-
-		if(!friendlyPlayer(count))
-		{
-			baseobj = skLocateEnemy(count);
-			if(baseobj != NULLOBJECT)
-			{
-				attackObj =	baseobj;
-
-				// set allOutAttack to attackObj only if attackObj is a more valuable target than allOutAttack
-				if(targetTypeValue(attackObj) > targetTypeValue(allOutAttack))
-				{
-					allOutAttack = attackObj;
-				}
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// send attack team out to cause trouble near things scout found.
-event attackStuff(attackStuffTr)
-{
-	local int i, x, y;
-	local BASEOBJ result, best;
-
-	// Attacks of opportunity
-	i = 0;
-	result = getDerrick(i);
-	best = NULLOBJECT;
-	while (result != NULLOBJECT)
-	{
-		if (result.type == OBJ_STRUCTURE and !allianceExistsBetween(result.player, me) and safeDest(me, result.x, result.y))
-		{
-			best = result;	// easy pickings
-		}
-		i++;
-		result = getDerrick(i);
-	}
-	if (best != NULLOBJECT)
-	{
-		dbgPlr("MOVEMENT OF OPPORTUNITY to " & best.x & ", " & best.y);
-		orderGroupLoc(attackGroup, DORDER_SCOUT, best.x, best.y);
-		exit;
-	}
-
-	// Regular attacks
-	if (idleGroup(attackGroup) >= (attackGroup.members / 2))
-	{
-		if( (attackObj != NULLOBJECT) and (not helpingAlly()) )
-		{
-			if (not allianceExistsBetween(me, attackObj.player))
-			{
-				if(attackGroup.members > (6 + random(6)) )
-				{
-					orderGroupLoc(attackGroup, DORDER_SCOUT, attackObj.x, attackObj.y);
-				}
-
-				// make scouts attack too
-				if( idleGroup(scoutGroup) >= (scoutGroup.members / 2) )
-				{
-					orderGroupLoc(scoutGroup, DORDER_SCOUT, attackObj.x, attackObj.y);
-				}
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-event doAllOutAttack(allOutAttackTr)
-{
-	if (idleGroup(attackGroup) >= (attackGroup.members / 3))	// make sure at least 30% are idle
-	{
-		if ((allOutAttack != NULLOBJECT) and (not helpingAlly()))
-		{
-			if (!friendlyPlayer(allOutAttack.player))
-			{
-				if (getDroidCount(me) > 40)	// plenty of units.
-				{
-					dbgPlr("ALL OUT ATTACK!");
-					orderGroupObj(attackGroup, DORDER_ATTACK, allOutAttack);
-					orderGroupObj(defendGroup, DORDER_ATTACK, allOutAttack);
-					orderGroupLoc(scoutGroup, DORDER_SCOUT, allOutAttack.x, allOutAttack.y);
-				}
-			}
-			else
-			{
-				allOutAttack = NULLOBJECT;
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// defending rules
-
-// defend attacked objects.
-event defendWatch(defendWatchTr)
-{
-	if (baseobj != NULLOBJECT)
-	{
-		if (baseobj.type == OBJ_DROID)
-		{
-			if (isVtol(objToDroid(baseobj)))
-			{
-				exit;	// avoid getting caught in the blast from incendiary bombs... no way to check if building is burning
-			}
-		}
-		if (!friendlyPlayer(baseobj.player))
-		{
-			if(distBetweenTwoPoints(baseobj.x, baseobj.y, baseX, baseY) <= MAX_DEFENDERS_RADIUS)	//don't go too far away from the base
-			{
-				defendObj = baseobj;
-				defendbusy = TRUE;
-				// if not too busy, attack.
-				if (idleGroup(defendGroup) >= (defendGroup.members / 2))
-				{
-					orderGroupLoc(defendGroup, DORDER_MOVE, defendObj.x, defendObj.y);	//cyborg mechanics can't attack (won't move)
-				}
-
-				if (idleGroup(scoutGroup) >= (scoutGroup.members / 2))
-				{
-					orderGroupLoc(scoutGroup, DORDER_MOVE, scoutX, scoutY);
-				}
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// defenders  return after they are finished.
-event defendReturn(defendReturnTr)
-{
-	if( defendbusy and (idleGroup(defendGroup) == (defendGroup.members - defendGroup.members / 12)))
-	{
-		// find a place with no structures nearby
-		buildX = baseX;
-		buildY = baseY;
-		pickStructLocationB(powGen, ref buildX, ref buildY, me, 0);
-
-		orderGroupLoc(defendGroup, DORDER_MOVE,buildX,buildY);
-		defendbusy = FALSE;
-	}
-}
-
-//returns number of non-idle structures of a certain type
-function int numStructBusyByType(STRUCTURESTAT _busyStructType)
-{
-	local	int _result;
-
-	initEnumStruct(FALSE,_busyStructType,me,me);
-	structure = enumStruct();
-	_result = 0;
-	while(structure != NULLOBJECT)
-	{
-		if(structureComplete(structure))
-		{
-			if(not structureIdle(structure))
-			{
-				_result++;
-			}
-		}
-		structure = enumStruct();
-	}
-
-	return _result;
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// Research Rules Now does true research.
-// do research
-
-event doResearch(doResearchTr)
-{
-	local	int		_techIndex,_numResearching;
-	local bool boolResult;
-
-	// don't throw in half of your money on research in T3 no bases when we don't have any income yet
-	if (isStructureAvailable(facModule,me) and not havePowerSource())
-	{
-		setEventTrigger(doResearch, doResearchTr);
-		exit;
-	}
-	
-	_techIndex = 0;	//research start
-	_numResearching = numStructBusyByType(resLab);
-
-	// for every research lab do this..
-	initEnumStruct(FALSE,resLab,me,me);
-	structure= enumStruct();
-	count = 0;
-	while(structure != NULLOBJECT)
-	{
-		boolResult = FALSE;		//haven't started research for the current resFac
-
-		if(structureIdle(structure))
-		{
-			if(structureComplete(structure))
-			{
-				// first research all technologies necessary for the current research branch
-				while(not boolResult and _techIndex != NONE)	//not started researching and still branch tech left to try
-				{
-					_techIndex = findResearch(_techIndex, curTech);
-					if(_techIndex > NONE)
-					{
-						boolResult = pursueResearch(structure,me,tech[curTech][_techIndex]);
-
-						_techIndex++;	//try nect research next time if needed
-						_numResearching++;
-					}
-				}
-
-				// do common research
-				if(not boolResult)	//didn't start branch research
-				{
-					if((maxIdleRes == UNLIMITED) or (_numResearching < maxIdleRes))
-					{
-						skDoResearch(structure,me,0);
-						_numResearching++;
-					}
-				}
-			}
-		}
-
-		structure = enumStruct();
-	}
-	setEventTrigger(doResearch, doResearchTr);
-}
-
-// find next available research of our research branch
-function int findResearch(int _searchStart, int _techTree)
-{
-	local	int	_result;
-
-	ASSERT(_searchStart >= 0, "findResearch: _searchStart < 0", me);
-	ASSERT(_techTree >= 0, "findResearch: _techTree < 0", me);
-
-	_result = _searchStart;
-	while(_result < techCount[_techTree])
-	{
-		if((not researchFinished(tech[_techTree][_result], me)) and (not researchStarted(tech[_techTree][_result], me)))
-		{
-			return _result;		//found research
-		}
-		_result++;
-	}
-
-	return NONE;		//not found
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// Alliance Rules
-
-// form alliances
-event formAllianceEvent(formAllianceEventTr)
-{
-	count = 0;
-	while(count < MAX_PLAYERS)
-	{
-		if( count != me )												// if not the only other player and rand2
-		{
-			if((getDroidCount(me) > 1) and (getDroidCount(count) > 1) )	// not dead
-			{
-				if(random(28) == 1)											// bit random
-				{
-					if(not isHumanPlayer(count))							// not human
-					{
-						createAlliance(me,count);
-						allianceTime[count] = gameTime;
-					}
-				}
-			}
-		}
-		count = count + 1;
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// break the alliance too.
-event breakAllianceEvent(breakAllianceEventTr)
-{
-	count = 0;
-	while(count<multiPlayerMaxPlayers)
-	{
-		if( count != me)
-		{
-			if((getDroidCount(me) > 1) and (getDroidCount(count) > 1) )	// not dead
-			{
-				if(allianceExistsBetween(me,count) )
-				{
-					// check if we're in alliance with any other players.
-					if( (random(30) == 1) and ( (gameTime - allianceTime[count]) > 6000) )	// rand and more than 10 minutes.
-					{
-						allianceTime[count] = gameTime;
-						breakAlliance(me,count);
-					}
-
-					// rules for breaking alliances with humans.
-					// built within my base
-					if(numStructsInArea(count,minx,miny,maxx,maxy) > 1)
-					{
-						allianceTime[count] = gameTime;
-						breakAlliance(me,count);
-					}
-
-					// you've got lots of units in my area.
-					if(numDroidsInArea(count,minx,miny,maxx,maxy) > 3)
-					{
-						allianceTime[count] = gameTime;
-						breakAlliance(me,count);
-					}
-
-					// you've wiped out one of my allies ??.
-				}
-			}
-		}
-		count = count + 1;
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-event formHumanAlliances(humanAllianceTr)
-{
-	local int result, result2;
-
-	if(count2 == me) // offered to me.
-	{
-		result = 0;
-		result2 = 0;
-		while(result < multiPlayerMaxPlayers)
-		{
-			if(allianceExistsBetween(count,result))
-			{
-				result2 = result2 + 1;
-			}
-			result = result + 1;
-		}
-		if( result2 < ((multiPlayerMaxPlayers / 2) - 1) )	// not too many already
-		{
-			//not too soon.
-			if((allianceTime[count] == 0) or (gameTime - allianceTime[count] > 1200))
-			{
-				result = 0;								// check forming wont end the game
-				result2 = 0;
-				while(result < multiPlayerMaxPlayers)
-				{
-					while(result2 < multiPlayerMaxPlayers)
-					{
-						if((not allianceExistsBetween(result,result2)) and (getDroidCount(result) > 0) and (getDroidCount(result2) > 0) and (result != result2) )
-						{
-							if( ((result == count and result2 == count2) or (result2 == count2 and result == count)) )	// ignore the outcome of this alliance
-							{
-								createAlliance(me,count);
-								allianceTime[count] = gameTime;
-							}
-						}
-						result2 = result2 + 1;
-					}
-					result = result + 1;
-				}
-			}
-
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// Consolidate Rules
-
-// bring forces back together to consolidate attacks
-event consolidateEvent(consolidateEventTr)
-{
-	if(not helpingAlly())
-	{
-		if(random(3) == 1)				// order all droids home to rejoin forces.!
-		{
-			// find a place with no structures nearby
-			buildX = baseX;
-			buildY = baseY;
-			pickStructLocationB(powGen, ref buildX, ref buildY, me, 0);
-
-			orderGroupLoc(scoutGroup, DORDER_MOVE,buildX,buildY);
-			orderGroupLoc(defendGroup, DORDER_MOVE,buildX,buildY);
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// vtols.
-/////////////////////////////////////////////////////////////////////
-// build vtol strucutures.
-event vtolStructs(inactive)
-{
-	local	int		_numVtolFacs,_numRearmPads;
-
-	// got any idle trucks?
-	if (idleGroup(buildGroup) < 1)
-	{
-		exit;
-	}
-
-	// see how many vtol factories we already have
-	_numVtolFacs = getNumStructures(vtolFactory,me);
-	_numRearmPads = getNumStructures(vtolPad,me);
-
-	//see if we have enough rearm pads
-	if( _numRearmPads * 4 / 3 <= totalVtols() )
-	{
-		dbg("NEED REARM PADS", me);
-		buildRearmPads();
-	}
-
-	if (_numVtolFacs > 0 and playerPower(me) < LOW_POWER)
-	{
-		exit;	// Throttle expansion to avoid waste
-	}
-
-	if (isStructureAvailable(vtolFactory, me) and _numVtolFacs < maxVtolFacs[curTech])			// if not enough
-	{
-		if (not grabTrucksAndBuild(8, vtolFactory, 1))
-		{
-			dbgPlr("Wanted to build VTOL Factory but could not");
-		}
-	}
-}
-
-//counts vtols
-function int totalVtols()
-{
-	local	int		_vtolGroup,_totalVtols;
-
-	_totalVtols = 0;
-	_vtolGroup = 0;
-	while(_vtolGroup < numVtolAttackGroups)
-	{
-		_totalVtols = _totalVtols + vtolAttackGr[_vtolGroup].members;
-		_vtolGroup++;
-	}
-
-	_totalVtols = _totalVtols + vtolDefendGr.members;
-
-	return _totalVtols;
-}
-
-function void buildRearmPads()
-{
-	if (isStructureAvailable(vtolPad, me))
-	{
-		if (not grabTrucksAndBuild(4, vtolPad, -1))
-		{
-			dbgPlr("Wanted to build VTOL rearm pad, but could not");
-		}
-	}
-}
-
-
-/////////////////////////////////////////////////////////////////////
-// build vtols.
-
-event buildVtols(inactive)
-{
-	// got enough vtols?
-	if((vtolDefendGr.members >= maxVTOLs[curTech]) or (getDroidCount(me) >= MAX_DROIDS)){
-		dbg("CAN'T BUILD VTOLS - TOO MANY UNITS", me);
-		exit;
-	}
-
-	// build vtols
-	initEnumStruct(FALSE,vtolFactory,me,me);
-	structure = enumStruct();
-	while(structure != NULLOBJECT)
-	{
-		if(structureIdle(structure))	// if factory idle
-		{
-			vtolFactoryBuildVtol(structure);
-		}
-
-		structure = enumStruct();
-	}
-}
-
-function void vtolFactoryBuildVtol(STRUCTURE _factory)
-{
-	local	TEMPLATE	_newTemplate;
-	local	BODY		_bestBody;
-	local	WEAPON		_bestWeapon;
-	local	int		_rand, _idx;
-
-	if (_factory == NULLOBJECT or not structureIdle(_factory))
-	{
-		return;
-	}
-
-	// choose branch: AT, AS or splash
-	_rand = random(3);
-	_idx = 0;
-	_bestWeapon = NULLSTAT;
-	if (_rand == 0)	// anti-tank
-	{
-		_idx = numAtWeapons - 1;
-		while (_idx >= 0 and _bestWeapon == NULLSTAT)
-		{
-			if (isComponentAvailable(me, atWeapon[_idx]))
-			{
-				_bestWeapon = atWeapon[_idx];
-			}
-			_idx--;
-		}
-	}
-	if (_rand == 1)	// anti-structure
-	{
-		_idx = numAsWeapons - 1;
-		while (_idx >= 0 and _bestWeapon == NULLSTAT)
-		{
-			if (isComponentAvailable(me, asWeapon[_idx]))
-			{
-				_bestWeapon = asWeapon[_idx];
-			}
-			_idx--;
-		}
-	}
-	if (_rand < 2 and _bestWeapon == NULLSTAT)
-	{
-		_rand = 2;	// try this instead
-	}
-	if (_rand == 2)	// indiscriminate mass destruction
-	{
-		_idx = numMdWeapons - 1;
-		while (_idx >= 0 and _bestWeapon == NULLSTAT)
-		{
-			if (isComponentAvailable(me, mdWeapon[_idx]))
-			{
-				_bestWeapon = mdWeapon[_idx];
-			}
-			_idx--;
-		}
-	}
-	if (_bestWeapon == NULLSTAT)
-	{
-		dbgPlr("Failed to find a weapon for VTOL design");
-		return;
-	}
-	_bestBody = NULLSTAT;
-	if (not seenAnyAA)
-	{
-		// no AA seen, so go for the cheapest bodies -- no need for defense yet!
-		if (isComponentAvailable(me, bugBody))
-		{
-			_bestBody = bugBody;
-		}
-		else if (isComponentAvailable(me, viperBody))
-		{
-			_bestBody = viperBody;
-		}
-	}
-	else
-	{
-		// build sturdiest body available with a decent engine
-		if (isComponentAvailable(me, retributionBody))
-		{
-			_bestBody = retributionBody;
-		}
-		else
-		{
-			if (isComponentAvailable(me, scorpionBody))
-			{
-				_bestBody = scorpionBody;
-			}
-			else if (isComponentAvailable(me, cobraBody))
-			{
-				_bestBody = cobraBody;
-			}
-		}
-	}
-	if (_bestBody == NULLSTAT or getBodySize(_bestBody) > skGetFactoryCapacity(_factory))
-	{
-		dbgPlr("Failed to find a viable body for VTOL design");
-		return;
-	}
-
-	_newTemplate = assembleWeaponTemplate(me, _bestBody, vtolPropulsion, _bestWeapon);
-
-	if (_newTemplate == NULLTEMPLATE or not skCanBuildTemplate(me, _factory, _newTemplate))
-	{
-		dbgPlr("Failed to construct viable VTOL template");
-		return;
-	}
-	buildDroid(_newTemplate, _factory, me, 1);
-}
-
-/////////////////////////////////////////////////////////////////////
-// attack with vtols.
-
-event vtolAttack(inactive)
-{
-	local		int			_groupIndex,_newTargetWeight,_oldTargetWeight;
-	local		BASEOBJ		_newTarget;
-	local		bool		_bHaveDefendTarget;
-	local		DROID		_droid;
-
-	// if vtol group is not busy..
-	if(  (idleGroup(vtolDefendGr) >= (vtolDefendGr.members / 2)) and (vtolDefendGr.members >= 2) )
-	{
-		if(attackObj != NULLOBJECT)
-		{
-			if(!friendlyPlayer(attackObj.player))
-			{
-				orderGroupObj(vtolDefendGr, DORDER_ATTACK, attackObj);	// get the attack target.
-			}
-			else
-			{
-				attackObj = NULLOBJECT;
-			}
-		}
-		else
-		{
-			if(defendObj != NULLOBJECT)
-			{
-				if(not isHumanPlayer(defendObj.player) )	// new in wdg1 	//TODO:is this check needed?
-				{
-					orderGroupObj(vtolDefendGr, DORDER_ATTACK,defendObj);		// get the defend target
-				}
-			}
-		}
-	}
-
-	//make sure attack vtol groups are not cluttered
-	rearrangeAttackVtols();
-
-	//attack vtols
-	_groupIndex = 0;
-	while(_groupIndex < numVtolAttackGroups)
-	{
-		if(vtolAttackGr[_groupIndex].members > 0)
-		{
-			// if our base is in trouble see if we have a target in the base
-			// don't choose new target if already have one
-			_bHaveDefendTarget = FALSE;
-			if((vtolGrAttackObj[_groupIndex] != NULLOBJECT))
-			{
-				if(defendingOwnBase() and
-					(distBetweenTwoPoints(baseX, baseY, vtolGrAttackObj[_groupIndex].x, vtolGrAttackObj[_groupIndex].y) <= MAX_VTOL_DEFEND_RADIUS))
-				{
-					_bHaveDefendTarget = TRUE;
-				}
-				else	//reset target if it's not worth it
-				{
-					//we don't want to attack enemy heavy tanks outside of our base
-					if(vtolGrAttackObj[_groupIndex].type == OBJ_DROID)
-					{
-						_droid = objToDroid(vtolGrAttackObj[_groupIndex]);
-						if(_droid.droidType != DROID_CONSTRUCT)
-						{
-							vtolGrAttackObj[_groupIndex] = NULLOBJECT;	//reset target
-							_bHaveDefendTarget = FALSE;
-						}
-					}
-				}
-			}
-
-			//find target in our base if our base is in trouble
-			if(!_bHaveDefendTarget and defendingOwnBase())
-			{
-				vtolGrAttackObj[_groupIndex] = chooseVtolDefenceTarget(baseX, baseY, MAX_VTOL_DEFEND_RADIUS, FALSE);
-
-				if(vtolGrAttackObj[_groupIndex] != NULLOBJECT)
-				{
-					dbg("assigned new defence target for group " & _groupIndex, me);
-					_bHaveDefendTarget = TRUE;
-				}
-			}
-
-			//attack rules
-			if(!_bHaveDefendTarget and (idleGroup(vtolAttackGr[_groupIndex]) >= (vtolAttackGr[_groupIndex].members / 2)) and
-			(vtolAttackGr[_groupIndex].members >= (numAttackVtols * 2 / 3)))
-			{
-				_newTarget = NULLOBJECT;
-
-				//reset attack targets once in a while
-				if(vtolGrAttackObj[_groupIndex] != NULLOBJECT)
-				{
-					if(random(10) > 7)
-					{
-						vtolGrAttackObj[_groupIndex] = NULLOBJECT;
-					}
-				}
-
-				//now try to find an attack target if we have no defence target
-				//find best attack target
-				_newTarget = chooseVtolTarget(TRUE);	//search for an exclusive target
-				if(_newTarget == NULLOBJECT)
-				{
-					_newTarget = chooseVtolTarget(FALSE);	//search for any target
-				}
-
-				_newTargetWeight = getVtolTargetWeight(_newTarget);
-				_oldTargetWeight = getVtolTargetWeight(vtolGrAttackObj[_groupIndex]);
-
-				// new one or a much better one
-				if((_newTargetWeight >= (_oldTargetWeight + 20)) or
-					(vtolGrAttackObj[_groupIndex] == NULLOBJECT ))
-				{
-					dbg("choosing new attack object for " & _groupIndex, me);
-					vtolGrAttackObj[_groupIndex] = _newTarget;
-				}
-			}
-
-			//see if this group has something to attack
-			if(vtolGrAttackObj[_groupIndex] != NULLOBJECT)
-			{
-				if(!friendlyPlayer(vtolGrAttackObj[_groupIndex].player))
-				{
-					dbg("VTOL Group " & _groupIndex & " attacking", me);
-
-					if(_DEBUG and (_groupIndex == 0))
-					{
-						dropBeacon(getPlayerName(me), me, me, vtolGrAttackObj[_groupIndex].x, vtolGrAttackObj[_groupIndex].y, 0);
-					}
-
-					orderGroupObj(vtolAttackGr[_groupIndex], DORDER_ATTACK, vtolGrAttackObj[_groupIndex]);
-				}
-				else
-				{
-					vtolGrAttackObj[_groupIndex] = NULLOBJECT;
-				}
-			}
-		}
-
-		_groupIndex++;
-	}
-}
-
-//make sure vtol groups are not cluttered
-function void rearrangeAttackVtols()
-{
-	local	int		_emptyGr,_fillGr;
-	local	DROID	_droid;
-
-	_emptyGr = 0;
-	while(_emptyGr < numVtolAttackGroups)
-	{
-		if((vtolAttackGr[_emptyGr].members < numAttackVtols) and	//this group is not full
-			(vtolAttackGr[_emptyGr].members > 0))
-		{
-			//try to make full groups by moving vtols from the last groups
-			_fillGr = _emptyGr + 1;	//start from the next group
-			while((_fillGr < numVtolAttackGroups) and
-				(vtolAttackGr[_emptyGr].members < numAttackVtols))
-			{
-				initIterateGroup(vtolAttackGr[_fillGr]);
-				_droid = iterateGroup(vtolAttackGr[_fillGr]);
-				while((_droid != NULLOBJECT) and
-					(vtolAttackGr[_emptyGr].members < numAttackVtols))
-				{
-					groupAddDroid(vtolAttackGr[_emptyGr], _droid);	//refill the group
-					_droid = iterateGroup(vtolAttackGr[_fillGr]);
-				}
-
-				_fillGr++;
-			}
-		}
-		_emptyGr++;
-	}
-}
-
-function BASEOBJ chooseVtolDefenceTarget(int _x, int _y, int _range, bool bExclusiveTarget)
-{
-	local	BASEOBJ		_target;
-
-	_target = getClosestEnemy(_x, _y, _range, FALSE, FALSE, me);
-
-	// make sure no one else is targeting it already if we want exclusive targets
-	if(bExclusiveTarget and vtolTargetAssigned(_target))
-	{
-		_target = NULLOBJECT;
-	}
-
-	return _target;
-}
-
-function BASEOBJ chooseVtolTarget(bool bExclusiveTarget)
-{
-	local 	int				_structTypeIndex,_enemy;
-	local	int				_bestScore,_tempScore;
-	local	BASEOBJ			_bestTarget;
-	local	STRUCTURE		_structure;
-
-	_bestScore = 0;
-	_bestTarget = NULLOBJECT;
-
-	_enemy = 0;
-	while(_enemy < MAX_PLAYERS)
-	{
-		if(!friendlyPlayer(_enemy))
-		{
-			_structTypeIndex = 0;
-			while(_structTypeIndex < numVtolTargets)
-			{
-				initEnumStruct(FALSE,vtolTarget[_structTypeIndex],_enemy,me);
-				_structure = enumStruct();
-				while(_structure != NULLOBJECT)
-				{
-
-					// in case we don't want all groups to attack the same target
-					if(not (bExclusiveTarget and vtolTargetAssigned(_structure)) )
-					{
-						_tempScore = getVtolTargetWeight(_structure);
-
-						//see if this one is better
-						if(_tempScore > _bestScore)
-						{
-							_bestScore = _tempScore;
-							_bestTarget = _structure;
-						}
-					}
-
-					_structure = enumStruct();
-				}
-
-				_structTypeIndex++;
-			}
-		}
-		_enemy++;
-	}
-
-	return _bestTarget;
-}
-
-function int getVtolTargetWeight(BASEOBJ _target)
-{
-	local 	int 		_AAPenalty,_numAA,_range,_targetWeight;
-	local 	int 		_targetType;
-	local	STRUCTURE	_structTarget;
-
-	if(_target == NULLOBJECT)
-	{
-		return 0;
-	}
-
-	if(_target.type != OBJ_STRUCTURE)
-	{
-		return 0;
-	}
-
-	_structTarget = objToStructure(_target);
-
-	_targetWeight = 0;
-
-	_AAPenalty = 9;			//penalty per aa defense
-	_range = AA_THREAT_RANGE;
-
-	// count enemy AA
-	_numAA = numEnemyAAInRange(_structTarget.x, _structTarget.y, _range);
-
-	// find tyrget type from stats
-	_targetType = 0;
-	while(_targetType < numVtolTargets)
-	{
-		if(_structTarget.stat == vtolTarget[_targetType])
-		{
-			_targetWeight = vtolTargetWeight[_targetType] - (_numAA * _AAPenalty);
-
-			_targetType = numVtolTargets;	//exit loop
-		}
-		_targetType++;
-	}
-
-	// incomplete structures get lower weight
-	if(!structureComplete(_structTarget))
-	{
-		_targetWeight = _targetWeight / 10;
-	}
-
-	return _targetWeight;
-}
-
-event checkForHostileAA(hostileAATr)
-{
-	local	int	_enemy, _numAA;
-
-	_numAA = 0;
-	_enemy = 0;
-	while (_enemy < MAX_PLAYERS)
-	{
-		if (!friendlyPlayer(_enemy))
-		{
-			_numAA = _numAA + numAAinRange(_enemy, me, baseX, baseY, -1);
-			if (_numAA > 0)
-			{
-				seenAnyAA = true;
-				exit;
-			}
-		}
-		_enemy++;
-	}
-	if (_numAA == 0)
-	{
-		seenAnyAA = false;
-	}
-}
-
-function int numEnemyAAInRange(int _x, int _y, int _range)
-{
-	local int _enemy,_numAA;
-
-	_numAA = 0;
-	_enemy = 0;
-	while(_enemy < MAX_PLAYERS)
-	{
-		if(!friendlyPlayer(_enemy))
-		{
-			_numAA = _numAA + numAAinRange(_enemy, me, _x, _y, _range);
-		}
-		_enemy++;
-	}
-
-	return _numAA;
-}
-
-// see if a particular target is already assigned to one of the VTOL attack groups
-function bool vtolTargetAssigned(BASEOBJ _target)
-{
-	local int _groupIndex;
-
-	if(_target == NULLOBJECT)
-	{
-		return FALSE;
-	}
-
-	_groupIndex = 0;
-	while(_groupIndex < numVtolAttackGroups)
-	{
-		if(_target == vtolGrAttackObj[_groupIndex])
-		{
-			return TRUE;
-		}
-
-		_groupIndex++;
-	}
-
-	return FALSE;
-}
-
-/////////////////////////////////////////////////////////////////////
-// watch for incoming vtols
-event vtolDefend(vtolDefendTr)
-{
-	local	int		_numBuilders,_maxBuilders;
-	local bool boolResult;
-
-	if(baseobj != NULLOBJECT)
-	{
-		if(baseobj.type == OBJ_DROID)
-		{
-			if(isVtol(objToDroid(baseobj)))
-			{
-				_numBuilders = 0;
-				_maxBuilders = 2;
-
-				// build defenses.
-				initIterateGroup(buildGroup);		// find idle droids in build group.
-				droid = iterateGroup(buildGroup);
-				while( droid != NULLOBJECT)
-				{
-					if( (structure != NULLOBJECT) and (droid.order != DORDER_BUILD) )
-					{
-						buildX = structure.x;
-						buildY = structure.y;
-
-						//find best defense we can build.
-						count = 0;
-						count2 = -1;
-						while (count < 6)
-						{
-							if(isStructureAvailable(vtolDefStruct[count],me))
-							{
-								count2 = count;
-							}
-							count = count + 1;
-						}
-						if(count2 != (-1) )
-						{
-							boolResult = pickDroidStructLocation(droid, vtolDefStruct[count2], ref buildX, ref buildY, me, 1);
-							if (boolResult == TRUE and (_numBuilders < _maxBuilders))	// build a vtol defense near the attacked struct...
-							{
-								orderDroidStatsLoc(droid, DORDER_BUILD,vtolDefStruct[count2],buildX,buildY);
-								_numBuilders++;
-							}
-						}
-
-					}
-					droid = iterateGroup(buildGroup);
-				}
-			}
-		}
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-event vtolEnabler(vtolEnablerTr)
-{
-	if( skVtolEnableCheck(me) )					// check to see if we have vtol technologies.
-	{
-		setEventTrigger(vtolEnabler,inactive);		// turn off this event.
-		setEventTrigger(vtolStructs,vtolStructsTr);	// activate other vtol functions..
-		setEventTrigger(buildVtols,	buildVtolsTr);
-		setEventTrigger(vtolAttack,	vtolAttackTr);
-		dbg("----I CAN USE VTOLS----", me);
-	}
-}
-
-/////////////////////////////////////////////////////////////////////
-// HouseKeeping
-
-function void shutDownAI()
-{
-	bRunning = false;
-
-	setEventTrigger(basedetails,	inactive);
-	setEventTrigger(buildDerrick,	inactive);
-	setEventTrigger(buildOilDefenseOrRetreat,	inactive);
-	setEventTrigger(incendry,	inactive);
-	setEventTrigger(buildPowerGenerators,	inactive);
-	setEventTrigger(buildExpand,inactive);
-	setEventTrigger(newfortify,	inactive);
-	setEventTrigger(droidBuiltAssign, inactive);
-	setEventTrigger(droidBuilt,	inactive);
-	setEventTrigger(structBuilt,inactive);
-	setEventTrigger(droidDestroyed,inactive);
-	setEventTrigger(conDroids,inactive);
-	setEventTrigger(repairDroids,inactive);
-	setEventTrigger(factoryEvent,	inactive);
-	setEventTrigger(cyborgFactoryEvent,	inactive);
-	setEventTrigger(chooseScoutArea,	inactive);
-	setEventTrigger(expandScoutArea,	inactive);
-	setEventTrigger(scoutMain,	inactive);
-	setEventTrigger(newObjectReport,	inactive);
-	setEventTrigger(takeover,	inactive);
-	setEventTrigger(takeoverDefend,	inactive);
-	setEventTrigger(useLassat,	inactive);
-	setEventTrigger(findEnemy,	inactive);
-	setEventTrigger(attackStuff,	inactive);
-	setEventTrigger(defendWatch,	inactive);
-	setEventTrigger(defendReturn,	inactive);
-	setEventTrigger(doResearch,	inactive);
-	setEventTrigger(formAllianceEvent,	inactive);
-	setEventTrigger(breakAllianceEvent,	inactive);
-	setEventTrigger(formHumanAlliances,	inactive);
-	setEventTrigger(consolidateEvent,	inactive);
-	setEventTrigger(vtolStructs,inactive);
-	setEventTrigger(buildVtols,inactive);
-	setEventTrigger(vtolAttack,inactive);
-	setEventTrigger(vtolDefend,inactive);
-	setEventTrigger(vtolEnabler,inactive);
-	setEventTrigger(beaconEv,	inactive);
-	setEventTrigger(multiMsgEv,	inactive);
-	setEventTrigger(manageAllyHelp,	inactive);
-	setEventTrigger(everySecEv,	inactive);
-	setEventTrigger(watchBaseThreat, inactive);
-	setEventTrigger(manageDefendLocationEv,	inactive);
-	setEventTrigger(structureDestroyed,inactive);
-	setEventTrigger(rebuildStructureEv,inactive);
-	setEventTrigger(startLevel, inactive);
-	setEventTrigger(arrived, inactive);
-	setEventTrigger(checkActivities, inactive);
-}
-
-function void reassignAI()
-{
-	bRunning = true;
-
-	setEventTrigger(basedetails,basedetailsTr);
-	setEventTrigger(buildDerrick, inactive);
-	setEventTrigger(buildOilDefenseOrRetreat, inactive);
-	setEventTrigger(incendry, inactive);
-	setEventTrigger(buildPowerGenerators, inactive);
-	setEventTrigger(buildExpand, inactive);
-	setEventTrigger(newfortify, inactive);
-	setEventTrigger(droidBuiltAssign,droidBuiltTr);
-	setEventTrigger(droidBuilt,droidBuiltTr);
-	setEventTrigger(droidDestroyed,droidDestroyedTr);
-	setEventTrigger(conDroids,conDroidsTr);
-	setEventTrigger(repairDroids,repairDroidsTr);
-	setEventTrigger(factoryEvent,factoryEventTr);
-	setEventTrigger(cyborgFactoryEvent,cyborgFactoryEventTr);
-	setEventTrigger(chooseScoutArea,chooseScoutAreaTr);
-	setEventTrigger(expandScoutArea,expandScoutAreaTr);
-	setEventTrigger(scoutMain,scoutMainTr);
-	setEventTrigger(newObjectReport,newObjectReportTr);
-	setEventTrigger(takeover,takeoverTr);
-	setEventTrigger(useLassat,useLassatTr);
-	setEventTrigger(findEnemy,attackStuffTr);
-	setEventTrigger(attackStuff,attackStuffTr);
-	setEventTrigger(doAllOutAttack,allOutAttackTr);
-	setEventTrigger(defendWatch,defendWatchTr);
-	setEventTrigger(defendReturn,defendReturnTr);
-	setEventTrigger(doResearch,doResearchTr);
-	setEventTrigger(formAllianceEvent,formAllianceEventTr);
-	setEventTrigger(breakAllianceEvent,breakAllianceEventTr);
-	setEventTrigger(consolidateEvent,consolidateEventTr);
-	setEventTrigger(vtolStructs,inactive);
-	setEventTrigger(buildVtols,inactive);
-	//setEventTrigger(vtolAttack,inactive);
-	setEventTrigger(vtolAttack,	vtolAttackTr);
-	setEventTrigger(vtolDefend,vtolDefendTr);
-	setEventTrigger(vtolEnabler,vtolEnablerTr);
-	setEventTrigger(formHumanAlliances,humanAllianceTr);
-	setEventTrigger(multiMsgEv, multiMsgTr);
-	setEventTrigger(beaconEv, beaconTr);
-	setEventTrigger(watchBaseThreat, watchBaseThreatTr);
-	setEventTrigger(manageAllyHelp, manageAllyHelpTr);
-	setEventTrigger(everySecEv, everySec);
-	//setEventTrigger(manageDefendLocationEv, manageDefendLocationTr);
-	setEventTrigger(structBuilt, structBuiltTr);
-	setEventTrigger(structureDestroyed, structureDestroyedTr);
-	setEventTrigger(rebuildStructureEv, rebuildStructureTr);
-	setEventTrigger(startLevel, startLevelTr);
-	setEventTrigger(arrived, reachedTr);
-	setEventTrigger(checkActivities, checkActivitiesTr);
-}
-
-/* Returns true if we just received a beacon from a certain player */
-function bool haveBeacon(int _player)
-{
-		if((tBeacon[_player] > 0) and (not beaconTimeout(_player)))
-		{
-			return TRUE;	//have beacon for this player
-		}
-
-		return FALSE;
-}
-
-/* See if last beacon was placed long ago */
-function bool beaconTimeout(int _player)
-{
-	if((tBeacon[_player] > 0) and
-		((tBeacon[_player] + BEACON_TIMEOUT) < (gameTime / 10)))	//not too long ago
-	{
-		return TRUE;	//this beacon is still 'fresh'
-	}
-
-	return FALSE;
-}
-
-/* Deal with beacons */
-event beaconEv(beaconTr)
-{
-	local	int			_players;
-	local	string		_processedString;
-
-	if(_DEBUG)
-		debug(me & ") beaconEv: from " & sender);
-
-	ASSERT(sender >= 0 and sender < MAX_PLAYERS,
-		"beaconEv: sender out of bounds: " & sender , me);
-
-	beaconX[sender] = x;
-	beaconY[sender] = y;
-	tBeacon[sender] = gameTime / 10;
-
-	processCommand(message, sender, TRUE);
-}
-
-/* Deal with a chat message */
-event multiMsgEv(multiMsgTr)
-{
-	if(_DEBUG)
-		debug(me & ") multiMsgEv: from " & sender);
-
-	if(not allianceExistsBetween(me, sender)){
-		exit;
-	}
-
-	if(sender == me){
-		exit;
-	}
-
-	processCommand(message, sender, FALSE);
-}
-
-/* Process multiplayer messages */
-function void processCommand(string _message, int _sender, bool _bBlipMessage)
-{
-	local	int 		_numMsgs,_curMsg,_addressedPlayers,_x,_y;
-	local	string		_msg,_processedString;
-
-	/* Extract semantic information */
-	_curMsg = 0;
-	_numMsgs = processChatMsg(_message);
-
-	debug(me & ") processCommand: '" & _message & "' from " & _sender);
-	dbg("processCommand: '" & _message & "' from " & _sender, me);
-	dbg("got " & _numMsgs & " commands", me);
-
-	/* Process all messages */
-	while(_curMsg < _numMsgs)
-	{
-		if(chatCmdIsPlayerAddressed(_curMsg, me))
-		{
-			dbg("i'm addressed", me);
-			_msg = getChatCmdDescription(_curMsg);
-
-			/* Someone requested help */
-			if(_msg == R_REQUEST_HELP)
-			{
-				dbg("'help' command", me);
-
-				if(haveBeacon(_sender))
-				{
-					dbg("got beacon", me);
-
-					_x = beaconX[_sender];
-					_y = beaconY[_sender];
-
-					if(attemptToHelp(_sender, _x, _y))
-					{
-						messagePlayer(ALL_ALLIES, m_affirmative(), MAX_PROBABILITY);
-					}
-				}
-				else
-				{
-					/* Ask player to drop a beacon so we would know where to help */
-					_addressedPlayers = setBit(0, _sender, TRUE);
-					messagePlayerAddressed(ALL_ALLIES, _addressedPlayers, R_REQUEST_BEACON);
-				}
-			}
-			/* Someone requested a beacon from us -
-			 * did we request help and our beacon timed out??
-			 */
-			else if(_msg == M_REQUEST_BEACON)
-			{
-				/* If our base is really in trouble drop a beacon for the requester again */
-				if(baseInTrouble()){
-					dropBeacon(getPlayerName(me), _sender, me, baseX, baseY, 0);
-				}
-			}
-			else if(_msg == R_REPORT_SAFETY)
-			{
-				dbg("helping " & lastHelpPlayer, me);
-
-				/* Make sure we were helping him */
-				if(helpingAlly() and (lastHelpPlayer == _sender))
-				{
-					stopHelpingAlly();
-					messagePlayer(ALL_ALLIES, m_affirmative(), MAX_PROBABILITY);
-				}
-				else if(defendingOwnBase())	//if we are in trouble re-request help
-				{
-					requestHelp(baseX, baseY);
-				}
-			}
-			else
-			{
-				dbg("unknown message", me);
-			}
-
-		}
-		else
-		{
-			dbg("i'm not addressed", me);
-		}
-
-		_curMsg++;
-	}
-}
-
-function bool attemptToHelp(int _playerToHelp, int _x, int _y)
-{
-	local bool _bHelpingMyself;
-
-	if(_playerToHelp < 0 or _playerToHelp >= MAX_PLAYERS){
-		return FALSE;
-	}
-
-	if(_x <= 0 or _y <= 0){
-		return FALSE;
-	}
-
-	dbg("attemptToHelp - checking", me);
-
-	_bHelpingMyself = (_playerToHelp == me);
-
-	/* Can only help allies and myself */
-	if(not friendlyPlayer(_playerToHelp)){
-		return FALSE;
-	}
-
-	if(_bHelpingMyself or !helpingAlly() or (lastHelpPlayer == _playerToHelp) )	//if not helping any other ally or it's me who needs help
-	{
-		dbg("not busy helping", me);
-
-		if(haveHelpers() or _DEBUG)
-		{
-			dbg("got attackers", me);
-			helpPlayer(_playerToHelp, _x, _y);
-			return TRUE;
-		}
-		else
-		{
-			messagePlayer(ALL_ALLIES, M_HELP_NO_UNITS, MAX_PROBABILITY);
-		}
-	}
-	else if((lastHelpPlayer >= 0) and (lastHelpPlayer < MAX_PLAYERS))
-	{
-		if(!_bHelpingMyself){
-			messagePlayer(ALL_ALLIES, "helping " & getPlayerName(lastHelpPlayer) & " already", MAX_PROBABILITY);
-		}
-	}
-
-	return FALSE;
-}
-
-/* Start helping player */
-function void helpPlayer(int _playerToHelp, int _helpX, int _helpY)
-{
-	local int _tTravelTime;
-
-	dbg("helping " & _playerToHelp, me);
-
-	if(_DEBUG)
-		debug(me & ") helpPlayer: '" & _playerToHelp);
-
-	/* Move scoutes to attackers */
-	groupAddGroup(attackGroup, scoutGroup);
-
-	//Calculate travel time, assume ~ 150 tiles in 4 minutes
-	if(attackGroup.members == 0){
-		_tTravelTime = (int)((float)(distBetweenTwoPoints(baseX, baseY, _helpX, _helpY) / 128 ) * 1.7);
-	}else{
-		_tTravelTime = (int)((float)(distBetweenTwoPoints(attackGroup.x, attackGroup.y, _helpX, _helpY) / 128 ) * 1.7);
-	}
-
-	tHelp = gameTime / 10;
-	tHelpTimeout = (gameTime / 10) + BASE_DEFEND_DURATION + _tTravelTime;
-	lastHelpPlayer = _playerToHelp;
-	helpX = _helpX;
-	helpY = _helpY;
-
-	/* Scouts and attackers go to help */
-	defendLocation(_helpX, _helpY, tHelpTimeout, (_playerToHelp == me));
-}
-
-/* Returns a random affirmative responce */
-function string m_affirmative()
-{
-	local int _rnd;
-
-	_rnd = random(4);
-	if(_rnd == 3)
-	{
-		return M_AFFIRMATIVE_ROGER;
-	}
-
-	return M_AFFIRMATIVE_OK;
-}
-
-/* See if there are any base structures belonging to ally at a certain location */
-function bool allyBaseAtLoc(int _ally, int _x, int _y)
-{
-	local int _structIndex;
-
-	if(_x <= 0 or _y <= 0){
-		return FALSE;
-	}
-
-	if(_ally < 0 or _ally >= MAX_PLAYERS){
-		return FALSE;
-	}
-
-	_structIndex = 0;
-	while(_structIndex < numBaseStruct)
-	{
-		if(numStructsByStatInRange(baseStruct[_structIndex], _x, _y, (7 * 128), me, _ally) > 0 )
-		{
-			return TRUE;
-		}
-
-		_structIndex++;
-	}
-
-	return FALSE;
-}
-
-event manageAllyHelp(manageAllyHelpTr)
-{
-	if(helpingAlly())
-	{
-		if(canStopHelpingAlly())
-		{
-			stopHelpingAlly();
-		}
-	}
-}
-
-event everySecEv(everySec)
-{
-	/* Check if we were helping long enough */
-	if(helpingAlly())
-	{
-		if(helpAllyTimeout())
-		{
-			stopHelpingAlly();
-		}
-	}
-
-	if(defendingLocation())
-	{
-		if(defendLocationTimeout())
-		{
-			stopDefendingLocation();
-		}
-	}
-}
-
-/* Do we have any units we can send to help ally ? */
-function bool haveHelpers()
-{
-	if(attackGroup.members == 0){
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-function bool helpingAlly()
-{
-	if(lastHelpPlayer >= 0){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-/* Returns true if we were helping long enough */
-function bool helpAllyTimeout()
-{
-	if(tHelpTimeout < (gameTime / 10) ){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-function bool canStopHelpingAlly()
-{
-	if(lastHelpPlayer < 0)
-	{
-		ASSERT(FALSE, "canStopHelpingAlly: lastHelpPlayer < 0", me);
-		return TRUE;
-	}
-
-	/* Were helping long enough or someone's backstabbing */
-	if(!friendlyPlayer(lastHelpPlayer)){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-function void stopHelpingAlly()
-{
-	dbg("stopped helping", me);
-
-	tHelp = -1;
-	tHelpTimeout = -1;
-	lastHelpPlayer = -1;
-	helpX = -1;
-	helpY = -1;
-
-	stopDefendingLocation();
-}
-
-/* Send a multiplayer message to an ally */
-function void messagePlayer(int _playerToMessage, string _message, int _probability)
-{
-	local int	_player;
-
-	ASSERT(_playerToMessage >= -1 && _playerToMessage < MAX_PLAYERS,
-		"messagePlayer: player out of bounds: " & _playerToMessage, me);
-
-	// throw the dice
-	if( random(MAX_PROBABILITY) >= _probability ){
-		return;
-	}
-
-	_player = 0;
-	if(_playerToMessage == ALL_ALLIES)	//everyone
-	{
-		while(_player < MAX_PLAYERS)
-		{
-			/* Send message (allies only)) */
-			if(allianceExistsBetween(me, _player))
-			{
-				msg(_message, me, _player);
-			}
-
-			_player++;
-		}
-	}
-	else	//a certain player
-	{
-		/* Send message (allies only)) */
-		if(allianceExistsBetween(me, _playerToMessage))
-		{
-			msg(_message, me, _playerToMessage);
-		}
-	}
-}
-
-function int numBitsSet(int _integer)
-{
-	local	int		_position,_result;
-
-	_position = 0;
-	_result = 0;
-	while(_position < 8)
-	{
-		if(getBit(_integer, _position))
-		{
-			_result++;
-		}
-		_position++;
-	}
-
-	return _result;
-}
-
-/* Send a multiplayer message, addressing some player(s) */
-function void messagePlayerAddressed(int _playerToMessage, int _playersToAddress, string _message)
-{
-	local	int		_player,_totalAddressed,_curAddressed;
-	local	string	_adrMessage;
-
-	_totalAddressed = numBitsSet(_playersToAddress);
-
-	ASSERT(_totalAddressed > 0, "messagePlayerAddressed: no players addressed", me);
-
-	_adrMessage = " ";
-
-	_player = 0;
-	_curAddressed = 0;
-	while(_player < MAX_PLAYERS)
-	{
-		if(getBit(_playersToAddress, _player))
-		{
-			_curAddressed++;
-
-			_adrMessage = _adrMessage & getPlayerName(_player);
-
-			//if(_totalAddressed == 1){	//one only
-			//	_adrMessage = getPlayerName(_player);
-			//}else
-
-			if(_totalAddressed > 1)
-			{
-				if(_curAddressed == _totalAddressed){		//end
-					_adrMessage = _adrMessage & " and " & getPlayerName(_player);
-				}else{
-					_adrMessage = _adrMessage & ", " & getPlayerName(_player);
-				}
-			}
-
-		}
-		_player++;
-	}
-
-	_message = _adrMessage &  " " & _message;
-
-	//Now send the message to all players addressed
-	messagePlayer(_playerToMessage, _message, MAX_PROBABILITY);
-}
-
-/* Returns true if we can see our allies on the map */
-function bool canSeeAllies()
-{
-	local STRUCTURE _uplink;
-
-	/* Can see allies when team mode is on */
-	if(multiPlayerAlliancesType == ALLIANCES_TEAMS)
-	{
-		return TRUE;
-	}
-
-	/* Can see whole map if we have uplink */
-	_uplink = getStructure(uplink, me);
-	if(_uplink != NULLOBJECT)
-	{
-		/* Make sure finished building */
-		if(structureComplete(_uplink))
-		{
-			return TRUE;
-		}
-	}
-
-	return FALSE;
-}
-
-function bool defendingOwnBase()
-{
-	if(helpingAlly() && lastHelpPlayer == me){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-/* Call for help when our base is in danger */
-event watchBaseThreat(watchBaseThreatTr)
-{
-	/* See if we can stop defending */
-	if(defendingOwnBase())
-	{
-		if(numEnemiesInBase(FALSE) == 0)
-		{
-			stopHelpingAlly();	//stop defending our own base
-
-			/* Let allies know we don't need their help anymore */
-			messagePlayer(ALL_ALLIES, R_REPORT_SAFETY, MAX_PROBABILITY);
-			exit;
-		}
-	}
-
-	/* See if our base is in trouble and we need help */
-	if(baseInTrouble())
-	{
-		if(!defendingOwnBase())	//make sure not already defending the base
-		{
-			dbgPlr("Our base is in trouble!");
-
-			/* Bring our forces back if needed */
-			if(helpingAlly())
-			{
-				stopHelpingAlly();
-			}
-
-			/* Defend my own base */
-			helpPlayer(me, baseX, baseY);
-		}
-
-		/* Request help once in a while */
-		requestHelp(baseX, baseY);
-		exit;
-	}
-}
-
-function int numAlliesInBase(bool _bVtols)
-{
-	local int _numAllies;
-
-	_numAllies = numFriendlyWeapDroidsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, _bVtols);
-	_numAllies = _numAllies +
-					numFriendlyWeapStructsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, true) / 3;
-
-	return _numAllies;
-}
-
-function int numEnemiesInBase(bool _bVtols)
-{
-	local int _numEnemies;
-
-	_numEnemies = numEnemyWeapDroidsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, _bVtols);
-	_numEnemies = _numEnemies +
-				numEnemyWeapStructsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, true) / 4;
-
-	return _numEnemies;
-}
-
-/* Returns true if our base is in trouble */
-function bool baseInTrouble()
-{
-	local int _enemyForce,_friendlyForce;
-
-	_friendlyForce = numAlliesInBase(FALSE);
-	_enemyForce = numEnemiesInBase(FALSE);
-
-	/* See if we are in trouble */
-	if((_enemyForce > 0) && (_enemyForce >= _friendlyForce)){
-		dbg("baseInTrouble: " & _enemyForce & " >= " & _friendlyForce, me);
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-/* Request help from allies */
-function void requestHelp(int _helpX, int _helpY)
-{
-	/* Don't do this too frequently */
-	if(tLastHelpRequest + HELP_REQUEST_INTERVAL > (gameTime / 10) ){
-		return;
-	}
-
-	doRequestHelp(_helpX, _helpY);
-}
-
-function void doRequestHelp(int _helpX, int _helpY)
-{
-	local int _ally;
-
-	/* Remember when we requested help last time */
-	tLastHelpRequest = gameTime / 10;
-
-	/* Drop beacon for all allies so they would know where to help */
-	_ally = 0;
-	while(_ally < MAX_PLAYERS)
-	{
-		if(allianceExistsBetween(me, _ally)){
-			if(_DEBUG)
-				debug(me & ") requestHelp: " & _ally);
-
-			dropBeacon(getPlayerName(me), _ally, me, _helpX, _helpY, 0);
-		}
-		_ally++;
-	}
-
-	/* Now send message with help request */
-	messagePlayer(ALL_ALLIES, M_REQUEST_HELP, MAX_PROBABILITY);
-}
-
-function void defendLocation(int _defendX, int _defendY, int _tDefendTimeout, bool _bMove)
-{
-	local int defendRadius;
-
-	defendRadius = 15 * TILE;
-
-	dbg("starting defending for " & _tDefendTimeout - (gameTime / 10) & " secs, with defend radius " & defendRadius, me);
-
-	defendX = _defendX;
-	defendY = _defendY;
-
-	tDefendStart = gameTime / 10;
-
-	/* Should already include travel time */
-	tDefendTimeout = _tDefendTimeout;
-
-	/* See if we have to move or scout */
-	defendMoveType = DORDER_SCOUT;
-	if(_bMove){
-		defendMoveType = DORDER_MOVE;
-	}
-
-	/* Send attackers */
-	if(attackGroup.members > 0)
-	{
-		if(distBetweenTwoPoints(attackGroup.x, attackGroup.y, _defendX, _defendY) > defendRadius)
-		{
-			orderGroupLoc(attackGroup, defendMoveType, _defendX, _defendY);
-		}
-	}
-
-	setEventTrigger(manageDefendLocationEv,	manageDefendLocationTr);
-}
-
-function void stopDefendingLocation()
-{
-	dbg("stopped defending location", me);
-
-	defendX = -1;
-	defendY = -1;
-
-	tDefendStart = -1;
-	tDefendTimeout = -1;
-
-	defendMoveType = -1;
-
-	setEventTrigger(manageDefendLocationEv,	inactive);
-
-	orderGroupLoc(attackGroup, DORDER_SCOUT,baseX,baseY);
-}
-
-function bool defendingLocation()
-{
-	if(defendX > 0 and defendY > 0){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-event manageDefendLocationEv(inactive)
-{
-	local int defendRadius;
-	local DROID _droid;
-
-	if (not defendingLocation())
-	{
-		exit;
-	}
-
-	defendRadius = 15 * TILE;
-
-	dbg("manageDefendLocationEv", me);
-
-	ASSERT(defendMoveType == DORDER_MOVE || defendMoveType == DORDER_SCOUT,
-		"manageDefendLocationEv: wrong move order:" & defendMoveType, me);
-
-	ASSERT(defendX > 0 && defendY > 0,
-		"manageDefendLocationEv: x/y coordinates:" & defendX & "/" & defendY, me);
-
-	if(!(defendX > 0 && defendY > 0)){
-		dbg("not defending???????", me);
-		exit;		//not defending?
-	}
-
-	/* Collect attackers */
-	initIterateGroup(attackGroup);
-	_droid = iterateGroup(attackGroup);
-	while(_droid != NULLOBJECT)
-	{
-		if(distBetweenTwoPoints(_droid.x,_droid.y,defendX,defendY) > defendRadius)	//too far from defend location
-		{
-			if(distBetweenTwoPoints(_droid.orderx,_droid.ordery,defendX,defendY) > defendRadius)	//not already on its way to the defend location
-			{
-				orderDroidLoc(_droid, defendMoveType, defendX, defendY);
-			}
-		}
-		_droid = iterateGroup(attackGroup);
-	}
-}
-
-function bool defendLocationTimeout()
-{
-	if(tDefendTimeout < (gameTime / 10) ){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-/* Returns true if player in question is my ally or if it's me */
-function bool friendlyPlayer(int _playerToCheck)
-{
-	if(allianceExistsBetween(_playerToCheck, me) or (_playerToCheck == me)){
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-function bool insideBase(int _x, int _y)
-{
-	if(_x < minx){
-		return FALSE;
-	}
-
-	if(_x > maxx){
-		return FALSE;
-	}
-
-	if(_y < miny){
-		return FALSE;
-	}
-
-	if(_y > maxy){
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-//---------------------------------------------------------------
-//Returns how many droids are already on the way to build the
-//same structure on the same spot (like helpbuild)
-//---------------------------------------------------------------
-function int numBuildSameBuilding(STRUCTURESTAT _checkStat, int _x, int _y)
-{
-	local	int		_numSameBuilding;
-	local	DROID	_truck;
-
-	_numSameBuilding = 0;
-
-	initIterateGroup(buildGroup);
-	_truck = iterateGroup(buildGroup);
-	while(_truck != NULLOBJECT)
-	{
-		if((_truck.order == DORDER_BUILD) or (_truck.order == DORDER_HELPBUILD) or (_truck.order == DORDER_LINEBUILD))
-		{
-			if((_checkStat == NULLSTRUCTURESTAT) or (_truck.stat == _checkStat))	//Same struct type
-			{
-				//Within some range
-				if((_x < 0) or (distBetweenTwoPoints(_x, _y, _truck.orderx , _truck.ordery) <= TILE))
-				{
-					_numSameBuilding++;
-				}
-			}
-		}
-		_truck = iterateGroup(buildGroup);
-	}
-
-	return _numSameBuilding;
-}
-
-// returns number of droids in a certain group with the same order
-function int numGroupSameOrder(GROUP _group, int _orderIndex)
-{
-	local		int 		_numDroids;
-	local		DROID		_droid;
-
-	_numDroids = 0;
-
-	initIterateGroup(_group);
-	_droid = iterateGroup(_group);
-	while(_droid != NULLOBJECT)
-	{
-		if(_droid.order == _orderIndex)	//right order type
-		{
-			_numDroids++;
-		}
-		_droid = iterateGroup(_group);
-	}
-
-	return _numDroids;
-}
-
-// Remember certain destroyed structures so we can rebuild them later
-event structureDestroyed(structureDestroyedTr)
-{
-	local	int	_count;
-
-	// add certain structures to the rebuild list
-	_count = 0;
-	while(_count < numRebuildStat)
-	{
-		if(structure.stat == rebuildStat[_count])
-		{
-			if(countRebuildStruct < MAX_REBUILD_STRUCT)
-			{
-				rebuildStructX[countRebuildStruct] = structure.x;
-				rebuildStructY[countRebuildStruct] = structure.y;
-				rebuildStructStat[countRebuildStruct] = structure.stat;
-				countRebuildStruct++;
-
-				dbg("remembered structure (" & countRebuildStruct & ") - " & structure.x & "/" & structure.y, me);
-
-				exit;
-			}
-		}
-		_count++;
-	}
-}
-
-// Rebuild structures that were destroyed
-event rebuildStructureEv(rebuildStructureTr)
-{
-	rebuildStructures();
-}
-
-function void rebuildStructures()
-{
-	local	int				_count,_threatRange,_x,_y;
-	local	DROID			_truck;
-	local	STRUCTURESTAT	_stat;
-
-	_threatRange = (TILE * 8);
-
-	_count = 0;
-	while(_count < countRebuildStruct)
-	{
-		if(!threatInRange(me, rebuildStructX[_count], rebuildStructY[_count], _threatRange, FALSE))
-		{
-			if(getTileStructure(_x / TILE, _y  / TILE) == NULLOBJECT)
-			{
-				_stat = rebuildStructStat[_count];
-				_x = rebuildStructX[_count];
-				_y = rebuildStructY[_count];
-
-				if (isStructureAvailable(_stat, me))
-				{
-					_truck = closestIdleTruck(_x, _y);
-
-					if (_truck != NULLOBJECT)
-					{
-						if (numBuildSameBuilding(_stat, _x, _y) == 0)	//make sure no one is building already
-						{
-							buildOnExactLocation(_truck, _x, _y, _stat);
-						}
-					}
-				}
-			}
-		}
-		_count++;
-	}
-}
-
-function void buildOnExactLocation(DROID _truck, int _x, int _y, STRUCTURESTAT _stat)
-{
-	local	int	_newX,_newY;
-
-	if(_truck == NULLOBJECT)
-	{
-		return;
-	}
-
-	_newX = _x;
-	_newY = _y;
-
-	if (pickDroidStructLocation(_truck, _stat, ref _newX, ref _newY, me, -1))
-	{
-		dbg("trying to rebuild on (" & _newX & "/" & _newY & ")", me);
-
-		if ((_x != _newX) or (_y != _newY))
-		{
-			return;
-		}
-
-		orderDroidStatsLoc(_truck, DORDER_BUILD, _stat, _x, _y);
-	}
-}
-
-// Get idle truck closest to some location
-function DROID closestIdleTruck(int _x, int _y)
-{
-	local DROID _closestTruck, _tempTruck;
-	local int _closestDist, _tempDist;
-
-	_closestTruck = NULLOBJECT;
-	_closestDist = 99999;
-
-	initIterateGroup(buildGroup);
-	_tempTruck = iterateGroup(buildGroup);
-	while(_tempTruck != NULLOBJECT)
-	{
-		if((_tempTruck.order == DORDER_NONE) or (_tempTruck.order == DORDER_RTB))
-		{
-			_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y);
-			if(_tempDist < _closestDist)
-			{
-				_closestDist = _tempDist;
-				_closestTruck = _tempTruck;
-			}
-		}
-		_tempTruck = iterateGroup(buildGroup);
-	}
-
-	return _closestTruck;
-}
-
-event consoleEv(consoleTr)
-{
-	//turn on 'autogame'
-	if(message == "autogame on" && (sender == me))
-	{
-		if(debugModeEnabled())
-		{
-			if(myResponsibility(me))
-			{
-				if(not bRunning)		//make sure current machine is responsible for this AI and it's not already active
-				{
-					console(getPlayerName(me) & " is active");
-					reassignAI();
-					setEventTrigger(startLevel, chainloadTr);
-				}
-			}
-		}
-	}
-
-	//turn off 'autogames'
-	if(message == "autogame off" && debugModeEnabled()  && (sender == me))
-	{
-		if(bRunning)		//make sure this AI is active
-		{
-			console(getPlayerName(me) & " is deactivated");
-			
-			shutDownAI();
-		}
-	}
-
-	if(message == "aidebug on")
-	{
-		console(getPlayerName(me) & " ai debug is on");
-		_DEBUG = TRUE;
-		dbgMsgOn(me, _DEBUG);
-	}
-	else if(message == "aidebug off")
-	{
-		console(getPlayerName(me) & " ai debug is off");
-		_DEBUG = FALSE;
-		dbgMsgOn(me, _DEBUG);
-	}
-}
diff --git a/data/mp/multiplay/skirmish/semperfi.vlo b/data/mp/multiplay/skirmish/semperfi.vlo
deleted file mode 100644
index c3598b4..0000000
--- a/data/mp/multiplay/skirmish/semperfi.vlo
+++ /dev/null
@@ -1,381 +0,0 @@
-/////////////////////////////////////////////////////////////////////
-// ai for skirmish game
-/////////////////////////////////////////////////////////////////////
-
-script "semperfi.slo"
-run
-{
-	// general constants
-	numScouts	int					3			// min number of droids in group to aim for
-	maxScouts	int					3			// max number of droids in group to aim for
-	numCyborgs	int					8			// build cyborgs until scouts contains at least x droids
-	maxCyborgs	int					20			// build cyborgs until scouts contains max x droids
-
-	// research branches
-	branchDefault	int					0
-	branchVTOL	int					1
-
-	//default branch
-	numDefenders[0]	int					4
-	numAttackers[0]	int					8
-
-	//vtol branch
-	numDefenders[1]	int					12
-	numAttackers[1]	int					0
-	
-	//default branch
-	maxDefenders[0]	int					5
-	maxAttackers[0]	int					-1
-
-	//vtol branch
-	maxDefenders[1]	int					20
-	maxAttackers[1]	int					0
-	
-	tileExpand		int					12			// approx minutes to expand over the map.
-
-	/////////////////////////////////////////////////////////////////////
-	/////////////////////////////////////////////////////////////////////
-	// structures
-
- 	// generic names, often used.
-	oilRes			FEATURESTAT			"OilResource"
-	resLab			STRUCTURESTAT		"A0ResearchFacility"
-	powGen			STRUCTURESTAT		"A0PowerGenerator"
-	factory			STRUCTURESTAT		"A0LightFactory"
-	derrick			STRUCTURESTAT		"A0ResourceExtractor"
-	cybFactory		STRUCTURESTAT		"A0CyborgFactory"
-	playerHQ		STRUCTURESTAT		"A0CommandCentre"
-	vtolPad			STRUCTURESTAT		"A0VtolPad"
-	vtolFactory		STRUCTURESTAT		"A0VTolFactory1"
-	sensorTower		STRUCTURESTAT		"Sys-SensoTower02"
-	lassat			STRUCTURESTAT		"A0LasSatCommand"
-	nexusDefence		RESEARCHSTAT		"R-Sys-Resistance-Circuits"
-	uplink			STRUCTURESTAT		"A0Sat-linkCentre"
-
-	//how many res facilities to use when finished researching all specified research topics
-	maxIdleRes	int					-1
-
-	//number of research topics for each research branch
-	techCount[0]	int					19
-	
-	tech[0][0]		RESEARCHSTAT		"R-Defense-Tower01"		//mg guard tower
-	tech[0][1]		RESEARCHSTAT		"R-Wpn-MG3Mk1"			//HMG
-	tech[0][2]		RESEARCHSTAT		"R-Vehicle-Prop-Halftracks"	//Half-tracks
-	tech[0][3]		RESEARCHSTAT		"R-Struc-PowerModuleMk1"	//power module
-	tech[0][4]		RESEARCHSTAT		"R-Struc-Research-Module"	//research module
-	tech[0][5]		RESEARCHSTAT		"R-Struc-Factory-Module"	//factory module
-	tech[0][6]		RESEARCHSTAT		"R-Defense-WallTower01"		//heavy mg hardpoint
-	tech[0][7]		RESEARCHSTAT		"R-Wpn-Rocket02-MRL"		//mini rocket artillery
-	tech[0][8]		RESEARCHSTAT		"R-Wpn-Rocket-ROF03"		//Fast Fire Mini-Rockets Mk3
-	tech[0][9]		RESEARCHSTAT		"R-Wpn-MG-Damage03"		//APDSB MG Bullets Mk2
-	tech[0][10]		RESEARCHSTAT		"R-Vehicle-Metals02"		//composite alloys Mk2
-	tech[0][11]		RESEARCHSTAT		"R-Defense-Pillbox06"		//lancer tower
-	tech[0][12]		RESEARCHSTAT		"R-Defense-WallUpgrade01"	//impr hardcrete - in case missed
-	tech[0][13]		RESEARCHSTAT		"R-Struc-Materials01"		//reinf struc mat - in case missed
-	tech[0][14]		RESEARCHSTAT		"R-Struc-Power-Upgrade03a"	//power upgrade 03a
-	tech[0][15]		RESEARCHSTAT		"R-Sys-Sensor-Upgrade01"	//sensor upgrade
-	tech[0][16]		RESEARCHSTAT		"R-Vehicle-Prop-Hover"		//hover propulsion - for more options
-	tech[0][17]		RESEARCHSTAT		"R-Vehicle-Body08"		//scorpion body - for more options (eg new hover truck)
-	tech[0][18]		RESEARCHSTAT		"R-Struc-Research-Upgrade06"	//to dedicate one reslab to cerebral stuff
-
-	//other tech: R-Vehicle-Prop-VTOL, R-Struc-VTOLPad, R-Struc-VTOLFactory
-	techCount[1]	int					18
-	
-	tech[1][0]		RESEARCHSTAT		"R-Defense-Tower01"		//mg tower for early fun
-	tech[1][1]		RESEARCHSTAT		"R-Struc-Research-Module"	//reslab module
-	tech[1][2]		RESEARCHSTAT		"R-Struc-PowerModuleMk1"	//power module
-	tech[1][3]		RESEARCHSTAT		"R-Struc-VTOLFactory"		//rush vtols
-	tech[1][4]		RESEARCHSTAT		"R-Struc-VTOLPad"		//vtol pads
-	tech[1][5]		RESEARCHSTAT		"R-Wpn-Bomb04"			//thermite bomb - and we win
-	tech[1][6]		RESEARCHSTAT		"R-Vehicle-Prop-Halftracks"	//half-tracks - in case missed
-	tech[1][7]		RESEARCHSTAT		"R-Defense-AASite-QuadMg1"	//AA hurricane site
-	tech[1][8]		RESEARCHSTAT		"R-Defense-WallTower01"		//heavy mg hardpoint - in case missed
-	tech[1][9]		RESEARCHSTAT		"R-Defense-WallUpgrade01"	//impr hardcrete - in case missed
-	tech[1][10]		RESEARCHSTAT		"R-Struc-Materials01"		//reinf struc mat - in case missed
-	tech[1][11]		RESEARCHSTAT		"R-Vehicle-Body07"		//retribution body
-	tech[1][12]		RESEARCHSTAT		"R-Vehicle-Metals09"		//vtol armor
-	tech[1][13]		RESEARCHSTAT		"R-Struc-VTOLPad-Upgrade06"	//rearm
-	tech[1][14]		RESEARCHSTAT		"R-Struc-Factory-Upgrade04"	//production
-	tech[1][15]		RESEARCHSTAT		"R-Struc-Power-Upgrade03a"	//power upgrade 03a
-	tech[1][16]		RESEARCHSTAT		"R-Sys-Autorepair-General"	//autorepair
-	tech[1][17]		RESEARCHSTAT		"R-Vehicle-Engine09"		//finally - speed
-
-	maxVtolFacs[0]	int					1
-	maxVtolFacs[1]	int					4
-
-	maxVTOLs[0]		int					5
-	maxVTOLs[1]		int					70
-
-	// incendry emplacements.
-	numIncendrys	int					10
-	incendrys[0]	STRUCTURESTAT		"Emplacement-MortarPit01"
-	incendrys[1]	STRUCTURESTAT		"Emplacement-MortarPit02"
-	incendrys[2]	STRUCTURESTAT		"Emplacement-MortarPit-Incenediary"
-	incendrys[3]	STRUCTURESTAT		"Emplacement-RotMor"
-	incendrys[4]	STRUCTURESTAT		"Emplacement-Howitzer105"
-	incendrys[5]	STRUCTURESTAT		"Emplacement-Howitzer150"
-	incendrys[6]	STRUCTURESTAT		"Emplacement-Howitzer-Incenediary"
-	incendrys[7]	STRUCTURESTAT		"Emplacement-RotHow"
-	incendrys[8]	STRUCTURESTAT		"Emplacement-Rocket06-IDF"
-	incendrys[9]	STRUCTURESTAT		"Emplacement-HvART-pit"
-
-	//anti a.
-	vtolDefStruct[0] STRUCTURESTAT		"AASite-QuadMg1"	//1
-	vtolDefStruct[1] STRUCTURESTAT		"AASite-QuadBof" 	//2
-	vtolDefStruct[2] STRUCTURESTAT		"AASite-QuadRotMg"
-	vtolDefStruct[3] STRUCTURESTAT		"P0-AASite-SAM1" 	//3
-	vtolDefStruct[4] STRUCTURESTAT		"P0-AASite-SAM2"
-	vtolDefStruct[5] STRUCTURESTAT		"P0-AASite-Laser"
-
-	// upgrade structures
-	powModule		STRUCTURESTAT		"A0PowMod1"
-	facModule		STRUCTURESTAT		"A0FacMod1"
-	resModule		STRUCTURESTAT		"A0ResearchModule1"
-
- 	// Essential and fundamental structs. Fundamental => what you build on level start
-	numStructs		int					13
-	numFundamental		int					5
-	structs[0]		STRUCTURESTAT		"A0LightFactory"
-	structs[1]		STRUCTURESTAT		"A0ResearchFacility"
-	structs[2]		STRUCTURESTAT		"A0CommandCentre"
-	structs[3]		STRUCTURESTAT		"A0PowerGenerator"
-	structs[4]		STRUCTURESTAT		"A0CyborgFactory"
-
-	structs[5]		STRUCTURESTAT		"Sys-CB-Tower01"
-	structs[6]		STRUCTURESTAT		"Sys-SpyTower"
-
-	structs[7]		STRUCTURESTAT		"A0LasSatCommand"
-	structs[8]		STRUCTURESTAT		"A0Sat-linkCentre"
-	structs[9]		STRUCTURESTAT		"X-Super-Rocket"
-	structs[10]		STRUCTURESTAT		"X-Super-Cannon"
-	structs[11]		STRUCTURESTAT		"X-Super-MassDriver"
-	structs[12]		STRUCTURESTAT		"X-Super-Missile"
-
-	/* List what counts as base structures */
-	numBaseStruct	int					8
-	baseStruct[0]	STRUCTURESTAT		"A0PowerGenerator"
-	baseStruct[1]	STRUCTURESTAT		"A0LightFactory"
-	baseStruct[2]	STRUCTURESTAT		"A0CommandCentre"
-	baseStruct[3]	STRUCTURESTAT		"A0ResearchFacility"
-	baseStruct[4]	STRUCTURESTAT		"A0CyborgFactory"
-	baseStruct[5]	STRUCTURESTAT		"A0LasSatCommand"
-	baseStruct[6]	STRUCTURESTAT		"A0Sat-linkCentre"
-	baseStruct[7]	STRUCTURESTAT		"A0VTolFactory1"
-
-	// defensive structs.
-	numDefStructs	int					22
-	defStructs[0]	STRUCTURESTAT		"GuardTower1"
-	defStructs[1]	STRUCTURESTAT		"PillBox1"
-	defStructs[2]	STRUCTURESTAT		"Pillbox-RotMG"
-	defStructs[3]	STRUCTURESTAT		"GuardTower6"
-	defStructs[4]	STRUCTURESTAT		"PillBox4"		//LC
-	defStructs[5]	STRUCTURESTAT		"GuardTower5"		//Lancer
-	defStructs[6]	STRUCTURESTAT		"WallTower03"		//MC
-	defStructs[7]	STRUCTURESTAT		"WallTower04"		//HC
-	defStructs[8]	STRUCTURESTAT		"GuardTower5"		//Lancer
-
-	defStructs[9]	STRUCTURESTAT		"WallTower04"		//HC
-	defStructs[10]	STRUCTURESTAT		"WallTower-HPVcannon"
-	defStructs[11]	STRUCTURESTAT		"Emplacement-Howitzer105"
-	defStructs[12]	STRUCTURESTAT		"Emplacement-HvyATrocket"
-	defStructs[13]	STRUCTURESTAT		"Emplacement-MortarPit02"
-	defStructs[14]	STRUCTURESTAT		"WallTower06"
-	defStructs[15]	STRUCTURESTAT		"Emplacement-PulseLaser"	// Campaign 3 Defensive Structures
-	defStructs[16]	STRUCTURESTAT		"Emplacement-Rail2"
-
-	defStructs[17]	STRUCTURESTAT		"WallTower-HvATrocket"	//TK
-	defStructs[18]	STRUCTURESTAT		"WallTower-Atmiss"	//Scourge
-	defStructs[19]	STRUCTURESTAT		"WallTower-PulseLas"
-	defStructs[20]	STRUCTURESTAT		"WallTower-Rail2"
-	defStructs[21]	STRUCTURESTAT		"WallTower-Rail3"
-
-	// wall structs (4)
-	numWallWeaps	int					10
-	wall			STRUCTURESTAT		"A0HardcreteMk1Wall"
-	cornerWall		STRUCTURESTAT		"A0HardcreteMk1CWall"
-	wallWeaps[0]	STRUCTURESTAT		"WallTower01"
-	wallWeaps[1]	STRUCTURESTAT		"WallTower02"
-	wallWeaps[2]	STRUCTURESTAT		"WallTower03"
-	wallWeaps[3]	STRUCTURESTAT		"WallTower04"
-	wallWeaps[4]	STRUCTURESTAT		"WallTower06"
-	wallWeaps[5]	STRUCTURESTAT		"WallTower06"
-	wallWeaps[6]	STRUCTURESTAT		"WallTower-Rail2"
-	wallWeaps[7]	STRUCTURESTAT		"WallTower-PulseLas"
-	wallWeaps[8]	STRUCTURESTAT		"WallTower-Atmiss"
-	wallWeaps[9]	STRUCTURESTAT		"WallTower-HPVcannon"
-
-	/////////////////////////////////////////////////////////////////////
-	/////////////////////////////////////////////////////////////////////
-	// SKIRMISH TEMPLATES
-
-	// COMBAT TEMPLATES
-
-	//branchDefault
-	numTemplates	int			48
-	
-	tmpl[0]	TEMPLATE	"ViperMG01Wheels"		//MG
-	tmpl[1]	TEMPLATE	"ViperMG02Wheels"		//TMG
-	tmpl[2]	TEMPLATE	"ViperHMGWheels"		//HMG
-	tmpl[3]	TEMPLATE	"ViperPODWheels"		//POD
-	tmpl[4]	TEMPLATE	"ViperLtA-Twheels"		//Lancer
-	tmpl[5]	TEMPLATE	"ViperFlameWheels"		//Flamer
-	tmpl[6]	TEMPLATE	"ViperLtA-Twheels"		//Lancer
-	tmpl[7]	TEMPLATE	"CobraMRLHalftrack"		//MRL
-	tmpl[8]	TEMPLATE	"ViperLtCannonWheels"	//LC
-	tmpl[9]	TEMPLATE	"ViperPODWheels"		//POD
-	tmpl[10]	TEMPLATE	"ViperLtCannonHTracks"	//LC
-
-	tmpl[11]	TEMPLATE	"CobraLtA-Thalftrack"	//Lancer	HT
-	tmpl[12]	TEMPLATE	"CobraMRLHalftrack"		//MRL 	HT
-	tmpl[13]	TEMPLATE	"CobraInfernoHTracks"	//Inferno	HT
-	tmpl[14]	TEMPLATE	"SK-Cobra-Hover-Lancer"	//Lancer	H
-	tmpl[15]	TEMPLATE	"Sk-CobraBBHover"		//BB		H
-	tmpl[16]	TEMPLATE	"CobraMedCnTrks"		//MC		Tr
-	tmpl[17]	TEMPLATE	"SK-Cobra-Track-HVC"	//HVC	Tr
-	tmpl[18]	TEMPLATE	"CobraHvyCnTrks"		//HC		Tr
-
-	//Campaign 2
-	tmpl[19]	TEMPLATE	"PythonHoverHVC"		//HVC Hover
-	tmpl[20]	TEMPLATE	"SK-Cobra-Track-TK"
-	tmpl[21]	TEMPLATE	"Sk-PythonHvCanTrack"
-	tmpl[22]	TEMPLATE	"Sk-PythonHvCanTrack"
-
-	tmpl[23]	TEMPLATE	"SK-Panther-Hover-HVC"
-	tmpl[24]	TEMPLATE	"SK-Panther-Hover-TK"
-
-	tmpl[25]	TEMPLATE	"SK-Tiger-Track-Hcannon"
-	tmpl[26]	TEMPLATE	"SK-Tiger-Track-HVC"
-	tmpl[27]	TEMPLATE	"SK-Tiger-Track-Hcannon"
-	tmpl[28]	TEMPLATE	"SK-Tiger-Hover-TK"
-
-	//Campaign 3
-	tmpl[29]	TEMPLATE	"SK-Leopard-Htrk-Needle"
-	tmpl[30]	TEMPLATE	"SK-Tiger-Track-Hcannon"
-	tmpl[31]	TEMPLATE	"SK-Panther-Track-RailGun"
-	tmpl[32]	TEMPLATE	"SK-Panther-Hover-TK"
-	tmpl[33]	TEMPLATE	"SK-Tiger-Track-Scourge"
-	tmpl[34]	TEMPLATE	"SK-Tiger-Track-Gauss"
-	tmpl[35]	TEMPLATE	"SK-Tiger-Hover-Gauss"
-	tmpl[36]	TEMPLATE	"SK-Retre-Track-PulseLsr"
-	tmpl[37]	TEMPLATE	"SK-Retre-Track-FlashLight"
-
-	tmpl[38]	TEMPLATE	"SK-Retre-Track-RailGun"
-	tmpl[39]	TEMPLATE	"SK-Veng-Track-Scourge"
-	tmpl[40]	TEMPLATE	"SK-Retre-Hover-RailGun"
-	tmpl[41]	TEMPLATE	"SK-Retre-Track-Scourge"
-	tmpl[42]	TEMPLATE	"SK-Veng-Track-Gauss"
-	tmpl[43]	TEMPLATE	"SK-Veng-Hover-Gauss"
-	tmpl[44]	TEMPLATE	"SK-Veng-Track-PulseLsr"
-	tmpl[45]	TEMPLATE	"SK-Veng-Hover-Scourge"
-
-	tmpl[46]	TEMPLATE	"SK-Veng-Hover-Seraph"
-	tmpl[47]	TEMPLATE	"Dragon-Hover-SeraphGauss"
-
-	
-	/////////////////////////////////////////////////////////////////////
-	// SENSORS / REPAIR TEMPLATES
-
-	constructor	TEMPLATE	"ConstructorDroid"
-	hovertruck	TEMPLATE	"ScorpHoverTruck"
-	repairUnit	TEMPLATE	"ViperRepairHalftrack"
-
-	numSenseTemplates		int		10
-
-	//Campaign 1
-	sense[0]	TEMPLATE	"ViperRepairWheels"
-	sense[1]	TEMPLATE	"ViperRepairHalftrack"
-	sense[2]	TEMPLATE	"CobraSensorHalftrack"
-	//Campaign 2
-	sense[3]	TEMPLATE	"SK-Bug-Hover-Sensor"
-	sense[4]	TEMPLATE	"SK-Bug-Hover-Repair"
-	sense[5]	TEMPLATE	"SK-Leopard-Hover-Sensor"
-	sense[6]	TEMPLATE	"SK-Leopard-Hover-Repair"
-	sense[7]	TEMPLATE	"SK-Panther-Track-Repair"
-	//Campaign 3
-	sense[8]	TEMPLATE	"SK-Retal-Hover-Sensor"
-	sense[9]	TEMPLATE	"SK-Retal-Hover-Repair"
-
-	/////////////////////////////////////////////////////////////////////
-	// cyborg templates
-	numLightCyborgs	int			6
-	cybTempl[0]		TEMPLATE	"CyborgChain01Ground"
-	cybTempl[1]		TEMPLATE	"CyborgCannon01Grd"		//heavy gunner
-	cybTempl[2]		TEMPLATE	"CyborgFlamer01Grd"
-	cybTempl[3]		TEMPLATE	"CyborgRkt01Ground"
-	cybTempl[4]		TEMPLATE	"MP-Cyb-Needle-GRD"
-	cybTempl[5]		TEMPLATE	"MP-Cyb-Needle-GRD"
-	
-	cybMechanic		TEMPLATE	"Cyb-Mechanic"
-	cybEngineer		TEMPLATE	"Cyb-ComEng"
-
-	superCyb[0]		TEMPLATE	"Cyb-Hvy-Mcannon"
-	superCyb[1]		TEMPLATE	"Cyb-Hvy-HPV"
-	superCyb[2]		TEMPLATE	"Cyb-Hvy-Acannon"
-	superCyb[3]		TEMPLATE	"Cyb-Hvy-TK"
-
-	numVtolTargets		int				10
-	vtolTarget[0]		STRUCTURESTAT	"A0CommandCentre"
-	vtolTargetWeight[0]	int				10
-	vtolTarget[1]		STRUCTURESTAT	"A0LightFactory"
-	vtolTargetWeight[1]	int				80
-	vtolTarget[2]		STRUCTURESTAT	"A0CyborgFactory"
-	vtolTargetWeight[2]	int				60
-	vtolTarget[3]		STRUCTURESTAT	"A0VTolFactory1"
-	vtolTargetWeight[3]	int				100
-	vtolTarget[4]		STRUCTURESTAT	"A0LasSatCommand"
-	vtolTargetWeight[4]	int				90
-	vtolTarget[5]		STRUCTURESTAT	"A0Sat-linkCentre"
-	vtolTargetWeight[5]	int				10
-	vtolTarget[6]		STRUCTURESTAT	"A0ResearchFacility"
-	vtolTargetWeight[6]	int				10
-	vtolTarget[7]		STRUCTURESTAT	"A0PowerGenerator"
-	vtolTargetWeight[7]	int				15
-	vtolTarget[8]		STRUCTURESTAT	"A0ResourceExtractor"
-	vtolTargetWeight[8]	int				20
-	vtolTarget[9]		STRUCTURESTAT	"A0RepairCentre3"
-	vtolTargetWeight[9]	int				10
-	
-	
-	// Structure types AI will rebuild when they get destroyed
-	numRebuildStat		int				2
-	rebuildStat[0]		STRUCTURESTAT	"A0HardcreteMk1Wall"
-	rebuildStat[1]		STRUCTURESTAT	"A0HardcreteMk1CWall"
-
-	// propulsions
-	vtolPropulsion			PROPULSION	"V-Tol"
-	trackPropulsion			PROPULSION	"tracked01"
-	wheelPropulsion			PROPULSION	"wheeled01"
-	hoverPropulsion			PROPULSION	"hover01"
-	halftrackPropulsion		PROPULSION	"HalfTrack"
-
-	// bodies
-	bugBody				BODY		"Body4ABT"
-	viperBody			BODY		"Body1REC"
-	cobraBody			BODY		"Body5REC"
-	scorpionBody			BODY		"Body8MBT"
-	leopardBody			BODY		"Body2SUP"
-	pythonBody			BODY		"Body11ABT"
-	retributionBody			BODY		"Body7ABT"
-	tigerBody			BODY		"Body9REC"
-	vengeanceBody			BODY		"Body10MBT"
-	wyvernBody			BODY		"Body13SUP"
-	dragonBody			BODY		"Body14SUP"
-
-	// VTOL anti-tank weapons, in reverse order of priority
-	numAtWeapons			int		3
-	atWeapon[0]			WEAPON		"Rocket-VTOL-LtA-T"	// vtol lancer
-	atWeapon[1]			WEAPON		"Rocket-VTOL-HvyA-T"	// vtol tank-killer
-	atWeapon[2]			WEAPON		"Missile-VTOL-AT"	// vtol scourge
-
-	// VTOL anti-building weapons, in reverse order of priority
-	numAsWeapons			int		1
-	asWeapon[0]			WEAPON		"Rocket-VTOL-BB"	// vtol bunker-buster
-
-	// VTOL weapons of mass destruction, in reverse order of priority
-	numMdWeapons			int		3
-	mdWeapon[0]			WEAPON		"Bomb3-VTOL-LtINC"	// phosphor bomb
-	mdWeapon[1]			WEAPON		"Bomb4-VTOL-HvyINC"	// thermite bomb
-	mdWeapon[2]			WEAPON		"Bomb5-VTOL-Plasmite"	// plasmite bomb
-
-	/////////////////////////////////////////////////////////////////////
-}
