diff --git a/src/function.cpp b/src/function.cpp
index 74ed9e0..c86fda7 100644
--- a/src/function.cpp
+++ b/src/function.cpp
@@ -294,7 +294,7 @@ static bool loadReArmFunction(const char *pData)
 
 	//read the data in
 	functionName[0] = '\0';
-	sscanf(pData, "%255[^,'\r\n],%d", functionName, &psFunction->reArmPoints);
+	sscanf(pData, "%255[^,'\r\n],%d,%d", functionName, &psFunction->reArmPoints, &psFunction->repairPoints);
 
 	//allocate storage for the name
 	storeName((FUNCTION *)psFunction, functionName);
@@ -1046,6 +1046,22 @@ void structureReArmUpgrade(STRUCTURE *psBuilding)
 	        asReArmUpgrade[psBuilding->player].modifier) / 100;
 }
 
+void structureReArmRepairUpgrade(STRUCTURE *psBuilding)
+{
+	REARM_PAD					*pPad = &psBuilding->pFunctionality->rearmPad;
+	REPAIR_DROID_FUNCTION				*pRepairFunc;
+
+	//upgrade the repair points of a rearm pad
+	ASSERT(pPad != NULL, "structureReArmUpgrade: invalid ReArm pointer");
+
+	pRepairFunc = (REPAIR_DROID_FUNCTION *)psBuilding->pStructureType->asFuncList[0];
+	ASSERT(pRepairFunc != NULL,
+	       "structureRepairUpgrade: invalid Function pointer");
+	
+	pPad->repairPoints = pRepairFunc->repairPoints + (pRepairFunc->repairPoints *
+	        asRepairFacUpgrade[psBuilding->player].modifier) / 100;
+}
+
 void structurePowerUpgrade(STRUCTURE *psBuilding)
 {
 	POWER_GEN		*pPowerGen = &psBuilding->pFunctionality->powerGenerator;
diff --git a/src/function.h b/src/function.h
index 977b73d..ab26691 100644
--- a/src/function.h
+++ b/src/function.h
@@ -49,6 +49,7 @@ extern void structurePowerUpgrade(STRUCTURE *psBuilding);
 extern void structureRepairUpgrade(STRUCTURE *psBuilding);
 extern void structureSensorUpgrade(STRUCTURE *psBuilding);
 extern void structureReArmUpgrade(STRUCTURE *psBuilding);
+extern void structureReArmRepairUpgrade(STRUCTURE *psBuilding);
 extern void structureECMUpgrade(STRUCTURE *psBuilding);
 extern void sensorUpgrade(FUNCTION *pFunction, UBYTE player);
 extern void repairUpgrade(FUNCTION *pFunction, UBYTE player);
diff --git a/src/functiondef.h b/src/functiondef.h
index 244b661..f5058b6 100644
--- a/src/functiondef.h
+++ b/src/functiondef.h
@@ -125,6 +125,7 @@ struct RESEARCH_FUNCTION : public FUNCTION
 /*To rearm VTOLs*/
 struct REARM_FUNCTION : public FUNCTION
 {
+	uint32_t		repairPoints;	/*The number of repair points added per cycle*/
 	UDWORD			reArmPoints;	/*The number of reArm points added per cycle*/
 };
 
diff --git a/src/game.cpp b/src/game.cpp
index 85e1cae..7dbb1f5 100644
--- a/src/game.cpp
+++ b/src/game.cpp
@@ -4904,6 +4904,7 @@ static bool loadSaveStructure2(const char *pFileName, STRUCTURE **ppList)
 			break;
 		case REF_REARM_PAD:
 			psReArmPad = ((REARM_PAD *)psStructure->pFunctionality);
+			psReArmPad->repairPoints = ini.value("Rearm/repairPoints", psReArmPad->repairPoints).toInt();
 			psReArmPad->reArmPoints = ini.value("Rearm/reArmPoints", psReArmPad->reArmPoints).toInt();
 			psReArmPad->timeStarted = ini.value("Rearm/timeStarted", psReArmPad->timeStarted).toInt();
 			psReArmPad->timeLastUpdated = ini.value("Rearm/timeLastUpdated", psReArmPad->timeLastUpdated).toInt();
@@ -5145,6 +5146,7 @@ bool writeStructFile(const char *pFileName)
 				else if (psCurr->pStructureType->type == REF_REARM_PAD)
 				{
 					REARM_PAD *psReArmPad = ((REARM_PAD *)psCurr->pFunctionality);
+					ini.setValue("Rearm/repairPoints", psReArmPad->repairPoints);
 					ini.setValue("Rearm/reArmPoints", psReArmPad->reArmPoints);
 					ini.setValue("Rearm/timeStarted", psReArmPad->timeStarted);
 					ini.setValue("Rearm/timeLastUpdated", psReArmPad->timeLastUpdated);
diff --git a/src/research.cpp b/src/research.cpp
index 4a6327e..651232e 100644
--- a/src/research.cpp
+++ b/src/research.cpp
@@ -938,6 +938,11 @@ void researchResult(UDWORD researchIndex, UBYTE player, bool bDisplay, STRUCTURE
 						// upgrade the repair points
 						structureRepairUpgrade(psCurr);
 					}
+					if (psCurr->pStructureType->type == REF_REARM_PAD)
+					{
+						// upgrade the repair points of a rearm pad
+						structureReArmRepairUpgrade(psCurr);
+					}
 				}
 				// and the mission structure
 				for (psCurr = mission.apsStructLists[player]; psCurr != NULL; psCurr = psCurr->psNext)
@@ -947,6 +952,11 @@ void researchResult(UDWORD researchIndex, UBYTE player, bool bDisplay, STRUCTURE
 						// upgrade the repair points
 						structureRepairUpgrade(psCurr);
 					}
+					if (psCurr->pStructureType->type == REF_REARM_PAD)
+					{
+						// upgrade the repair points of a rearm pad
+						structureReArmRepairUpgrade(psCurr);
+					}
 				}
 				break;
 			case(WEAPON_UPGRADE_TYPE):
diff --git a/src/structure.cpp b/src/structure.cpp
index 876c55f..691a624 100644
--- a/src/structure.cpp
+++ b/src/structure.cpp
@@ -104,8 +104,6 @@
 
 //used to calculate the time required for rearming
 #define REARM_FACTOR                10
-//used to calculate the time  required for repairing
-#define VTOL_REPAIR_FACTOR          10
 
 //Value is stored for easy access to this structure stat
 UDWORD			factoryModuleStat;
@@ -2051,10 +2049,11 @@ static bool setFunctionality(STRUCTURE	*psBuilding, STRUCTURE_TYPE functionType)
 		{
 			REARM_PAD* psReArmPad = &psBuilding->pFunctionality->rearmPad;
 
-			psReArmPad->reArmPoints = ((REARM_PAD *)psBuilding->pStructureType->asFuncList[0])->reArmPoints;
-
+			psReArmPad->reArmPoints = ((REARM_FUNCTION *)psBuilding->pStructureType->asFuncList[0])->reArmPoints;
+			psReArmPad->repairPoints = ((REARM_FUNCTION *)psBuilding->pStructureType->asFuncList[0])->repairPoints;
 			// Take advantage of upgrades
 			structureReArmUpgrade(psBuilding);
+			structureReArmRepairUpgrade(psBuilding);
 			break;
 		}
 
@@ -3066,7 +3065,21 @@ static void aiUpdateStructure(STRUCTURE *psStructure, bool isMission)
 					{
 						psChosenObj = psDroid;
 					}
+					if (isVtolDroid(psDroid))
+					{
+						// for VTOLs just sitting on rearm pads, we repair them if they are damaged
+						// Check if the units is on the pad or not (within coordinates of center Â± 64)
+						// Note: This is NOT the same as 'distance to center is <= 64'!
+						xdiff = abs((SDWORD)psDroid->pos.x - (SDWORD)psStructure->pos.x);
+						ydiff = abs((SDWORD)psDroid->pos.y - (SDWORD)psStructure->pos.y);
+						if (xdiff <= 64 && ydiff <= 64 && psDroid->pos.z == psStructure->pos.z && psDroid->body < psDroid->originalBody)
+						{
+							psChosenObj = psDroid;
+						}
+					}
 				}
+			
+				
 				if (!psChosenObj) // None available? Try allies.
 				{
 					for (i=0; i<MAX_PLAYERS; i++)
@@ -3412,7 +3425,7 @@ static void aiUpdateStructure(STRUCTURE *psStructure, bool isMission)
 		{
 			REARM_PAD	*psReArmPad = &psStructure->pFunctionality->rearmPad;
 			UDWORD pointsAlreadyAdded;
-
+			
 			psDroid = (DROID *)psChosenObj;
 			ASSERT_OR_RETURN( , psDroid != NULL, "invalid droid pointer");
 			ASSERT_OR_RETURN( , isVtolDroid(psDroid), "invalid droid type");
@@ -3481,20 +3494,37 @@ static void aiUpdateStructure(STRUCTURE *psStructure, bool isMission)
 						}
 					}
 				}
+								
 				/* do repairing */
 				if (psDroid->body < psDroid->originalBody)
 				{
-					// Do not "simplify" this formula.
-					// It is written this way to prevent rounding errors.
-					pointsToAdd =  VTOL_REPAIR_FACTOR * (100+asReArmUpgrade[psStructure->player].modifier) * (gameTime -
-					               psReArmPad->timeStarted) / (GAME_TICKS_PER_SEC * 100);
-					pointsAlreadyAdded =  VTOL_REPAIR_FACTOR * (100+asReArmUpgrade[psStructure->player].modifier) * (psReArmPad->timeLastUpdated -
-					               psReArmPad->timeStarted) / (GAME_TICKS_PER_SEC * 100);
-
-					if ((pointsToAdd - pointsAlreadyAdded) > 0)
+				
+					//if in multiPlayer, and a Transporter - make sure its on the ground before repairing
+					if (bMultiPlayer && (psDroid->droidType == DROID_TRANSPORTER || psDroid->droidType == DROID_SUPERTRANSPORTER))
+					{
+						if (!(psDroid->sMove.Status == MOVEINACTIVE &&
+							psDroid->sMove.iVertSpeed == 0))
+						{
+							objTrace(psStructure->id, "Waiting for transporter to land");
+							return;
+						}
+					}
+
+					//don't do anything if the resistance is low in multiplayer
+					if (bMultiPlayer)
 					{
-						psDroid->body += (pointsToAdd - pointsAlreadyAdded);
+						if (psStructure->resistance < (SWORD)structureResistance(psStructure->
+							pStructureType, psStructure->player))
+						{
+							objTrace(psStructure->id, "Resistance too low for repair");
+							return;
+						}
 					}
+
+					// FIXME: duplicate code, make repairing cost power again
+					/* do repairing */
+					psDroid->body += gameTimeAdjustedAverage(psReArmPad->repairPoints);
+
 					if (psDroid->body >= psDroid->originalBody)
 					{
 						/* set droid points to max */
diff --git a/src/structuredef.h b/src/structuredef.h
index 6c971d9..67d36f7 100644
--- a/src/structuredef.h
+++ b/src/structuredef.h
@@ -222,6 +222,7 @@ struct REPAIR_FACILITY
 
 struct REARM_PAD
 {
+	uint32_t                        repairPoints;           /* repair points per cycle */
 	UDWORD                          reArmPoints;            /* rearm points per cycle */
 	UDWORD                          timeStarted;            /* Time reArm started on current object */
 	BASE_OBJECT                     *psObj;                 /* Object being rearmed */
