diff --git a/src/droid.cpp b/src/droid.cpp
index 755cb30..7cbca8a 100644
--- a/src/droid.cpp
+++ b/src/droid.cpp
@@ -842,23 +842,6 @@ void droidUpdate(DROID *psDroid)
 		droidUpdateDroidSelfRepair(psDroid);
 	}
 
-	/* Update the fire damage data */
-	if (psDroid->burnStart != 0 && psDroid->burnStart != gameTime - deltaGameTime)  // -deltaGameTime, since projectiles are updated after droids.
-	{
-		// The burnStart has been set, but is not from the previous tick, so we must be out of the fire.
-		psDroid->burnDamage = 0;  // Reset burn damage done this tick.
-		if (psDroid->burnStart + BURN_TIME < gameTime)
-		{
-			// Finished burning.
-			psDroid->burnStart = 0;
-		}
-		else
-		{
-			// do burn damage
-			droidDamage(psDroid, BURN_DAMAGE, WC_HEAT, WSC_FLAME, gameTime - deltaGameTime/2 + 1, true);
-		}
-	}
-
 	// At this point, the droid may be dead due to burn damage.
 	if (isDead((BASE_OBJECT *)psDroid))
 	{
diff --git a/src/projectile.cpp b/src/projectile.cpp
index e8eb7db..de5bcb5 100644
--- a/src/projectile.cpp
+++ b/src/projectile.cpp
@@ -1374,6 +1374,13 @@ void PROJECTILE::update()
 
 		case PROJ_INACTIVE:
 			psObj->died = psObj->time;
+			if (!psObj->burnVictims.empty())
+			{
+				for(std::list<BASE_OBJECT *>::iterator it = psObj->burnVictims.begin(); it != psObj->burnVictims.end(); it++)
+				{
+					(*it)->burnStart = 0;
+				}
+			}
 			break;
 	}
 
@@ -1405,11 +1412,26 @@ static void proj_checkBurnDamage(PROJECTILE *psProj)
 
 	WEAPON_STATS *psStats = psProj->psWStats;
 
+	BASE_OBJECT* psCurr;
+
+	if (!psProj->burnVictims.empty())
+	{
+		for (std::list<BASE_OBJECT *>::iterator it = psProj->burnVictims.begin(); it != psProj->burnVictims.end(); it++)
+		{
+			psCurr = *it;
+			if(isDead(psCurr))
+			{
+				psProj->burnVictims.erase(it);
+				break;	// needed, because we are not resetting the iterator
+			}
+		}
+	}
+
 	static GridList gridList;  // static to avoid allocations.
 	gridList = gridStartIterate(psProj->pos.x, psProj->pos.y, psStats->incenRadius);
 	for (GridIterator gi = gridList.begin(); gi != gridList.end(); ++gi)
 	{
-		BASE_OBJECT *psCurr = *gi;
+		psCurr = *gi;
 		if (psCurr->died)
 		{
 			continue;  // Do not damage dead objects further.
@@ -1437,11 +1459,39 @@ static void proj_checkBurnDamage(PROJECTILE *psProj)
 			psCurr->burnStart = gameTime;
 			psCurr->burnDamage = 0;  // Reset burn damage done this tick.
 		}
-		unsigned damageRate = weaponIncenDamage(psStats,psProj->player);
-		debug(LOG_NEVER, "Burn damage of %d per second to object %d, player %d\n", damageRate, psCurr->id, psCurr->player);
 
-		int relativeDamage = objectDamage(psCurr, damageRate, psStats->weaponClass, psStats->weaponSubClass, gameTime - deltaGameTime/2 + 1, true);
-		proj_UpdateKills(psProj, relativeDamage);
+		if (psProj->burnVictims.empty())
+		{
+			debug(LOG_WZ, "Adding cppVictim: %p", psCurr);
+			psProj->burnVictims.push_front(psCurr);
+			debug(LOG_WZ, "cppVictim added: %p", psCurr);
+		} else {
+			for (std::list<BASE_OBJECT *>::iterator it = psProj->burnVictims.begin(); it != psProj->burnVictims.end(); it++)
+			{
+				if (psCurr == *it)
+				{
+					break;
+				} else if (it == psProj->burnVictims.end()) {
+					debug(LOG_WZ, "Adding cppVictim: %p", psCurr);
+					psProj->burnVictims.push_back(psCurr);
+					debug(LOG_WZ, "cppVictim added: %p", psCurr);
+					break;
+				}
+			}
+		}
+	}
+	unsigned damageRate = weaponIncenDamage(psStats,psProj->player);
+
+	int relativeDamage;
+	
+	if (!psProj->burnVictims.empty())
+	{
+		for (std::list<BASE_OBJECT *>::iterator it = psProj->burnVictims.begin(); it != psProj->burnVictims.end(); it++)
+		{
+			psCurr = *it;
+			relativeDamage = objectDamage(psCurr, damageRate, psStats->weaponClass, psStats->weaponSubClass, gameTime - deltaGameTime/2 + 1, true);
+			proj_UpdateKills(psProj, relativeDamage);
+		}
 	}
 }
 
diff --git a/src/projectile.h b/src/projectile.h
index 2eec477..4a7e1ad 100644
--- a/src/projectile.h
+++ b/src/projectile.h
@@ -38,8 +38,6 @@ extern	BASE_OBJECT	*g_pProjLastAttacker;	///< The last unit that did damage - us
 #define PROJ_MAX_PITCH  45
 #define PROJ_ULTIMATE_PITCH  80
 
-#define BURN_TIME	10000	///< How long an object burns for after leaving a fire.
-#define BURN_DAMAGE	15	///< How much damaga a second an object takes when it is burning.
 #define ACC_GRAVITY	1000	///< Downward force against projectiles.
 
 /** How long to display a single electronic warfare shimmmer. */
diff --git a/src/projectiledef.h b/src/projectiledef.h
index b57c3b6..0cce46e 100644
--- a/src/projectiledef.h
+++ b/src/projectiledef.h
@@ -28,6 +28,7 @@
 #include "lib/gamelib/gtime.h"
 
 #include <vector>
+#include <list>
 
 
 enum PROJ_STATE
@@ -52,6 +53,7 @@ struct PROJECTILE : public SIMPLE_OBJECT
 	BASE_OBJECT*    psSource;               ///< what fired the projectile
 	BASE_OBJECT*    psDest;                 ///< target of this projectile
 	std::vector<BASE_OBJECT *> psDamaged;   ///< the targets that have already been dealt damage to (don't damage the same target twice)
+	std::list<BASE_OBJECT *> burnVictims; ///< CPP linked list with the projectile's burn victims
 
 	Vector3i        src;                    ///< Where projectile started
 	Vector3i        dst;                    ///< The target coordinates
