unchanged:
--- a/src/component.cpp
+++ b/src/component.cpp
@@ -128,6 +128,9 @@ UDWORD getComponentRadius(BASE_STATS *psComponent)
 	/* VTOL bombs are only stats allowed to have NULL ComponentIMD */
 	if (StatIsComponent(psComponent) != COMP_WEAPON
 		|| (((WEAPON_STATS *)psComponent)->weaponSubClass != WSC_BOMB
+			&& ((WEAPON_STATS *)psComponent)->weaponSubClass != WSC_CLUSTERBOMB
+			&& ((WEAPON_STATS *)psComponent)->weaponSubClass != WSC_HEAVYBOMB
+			&& ((WEAPON_STATS *)psComponent)->weaponSubClass != WSC_HOTBOMB
 			&& ((WEAPON_STATS *)psComponent)->weaponSubClass != WSC_EMP))
 	{
 		ASSERT(ComponentIMD, "No ComponentIMD!");
@@ -419,6 +422,9 @@ void displayComponentButton(BASE_STATS *Stat, Vector3i *Rotation, Vector3i *Posi
 	/* VTOL bombs are only stats allowed to have NULL ComponentIMD */
 	if (StatIsComponent(Stat) != COMP_WEAPON
 		|| (((WEAPON_STATS *)Stat)->weaponSubClass != WSC_BOMB
+			&& ((WEAPON_STATS *)Stat)->weaponSubClass != WSC_CLUSTERBOMB
+			&& ((WEAPON_STATS *)Stat)->weaponSubClass != WSC_HEAVYBOMB
+			&& ((WEAPON_STATS *)Stat)->weaponSubClass != WSC_HOTBOMB
 			&& ((WEAPON_STATS *)Stat)->weaponSubClass != WSC_EMP))
 	{
 		ASSERT(ComponentIMD, "No ComponentIMD");
unchanged:
--- a/src/oprint.cpp
+++ b/src/oprint.cpp
@@ -152,6 +152,56 @@ static void printWeaponInfo(const WEAPON_STATS* psStats)
 	case WSC_EMP:
 		pWSC = "WSC_EMP";
 		break;
+	/* New weapon subclasses for FK mod and some generic subclasses for other projects */
+	/* Added by Kreuvf 2012-06-03 */
+	case WSC_AACANNON:
+		pWSC = "WSC_AACANNON";
+		break;
+	case WSC_CLUSTERBOMB:
+		pWSC = "WSC_CLUSTERBOMB";
+		break;
+	case WSC_HEAVYBOMB:
+		pWSC = "WSC_HEAVYBOMB";
+		break;
+	case WSC_HOTBOMB:
+		pWSC = "WSC_HOTBOMB";
+		break;
+	case WSC_HOTHOWITZER:
+		pWSC = "WSC_HOTHOWITZER";
+		break;
+	case WSC_LASER:
+		pWSC = "WSC_LASER";
+		break;
+	case WSC_AALASER:
+		pWSC = "WSC_AALASER";
+		break;
+	case WSC_GEN0:
+		pWSC = "WSC_GEN0";
+		break;
+	case WSC_GEN1:
+		pWSC = "WSC_GEN1";
+		break;
+	case WSC_GEN2:
+		pWSC = "WSC_GEN2";
+		break;
+	case WSC_GEN3:
+		pWSC = "WSC_GEN3";
+		break;
+	case WSC_GEN4:
+		pWSC = "WSC_GEN4";
+		break;
+	case WSC_GEN5:
+		pWSC = "WSC_GEN5";
+		break;
+	case WSC_GEN6:
+		pWSC = "WSC_GEN6";
+		break;
+	case WSC_GEN7:
+		pWSC = "WSC_GEN7";
+		break;
+	case WSC_GEN8:
+		pWSC = "WSC_GEN8";
+		break;
 	default:
 		pWSC = "UNKNOWN SUB CLASS";
 		break;
unchanged:
--- b/src/projectile.cpp
+++ b/src/projectile.cpp
@@ -538,7 +538,8 @@
 				/* firing sound emitted from source */
 				audio_PlayObjDynamicTrack(psProj->psSource, psStats->iAudioFireID, NULL);
 				/* GJ HACK: move howitzer sound with shell */
-				if ( psStats->weaponSubClass == WSC_HOWITZERS )
+				/* Kreuvf: Added HOTHOWITZER */
+				if ( (psStats->weaponSubClass == WSC_HOWITZERS) || (psStats->weaponSubClass == WSC_HOTHOWITZER) )
 				{
 					audio_PlayObjDynamicTrack(psProj, ID_SOUND_HOWITZ_FLIGHT, NULL);
 				}
@@ -697,14 +698,29 @@
 			break;
 		case WSC_CANNON:
 		case WSC_BOMB:
+		case WSC_CLUSTERBOMB:
+		case WSC_HOTBOMB:
+		case WSC_HEAVYBOMB:
 		case WSC_ELECTRONIC:
 		case WSC_EMP:
 		case WSC_FLAME:
+		case WSC_LASER:
+		case WSC_AALASER:
 		case WSC_ENERGY:
 		case WSC_GAUSS:
 			distanceExtensionFactor = 150;
 			break;
 		case WSC_AAGUN: // No extended distance
+		case WSC_AACANNON:
+		case WSC_GEN0:
+		case WSC_GEN1:
+		case WSC_GEN2:
+		case WSC_GEN3:
+		case WSC_GEN4:
+		case WSC_GEN5:
+		case WSC_GEN6:
+		case WSC_GEN7:
+		case WSC_GEN8:
 			distanceExtensionFactor = 100;
 			break;
 		case WSC_ROCKET:
@@ -715,6 +731,7 @@
 		case WSC_COUNTER:
 		case WSC_MORTARS:
 		case WSC_HOWITZERS:
+		case WSC_HOTHOWITZER:
 		case WSC_LAS_SAT:
 			distanceExtensionFactor = 150;
 			break;
@@ -1288,7 +1305,7 @@
 	int age = gameTime - psObj->born;
 
 	/* Time to finish postimpact effect? */
-	if (age > (SDWORD)psStats->radiusLife && age > (SDWORD)psStats->incenTime)
+	if (age >= (SDWORD)psStats->radiusLife && age >= (SDWORD)psStats->incenTime)
 	{
 		psObj->state = PROJ_INACTIVE;
 		return;
diff -u b/src/stats.cpp b/src/stats.cpp
--- b/src/stats.cpp
+++ b/src/stats.cpp
@@ -625,7 +625,7 @@
 			%255[^,'\r\n],%255[^,'\r\n],%255[^,'\r\n],%255[^,'\r\n],%255[^,'\r\n],%255[^,'\r\n],%255[^,'\r\n],%d,\
 			%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%255[^,'\r\n],\
 			%255[^,'\r\n],%255[^,'\r\n],%255[^,'\r\n],%255[^,'\r\n],%d,%d,%d,%255[^,'\r\n],%255[^,'\r\n],%d,%d,\
-			%255[^,'\r\n],%d,%d,%d,%d,%d",
+			%255[^,'\r\n],%d,%d,%d,%d,%d,%d",
 			WeaponName, dummy, &psStats->buildPower,&psStats->buildPoints,
 			&psStats->weight, &weaponsize, &dummyVal,
 			&psStats->body, GfxFile, mountGfx, muzzleGfx, flightGfx,
@@ -639,7 +639,7 @@
 			fireOnMove, weaponClass, weaponSubClass, movement, weaponEffect,
 			&rotate, &maxElevation, &minElevation, facePlayer, faceInFlight,
 			&psStats->recoilValue, &psStats->minRange, lightWorld,
-			&effectSize, &surfaceToAir, &numAttackRuns, &designable, &penetrate);
+			&effectSize, &surfaceToAir, &numAttackRuns, &designable, &penetrate, &psStats->targeting);
 
 			psStats->numRounds = (UBYTE)numRounds;
 
@@ -1417,10 +1417,14 @@
 		{
 			psStats->type = SUPER_SENSOR;
 		}
-		else if (!strcmp(type, "RADAR DETECTOR"))
+		else if(!strcmp(type, "RADAR DETECTOR"))
 		{
 			psStats->type = RADAR_DETECTOR_SENSOR;
 		}
+		else if(!strcmp(type, "SURVEILLANCE"))
+		{
+			psStats->type = SURVEILLANCE_SENSOR;
+		}
 		else
 		{
 			ASSERT( false, "Invalid Sensor type" );
@@ -2876,6 +2880,72 @@
 	{
 		*wclass = WSC_EMP;
 	}
+	/* New weapon subclasses for FK mod and some generic subclasses for other projects */
+	/* Added by Kreuvf 2012-06-03 */
+	else if (strcmp(subClass, "A-A CANNON") == 0)
+	{
+		*wclass = WSC_AACANNON;
+	}
+	else if (strcmp(subClass, "CLUSTER BOMB") == 0)
+	{
+		*wclass = WSC_CLUSTERBOMB;
+	}
+	else if (strcmp(subClass, "HEAVY BOMB") == 0)
+	{
+		*wclass = WSC_HEAVYBOMB;
+	}
+	else if (strcmp(subClass, "HOT BOMB") == 0)
+	{
+		*wclass = WSC_HOTBOMB;
+	}
+	else if (strcmp(subClass, "HOT HOWITZER") == 0)
+	{
+		*wclass = WSC_HOTHOWITZER;
+	}
+	else if (strcmp(subClass, "LASER") == 0)
+	{
+		*wclass = WSC_LASER;
+	}
+	else if (strcmp(subClass, "A-A LASER") == 0)
+	{
+		*wclass = WSC_AALASER;
+	}
+	else if (strcmp(subClass, "GENERIC 0") == 0)
+	{
+		*wclass = WSC_GEN0;
+	}
+	else if (strcmp(subClass, "GENERIC 1") == 0)
+	{
+		*wclass = WSC_GEN1;
+	}
+	else if (strcmp(subClass, "GENERIC 2") == 0)
+	{
+		*wclass = WSC_GEN2;
+	}
+	else if (strcmp(subClass, "GENERIC 3") == 0)
+	{
+		*wclass = WSC_GEN3;
+	}
+	else if (strcmp(subClass, "GENERIC 4") == 0)
+	{
+		*wclass = WSC_GEN4;
+	}
+	else if (strcmp(subClass, "GENERIC 5") == 0)
+	{
+		*wclass = WSC_GEN5;
+	}
+	else if (strcmp(subClass, "GENERIC 6") == 0)
+	{
+		*wclass = WSC_GEN6;
+	}
+	else if (strcmp(subClass, "GENERIC 7") == 0)
+	{
+		*wclass = WSC_GEN7;
+	}
+	else if (strcmp(subClass, "GENERIC 8") == 0)
+	{
+		*wclass = WSC_GEN8;
+	}
         else
         {
 	    ASSERT(!"Invalid weapon sub class", "Invalid weapon sub class: %s", subClass);
@@ -3513,0 +3584,85 @@
+
+bool objSurveillanceSensor(const BASE_OBJECT *psObj) {
+	if (psObj->type == OBJ_STRUCTURE)
+	{
+		STRUCTURE *psStruct = (STRUCTURE *)psObj;
+
+		return (psStruct->status == SS_BUILT && psStruct->pStructureType->pSensor && psStruct->pStructureType->pSensor->type == SURVEILLANCE_SENSOR);
+	}
+	else if (psObj->type == OBJ_DROID)
+	{
+		DROID *psDroid = (DROID *)psObj;
+		SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+		return (psSensor && psSensor->type == SURVEILLANCE_SENSOR);
+	}
+	return false;
+}
+
+bool objVTOLSensor(const BASE_OBJECT *psObj) {
+	if (psObj->type == OBJ_STRUCTURE)
+	{
+		STRUCTURE *psStruct = (STRUCTURE *)psObj;
+
+		return (psStruct->status == SS_BUILT && psStruct->pStructureType->pSensor && psStruct->pStructureType->pSensor->type == VTOL_INTERCEPT_SENSOR);
+	}
+	else if (psObj->type == OBJ_DROID)
+	{
+		DROID *psDroid = (DROID *)psObj;
+		SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+		return (psSensor && psSensor->type == VTOL_INTERCEPT_SENSOR);
+	}
+	return false;
+}
+
+bool objVTOLCBSensor(const BASE_OBJECT *psObj) {
+	if (psObj->type == OBJ_STRUCTURE)
+	{
+		STRUCTURE *psStruct = (STRUCTURE *)psObj;
+
+		return (psStruct->status == SS_BUILT && psStruct->pStructureType->pSensor && psStruct->pStructureType->pSensor->type == VTOL_CB_SENSOR);
+	}
+	else if (psObj->type == OBJ_DROID)
+	{
+		DROID *psDroid = (DROID *)psObj;
+		SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+		return (psSensor && psSensor->type == VTOL_CB_SENSOR);
+	}
+	return false;
+}
+
+bool objCBSensor(const BASE_OBJECT *psObj) {
+	if (psObj->type == OBJ_STRUCTURE)
+	{
+		STRUCTURE *psStruct = (STRUCTURE *)psObj;
+
+		return (psStruct->status == SS_BUILT && psStruct->pStructureType->pSensor && psStruct->pStructureType->pSensor->type == INDIRECT_CB_SENSOR);
+	}
+	else if (psObj->type == OBJ_DROID)
+	{
+		DROID *psDroid = (DROID *)psObj;
+		SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+		return (psSensor && psSensor->type == INDIRECT_CB_SENSOR);
+	}
+	return false;
+}
+
+bool objStandardSensor(const BASE_OBJECT *psObj) {
+	if (psObj->type == OBJ_STRUCTURE)
+	{
+		STRUCTURE *psStruct = (STRUCTURE *)psObj;
+
+		return (psStruct->status == SS_BUILT && psStruct->pStructureType->pSensor && psStruct->pStructureType->pSensor->type == STANDARD_SENSOR);
+	}
+	else if (psObj->type == OBJ_DROID)
+	{
+		DROID *psDroid = (DROID *)psObj;
+		SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+		return (psSensor && psSensor->type == STANDARD_SENSOR);
+	}
+	return false;
+}
diff -u b/src/statsdef.h b/src/statsdef.h
--- b/src/statsdef.h
+++ b/src/statsdef.h
@@ -278,6 +278,24 @@
 	WSC_BOMB,
 	WSC_COMMAND,
 	WSC_EMP,
+	/* New weapon subclasses for FK mod and some generic subclasses for other projects */
+	/* Added by Kreuvf 2012-06-03 */
+	WSC_AACANNON,
+	WSC_CLUSTERBOMB,
+	WSC_HEAVYBOMB,
+	WSC_HOTBOMB,
+	WSC_HOTHOWITZER,
+	WSC_LASER,
+	WSC_AALASER,
+	WSC_GEN0,
+	WSC_GEN1,
+	WSC_GEN2,
+	WSC_GEN3,
+	WSC_GEN4,
+	WSC_GEN5,
+	WSC_GEN6,
+	WSC_GEN7,
+	WSC_GEN8,
 	WSC_COUNTER,				// Counter missile
 	WSC_NUM_WEAPON_SUBCLASSES,	/** The number of enumerators in this enum.	 */
 };
@@ -343,6 +361,7 @@
 	VTOL_INTERCEPT_SENSOR,
 	SUPER_SENSOR,			///< works as all of the above together! - new for updates
 	RADAR_DETECTOR_SENSOR,
+	SURVEILLANCE_SENSOR,
 };
 
 enum FIREONMOVE
@@ -457,6 +476,7 @@
 	UBYTE			surfaceToAir;			///< indicates how good in the air - SHOOT_ON_GROUND, SHOOT_IN_AIR or both
 	UBYTE			vtolAttackRuns;			///< number of attack runs a VTOL droid can	do with this weapon
 	bool			penetrate;				///< flag to indicate whether pentrate droid or not
+	UDWORD			targeting;				///< indicates if weapon needs sensor for targeting
 
 	/* Graphics control stats */
 	UDWORD			directLife;				///< How long a direct fire weapon is visible. Measured in 1/100 sec.
unchanged:
--- b/src/function.cpp
+++ b/src/function.cpp
@@ -145,7 +145,7 @@
 {
 	PRODUCTION_FUNCTION	*psFunction;
 	char					functionName[MAX_STR_LENGTH], bodySize[MAX_STR_LENGTH];
-	UDWORD					productionOutput;
+	uint32_t					productionOutput;
 
 	psFunction = (PRODUCTION_FUNCTION *)malloc(sizeof(PRODUCTION_FUNCTION));
 	memset(psFunction, 0, sizeof(PRODUCTION_FUNCTION));
@@ -162,7 +162,7 @@
 	//read the data in
 	functionName[0] = '\0';
 	bodySize[0] = '\0';
-	sscanf(pData, "%255[^,'\r\n],%255[^,'\r\n],%d", functionName, bodySize,
+	sscanf(pData, "%255[^,'\r\n],%255[^,'\r\n],%u", functionName, bodySize,
 	       &productionOutput);
 
 	//allocate storage for the name
@@ -174,15 +174,14 @@
 		return false;
 	}
 
-	//check prod output < UWORD_MAX
-	if (productionOutput < UWORD_MAX)
+	//check prod output <= UINT32_MAX
+	if (productionOutput <= UINT32_MAX)
 	{
-		psFunction->productionOutput = (UWORD)productionOutput;
+		psFunction->productionOutput = (uint32_t)productionOutput;
 	}
 	else
 	{
-		ASSERT(false, "loadProduction: production Output too big for %s", psFunction->pName);
-
+		ASSERT(false, "loadProduction: production Output too big for %s, production Output set to 0", psFunction->pName);
 		psFunction->productionOutput = 0;
 	}
 
@@ -295,7 +294,7 @@
 
 	//read the data in
 	functionName[0] = '\0';
-	sscanf(pData, "%255[^,'\r\n],%d", functionName, &psFunction->reArmPoints);
+	sscanf(pData, "%255[^,'\r\n],%d,%d", functionName, &psFunction->reArmPoints, &psFunction->repairPoints);
 
 	//allocate storage for the name
 	storeName((FUNCTION *)psFunction, functionName);
@@ -960,7 +959,7 @@
 {
 	FACTORY						*pFact;
 	PRODUCTION_FUNCTION			*pFactFunc;
-	UDWORD						type, baseOutput, i;
+	uint32_t						type, baseOutput, i;
 	STRUCTURE_STATS             *psStat;
 
 	switch (psBuilding->pStructureType->type)
@@ -999,7 +998,7 @@
 		}
 	}
 
-	pFact->productionOutput = (UBYTE)(baseOutput + (pFactFunc->productionOutput *
+	pFact->productionOutput = (uint32_t)(baseOutput + (pFactFunc->productionOutput *
 	        asProductionUpgrade[psBuilding->player][type].modifier) / 100);
 }
 
@@ -1047,6 +1046,22 @@
 	        asReArmUpgrade[psBuilding->player].modifier) / 100;
 }
 
+void structureReArmRepairUpgrade(STRUCTURE *psBuilding)
+{
+	REARM_PAD					*pPad = &psBuilding->pFunctionality->rearmPad;
+	REPAIR_DROID_FUNCTION				*pRepairFunc;
+
+	//upgrade the repair points of a rearm pad
+	ASSERT(pPad != NULL, "structureReArmUpgrade: invalid ReArm pointer");
+
+	pRepairFunc = (REPAIR_DROID_FUNCTION *)psBuilding->pStructureType->asFuncList[0];
+	ASSERT(pRepairFunc != NULL,
+	       "structureRepairUpgrade: invalid Function pointer");
+	
+	pPad->repairPoints = pRepairFunc->repairPoints + (pRepairFunc->repairPoints *
+	        asRepairFacUpgrade[psBuilding->player].modifier) / 100;
+}
+
 void structurePowerUpgrade(STRUCTURE *psBuilding)
 {
 	POWER_GEN		*pPowerGen = &psBuilding->pFunctionality->powerGenerator;
unchanged:
--- b/src/functiondef.h
+++ b/src/functiondef.h
@@ -112,7 +112,7 @@
 struct PRODUCTION_FUNCTION : public FUNCTION
 {
 	BODY_SIZE capacity;      // The max size of body the factory can produce
-	UWORD productionOutput;	 // Droid Build Points Produced Per Build Cycle
+	uint32_t productionOutput;	 // Droid Build Points Produced Per Build Cycle
 };
 
 /*To research topics available*/
@@ -125,6 +125,7 @@
 /*To rearm VTOLs*/
 struct REARM_FUNCTION : public FUNCTION
 {
+	uint32_t		repairPoints;	/*The number of repair points added per cycle*/
 	UDWORD			reArmPoints;	/*The number of reArm points added per cycle*/
 };
 
unchanged:
--- a/src/intdisplay.cpp
+++ b/src/intdisplay.cpp
@@ -267,7 +267,7 @@ void intUpdateProgressBar(WIDGET *psWidget, W_CONTEXT *psContext)
 				{
 					// Started production. Set the colour of the bar to yellow.
 					int buildPointsTotal = FactoryGetTemplate(Manufacture)->buildPoints;
-					int buildRate = Manufacture->timeStartHold == 0? Manufacture->productionOutput : 0;
+					uint32_t buildRate = Manufacture->timeStartHold == 0? Manufacture->productionOutput : 0;
 					formatTime(BarGraph, buildPointsTotal - Manufacture->buildPointsRemaining, buildPointsTotal, buildRate, _("Construction Progress"));
 				}
 				else
unchanged:
--- b/src/structure.cpp
+++ b/src/structure.cpp
@@ -1709,12 +1709,11 @@
 
 				//quick check not trying to add too much
 				ASSERT_OR_RETURN(NULL, psBuilding->pFunctionality->factory.productionOutput +
-					((PRODUCTION_FUNCTION*)pStructureType->asFuncList[0])->productionOutput < UBYTE_MAX,
+					((PRODUCTION_FUNCTION*)pStructureType->asFuncList[0])->productionOutput <= UINT32_MAX,
 					"building factory module - production Output is too big");
 
 				psBuilding->pFunctionality->factory.productionOutput += ((
 					PRODUCTION_FUNCTION*)pStructureType->asFuncList[0])->productionOutput;
-
 				capacity = psBuilding->pFunctionality->factory.capacity;
 			}
 		}
@@ -1937,7 +1936,7 @@
 			unsigned int x, y;
 
 			psFactory->capacity = (UBYTE) ((PRODUCTION_FUNCTION*)psBuilding->pStructureType->asFuncList[0])->capacity;
-			psFactory->productionOutput = (UBYTE) ((PRODUCTION_FUNCTION*)psBuilding->pStructureType->asFuncList[0])->productionOutput;
+			psFactory->productionOutput = ((PRODUCTION_FUNCTION*)psBuilding->pStructureType->asFuncList[0])->productionOutput;
 			psFactory->psSubject = NULL;
 
 			// Default the secondary order - AB 22/04/99
@@ -5618,8 +5617,8 @@
 		{
 			unsigned int assigned_droids = countAssignedDroids(psStructure);
 
-			CONPRINTF(ConsoleString, (ConsoleString, ngettext("%s - %u Unit assigned - Damage %3.0f%%", "%s - %u Units assigned - Damage %3.0f%%", assigned_droids),
-					  getStatName(psStructure->pStructureType), assigned_droids, getStructureDamage(psStructure) * (100.f/65536.f)));
+			CONPRINTF(ConsoleString, (ConsoleString, ngettext("%s - %u Unit assigned - Body Points: %d of %d", "%s - %u Units assigned - Body Points: %d of %d", assigned_droids),
+					  getStatName(psStructure->pStructureType), assigned_droids, psStructure->body, structureBodyBuilt(psStructure)));
 		}
 		break;
 	case REF_DEFENSE:
@@ -5643,13 +5642,13 @@
 		{
 			unsigned int assigned_droids = countAssignedDroids(psStructure);
 
-			CONPRINTF(ConsoleString, (ConsoleString, ngettext("%s - %u Unit assigned - Damage %3.0f%%", "%s - %u Units assigned - Damage %3.0f%%", assigned_droids),
-				getStatName(psStructure->pStructureType), assigned_droids, getStructureDamage(psStructure) * (100.f/65536.f)));
+			CONPRINTF(ConsoleString, (ConsoleString, ngettext("%s - %u Unit assigned - Body Points: %d of %d", "%s - %u Units assigned - Body Points: %d of %d", assigned_droids),
+				getStatName(psStructure->pStructureType), assigned_droids, psStructure->body, structureBodyBuilt(psStructure)));
 		}
 		else
 		{
-			CONPRINTF(ConsoleString, (ConsoleString, _("%s - Damage %3.0f%%"),
-									  getStatName(psStructure->pStructureType), getStructureDamage(psStructure) * (100.f/65536.f)));
+			CONPRINTF(ConsoleString, (ConsoleString, _("%s - Body Points: %d of %d"),
+									  getStatName(psStructure->pStructureType), psStructure->body, structureBodyBuilt(psStructure)));
 		}
 		break;
 	case REF_REPAIR_FACILITY:
@@ -5662,7 +5661,7 @@
 		else
 #endif
 		{
-			CONPRINTF(ConsoleString, (ConsoleString, "%s - Damage %3.0f%%", getStatName(psStructure->pStructureType), getStructureDamage(psStructure) * (100.f/65536.f)));
+			CONPRINTF(ConsoleString, (ConsoleString, "%s - Body Points: %d of %d", getStatName(psStructure->pStructureType), psStructure->body, structureBodyBuilt(psStructure)));
 		}
 		break;
 	case REF_RESOURCE_EXTRACTOR:
@@ -5675,7 +5674,7 @@
 		else
 #endif
 		{
-			CONPRINTF(ConsoleString, (ConsoleString, "%s - Damage %3.0f%%", getStatName(psStructure->pStructureType), getStructureDamage(psStructure) * (100.f/65536.f)));
+			CONPRINTF(ConsoleString, (ConsoleString, "%s - Body Points: %d of %d", getStatName(psStructure->pStructureType), psStructure->body, structureBodyBuilt(psStructure)));
 		}
 		break;
 	case REF_POWER_GEN:
@@ -5698,8 +5697,8 @@
 		else
 #endif
 		{
-			CONPRINTF(ConsoleString, (ConsoleString, _("%s - Connected %u of %u - Damage %3.0f%%"),
-					  getStatName(psStructure->pStructureType), numConnected, NUM_POWER_MODULES, getStructureDamage(psStructure) * (100.f/65536.f)));
+			CONPRINTF(ConsoleString, (ConsoleString, _("%s - Connected %u of %u - Body Points: %d of %d"),
+					  getStatName(psStructure->pStructureType), numConnected, NUM_POWER_MODULES, psStructure->body, structureBodyBuilt(psStructure)));
 		}
 		break;
 	case REF_CYBORG_FACTORY:
@@ -5716,8 +5715,8 @@
 		else
 #endif
 		{
-			CONPRINTF(ConsoleString, (ConsoleString, _("%s - Damage %3.0f%%"),
-					  getStatName(psStructure->pStructureType), getStructureDamage(psStructure) * (100.f/65536.f)));
+			CONPRINTF(ConsoleString, (ConsoleString, _("%s - Body Points: %d of %d"),
+					  getStatName(psStructure->pStructureType), psStructure->body, structureBodyBuilt(psStructure)));
 		}
 		break;
 	case REF_RESEARCH:
@@ -5731,8 +5730,8 @@
 		else
 #endif
 		{
-			CONPRINTF(ConsoleString, (ConsoleString, _("%s - Damage %3.0f%%"),
-					  getStatName(psStructure->pStructureType), getStructureDamage(psStructure) * (100.f/65536.f)));
+			CONPRINTF(ConsoleString, (ConsoleString, _("%s - Body Points: %d of %d"),
+					  getStatName(psStructure->pStructureType), psStructure->body, structureBodyBuilt(psStructure)));
 		}
 		break;
 	default:
@@ -5745,8 +5744,8 @@
 		else
 #endif
 		{
-			CONPRINTF(ConsoleString, (ConsoleString, _("%s - Damage %3.0f%%"),
-					  getStatName(psStructure->pStructureType), getStructureDamage(psStructure) * (100.f/65536.f)));
+			CONPRINTF(ConsoleString, (ConsoleString, _("%s - Body Points: %d of %d"),
+					  getStatName(psStructure->pStructureType), psStructure->body, structureBodyBuilt(psStructure)));
 		}
 		break;
 	}
unchanged:
--- b/src/structuredef.h
+++ b/src/structuredef.h
@@ -179,7 +179,7 @@
 											   can produce*/
 	uint8_t                         productionLoops;        ///< Number of loops to perform. Not synchronised, and only meaningful for selectedPlayer.
 	UBYTE				loopsPerformed;		/* how many times the loop has been performed*/
-	UBYTE				productionOutput;	/* Droid Build Points Produced Per
+	uint32_t				productionOutput;	/* Droid Build Points Produced Per
 											   Build Cycle*/
 	DROID_TEMPLATE *                psSubject;              ///< The subject the structure is working on.
 	DROID_TEMPLATE *                psSubjectPending;       ///< The subject the structure is going to working on. (Pending = not yet synchronised.)
@@ -222,6 +222,7 @@
 
 struct REARM_PAD
 {
+	uint32_t                        repairPoints;           /* repair points per cycle */
 	UDWORD                          reArmPoints;            /* rearm points per cycle */
 	UDWORD                          timeStarted;            /* Time reArm started on current object */
 	BASE_OBJECT                     *psObj;                 /* Object being rearmed */
unchanged:
--- a/src/display.cpp
+++ b/src/display.cpp
@@ -1750,9 +1750,10 @@ static void dealWithLMBDroid(DROID* psDroid, SELECTION_TYPE selection)
 			if(!psDroid->selected)
 			{
 				CONPRINTF(ConsoleString, (ConsoleString,
-					_("%s - Damage %d%% - Experience %.1f, %s"),
+					_("%s - Body Points: %d of %d - Experience %.1f, %s"),
 					droidGetName(psDroid),
-					100 - clip(PERCENT(psDroid->body,psDroid->originalBody), 0, 100),
+					psDroid->body,
+					psDroid->originalBody,
 					psDroid->experience/65536.f, _(getDroidLevelName(psDroid))));
 
 				FeedbackOrderGiven();
@@ -1766,9 +1767,10 @@ static void dealWithLMBDroid(DROID* psDroid, SELECTION_TYPE selection)
 	else // Clicked on allied unit with no other possible actions
 	{
 		CONPRINTF(ConsoleString, (ConsoleString,
-								  _("%s - Allied - Damage %d%% - Experience %d, %s"),
+								  _("%s - Allied - Body Points: %d of %d - Experience %d, %s"),
 								  droidGetName(psDroid),
-								  100 - clip(PERCENT(psDroid->body,psDroid->originalBody), 0, 100),
+								  psDroid->body,
+								  psDroid->originalBody,
 								  psDroid->experience/65536, getDroidLevelName(psDroid)));
 
 		FeedbackOrderGiven();
@@ -2247,9 +2249,10 @@ static void dealWithRMB( void )
 							if(!psDroid->selected)
 							{
 								CONPRINTF(ConsoleString, (ConsoleString,
-									_("%s - Damage %d%% - Experience %.1f, %s"),
+									_("%s - Body Points: %d of %d - Experience %.1f, %s"),
 									droidGetName(psDroid),
-									100 - clip(PERCENT(psDroid->body,psDroid->originalBody), 0, 100),
+									psDroid->body,
+									psDroid->originalBody,
 									psDroid->experience/65536.f, _(getDroidLevelName(psDroid))));
 
 								FeedbackOrderGiven();
unchanged:
--- a/src/function.h
+++ b/src/function.h
@@ -49,6 +49,7 @@ extern void structurePowerUpgrade(STRUCTURE *psBuilding);
 extern void structureRepairUpgrade(STRUCTURE *psBuilding);
 extern void structureSensorUpgrade(STRUCTURE *psBuilding);
 extern void structureReArmUpgrade(STRUCTURE *psBuilding);
+extern void structureReArmRepairUpgrade(STRUCTURE *psBuilding);
 extern void structureECMUpgrade(STRUCTURE *psBuilding);
 extern void sensorUpgrade(FUNCTION *pFunction, UBYTE player);
 extern void repairUpgrade(FUNCTION *pFunction, UBYTE player);
unchanged:
--- a/src/game.cpp
+++ b/src/game.cpp
@@ -4903,6 +4903,7 @@ static bool loadSaveStructure2(const char *pFileName, STRUCTURE **ppList)
 			break;
 		case REF_REARM_PAD:
 			psReArmPad = ((REARM_PAD *)psStructure->pFunctionality);
+			psReArmPad->repairPoints = ini.value("Rearm/repairPoints", psReArmPad->repairPoints).toInt();
 			psReArmPad->reArmPoints = ini.value("Rearm/reArmPoints", psReArmPad->reArmPoints).toInt();
 			psReArmPad->timeStarted = ini.value("Rearm/timeStarted", psReArmPad->timeStarted).toInt();
 			psReArmPad->timeLastUpdated = ini.value("Rearm/timeLastUpdated", psReArmPad->timeLastUpdated).toInt();
@@ -5144,6 +5145,7 @@ bool writeStructFile(const char *pFileName)
 				else if (psCurr->pStructureType->type == REF_REARM_PAD)
 				{
 					REARM_PAD *psReArmPad = ((REARM_PAD *)psCurr->pFunctionality);
+					ini.setValue("Rearm/repairPoints", psReArmPad->repairPoints);
 					ini.setValue("Rearm/reArmPoints", psReArmPad->reArmPoints);
 					ini.setValue("Rearm/timeStarted", psReArmPad->timeStarted);
 					ini.setValue("Rearm/timeLastUpdated", psReArmPad->timeLastUpdated);
unchanged:
--- a/src/research.cpp
+++ b/src/research.cpp
@@ -938,6 +938,11 @@ void researchResult(UDWORD researchIndex, UBYTE player, bool bDisplay, STRUCTURE
 						// upgrade the repair points
 						structureRepairUpgrade(psCurr);
 					}
+					if (psCurr->pStructureType->type == REF_REARM_PAD)
+					{
+						// upgrade the repair points of a rearm pad
+						structureReArmRepairUpgrade(psCurr);
+					}
 				}
 				// and the mission structure
 				for (psCurr = mission.apsStructLists[player]; psCurr != NULL; psCurr = psCurr->psNext)
@@ -947,6 +952,11 @@ void researchResult(UDWORD researchIndex, UBYTE player, bool bDisplay, STRUCTURE
 						// upgrade the repair points
 						structureRepairUpgrade(psCurr);
 					}
+					if (psCurr->pStructureType->type == REF_REARM_PAD)
+					{
+						// upgrade the repair points of a rearm pad
+						structureReArmRepairUpgrade(psCurr);
+					}
 				}
 				break;
 			case(WEAPON_UPGRADE_TYPE):
unchanged:
--- a/src/structure.cpp
+++ b/src/structure.cpp
@@ -105,8 +105,6 @@
 
 //used to calculate the time required for rearming
 #define REARM_FACTOR                10
-//used to calculate the time  required for repairing
-#define VTOL_REPAIR_FACTOR          10
 
 //Value is stored for easy access to this structure stat
 UDWORD			factoryModuleStat;
@@ -2052,10 +2050,11 @@ static bool setFunctionality(STRUCTURE	*psBuilding, STRUCTURE_TYPE functionType)
 		{
 			REARM_PAD* psReArmPad = &psBuilding->pFunctionality->rearmPad;
 
-			psReArmPad->reArmPoints = ((REARM_PAD *)psBuilding->pStructureType->asFuncList[0])->reArmPoints;
-
+			psReArmPad->reArmPoints = ((REARM_FUNCTION *)psBuilding->pStructureType->asFuncList[0])->reArmPoints;
+			psReArmPad->repairPoints = ((REARM_FUNCTION *)psBuilding->pStructureType->asFuncList[0])->repairPoints;
 			// Take advantage of upgrades
 			structureReArmUpgrade(psBuilding);
+			structureReArmRepairUpgrade(psBuilding);
 			break;
 		}
 
@@ -3075,7 +3074,21 @@ static void aiUpdateStructure(STRUCTURE *psStructure, bool isMission)
 					{
 						psChosenObj = psDroid;
 					}
+					if (isVtolDroid(psDroid))
+					{
+						// for VTOLs just sitting on rearm pads, we repair them if they are damaged
+						// Check if the units is on the pad or not (within coordinates of center ± 64)
+						// Note: This is NOT the same as 'distance to center is <= 64'!
+						xdiff = abs((SDWORD)psDroid->pos.x - (SDWORD)psStructure->pos.x);
+						ydiff = abs((SDWORD)psDroid->pos.y - (SDWORD)psStructure->pos.y);
+						if (xdiff <= 64 && ydiff <= 64 && psDroid->pos.z == psStructure->pos.z && psDroid->body < psDroid->originalBody)
+						{
+							psChosenObj = psDroid;
+						}
+					}
 				}
+			
+				
 				if (!psChosenObj) // None available? Try allies.
 				{
 					for (i=0; i<MAX_PLAYERS; i++)
@@ -3421,7 +3434,7 @@ static void aiUpdateStructure(STRUCTURE *psStructure, bool isMission)
 		{
 			REARM_PAD	*psReArmPad = &psStructure->pFunctionality->rearmPad;
 			UDWORD pointsAlreadyAdded;
-
+			
 			psDroid = (DROID *)psChosenObj;
 			ASSERT_OR_RETURN( , psDroid != NULL, "invalid droid pointer");
 			ASSERT_OR_RETURN( , isVtolDroid(psDroid), "invalid droid type");
@@ -3490,20 +3503,37 @@ static void aiUpdateStructure(STRUCTURE *psStructure, bool isMission)
 						}
 					}
 				}
+								
 				/* do repairing */
 				if (psDroid->body < psDroid->originalBody)
 				{
-					// Do not "simplify" this formula.
-					// It is written this way to prevent rounding errors.
-					pointsToAdd =  VTOL_REPAIR_FACTOR * (100+asReArmUpgrade[psStructure->player].modifier) * (gameTime -
-					               psReArmPad->timeStarted) / (GAME_TICKS_PER_SEC * 100);
-					pointsAlreadyAdded =  VTOL_REPAIR_FACTOR * (100+asReArmUpgrade[psStructure->player].modifier) * (psReArmPad->timeLastUpdated -
-					               psReArmPad->timeStarted) / (GAME_TICKS_PER_SEC * 100);
-
-					if ((pointsToAdd - pointsAlreadyAdded) > 0)
+				
+					//if in multiPlayer, and a Transporter - make sure its on the ground before repairing
+					if (bMultiPlayer && (psDroid->droidType == DROID_TRANSPORTER || psDroid->droidType == DROID_SUPERTRANSPORTER))
 					{
-						psDroid->body += (pointsToAdd - pointsAlreadyAdded);
+						if (!(psDroid->sMove.Status == MOVEINACTIVE &&
+							psDroid->sMove.iVertSpeed == 0))
+						{
+							objTrace(psStructure->id, "Waiting for transporter to land");
+							return;
+						}
 					}
+
+					//don't do anything if the resistance is low in multiplayer
+					if (bMultiPlayer)
+					{
+						if (psStructure->resistance < (SWORD)structureResistance(psStructure->
+							pStructureType, psStructure->player))
+						{
+							objTrace(psStructure->id, "Resistance too low for repair");
+							return;
+						}
+					}
+
+					// FIXME: duplicate code, make repairing cost power again
+					/* do repairing */
+					psDroid->body += gameTimeAdjustedAverage(psReArmPad->repairPoints);
+
 					if (psDroid->body >= psDroid->originalBody)
 					{
 						/* set droid points to max */
unchanged:
--- b/src/combat.cpp
+++ b/src/combat.cpp
@@ -477,21 +477,15 @@
 	// Reduce damage taken by EXP_REDUCE_DAMAGE % for each experience level
 	actualDamage = (damage * (100 - EXP_REDUCE_DAMAGE * level)) / 100;
 
-	// You always do at least a third of the experience modified damage
-	actualDamage = MAX(actualDamage - armour, actualDamage / 3);
+    // Reduce damage taken by armour
+    actualDamage = actualDamage - armour;
 
-	// And at least MIN_WEAPON_DAMAGE points
+    // You always do at least MIN_WEAPON_DAMAGE points
 	actualDamage = MAX(actualDamage, MIN_WEAPON_DAMAGE);
 
 	if (isDamagePerSecond)
 	{
-		int deltaDamageRate = actualDamage - psObj->burnDamage;
-		if (deltaDamageRate <= 0)
-		{
-			return 0;  // Did this much damage already, this tick, so don't do more.
-		}
-		actualDamage = gameTimeAdjustedAverage(deltaDamageRate);
-		psObj->burnDamage += deltaDamageRate;
+		actualDamage = gameTimeAdjustedAverage(actualDamage);
 	}
 
 	objTrace(psObj->id, "objDamage: Penetrated %d", actualDamage);
unchanged:
--- b/src/droid.cpp
+++ b/src/droid.cpp
@@ -162,10 +162,7 @@
 	CHECK_DROID(psDroid);
 
 	// VTOLs (and transporters in MP) on the ground take triple damage
-	if ((isVtolDroid(psDroid) || (isTransporter(psDroid) && bMultiPlayer)) && (psDroid->sMove.Status == MOVEINACTIVE))
-	{
-		damage *= 3;
-	}
+	// NOT
 
 	relativeDamage = objDamage(psDroid, damage, psDroid->originalBody, weaponClass, weaponSubClass, isDamagePerSecond);
 
@@ -842,23 +839,6 @@
 		droidUpdateDroidSelfRepair(psDroid);
 	}
 
-	/* Update the fire damage data */
-	if (psDroid->burnStart != 0 && psDroid->burnStart != gameTime - deltaGameTime)  // -deltaGameTime, since projectiles are updated after droids.
-	{
-		// The burnStart has been set, but is not from the previous tick, so we must be out of the fire.
-		psDroid->burnDamage = 0;  // Reset burn damage done this tick.
-		if (psDroid->burnStart + BURN_TIME < gameTime)
-		{
-			// Finished burning.
-			psDroid->burnStart = 0;
-		}
-		else
-		{
-			// do burn damage
-			droidDamage(psDroid, BURN_DAMAGE, WC_HEAT, WSC_FLAME, gameTime - deltaGameTime/2 + 1, true);
-		}
-	}
-
 	// At this point, the droid may be dead due to burn damage.
 	if (isDead((BASE_OBJECT *)psDroid))
 	{
unchanged:
--- a/src/projectile.cpp
+++ b/src/projectile.cpp
@@ -1374,6 +1374,13 @@ void PROJECTILE::update()
 
 		case PROJ_INACTIVE:
 			psObj->died = psObj->time;
+			if (!psObj->burnVictims.empty())
+			{
+				for(std::list<BASE_OBJECT *>::iterator it = psObj->burnVictims.begin(); it != psObj->burnVictims.end(); it++)
+				{
+					(*it)->burnStart = 0;
+				}
+			}
 			break;
 	}
 
@@ -1405,11 +1412,26 @@ static void proj_checkBurnDamage(PROJECTILE *psProj)
 
 	WEAPON_STATS *psStats = psProj->psWStats;
 
+	BASE_OBJECT* psCurr;
+
+	if (!psProj->burnVictims.empty())
+	{
+		for (std::list<BASE_OBJECT *>::iterator it = psProj->burnVictims.begin(); it != psProj->burnVictims.end(); it++)
+		{
+			psCurr = *it;
+			if(isDead(psCurr))
+			{
+				psProj->burnVictims.erase(it);
+				break;	// needed, because we are not resetting the iterator
+			}
+		}
+	}
+
 	static GridList gridList;  // static to avoid allocations.
 	gridList = gridStartIterate(psProj->pos.x, psProj->pos.y, psStats->incenRadius);
 	for (GridIterator gi = gridList.begin(); gi != gridList.end(); ++gi)
 	{
-		BASE_OBJECT *psCurr = *gi;
+		psCurr = *gi;
 		if (psCurr->died)
 		{
 			continue;  // Do not damage dead objects further.
@@ -1437,11 +1459,35 @@ static void proj_checkBurnDamage(PROJECTILE *psProj)
 			psCurr->burnStart = gameTime;
 			psCurr->burnDamage = 0;  // Reset burn damage done this tick.
 		}
-		unsigned damageRate = weaponIncenDamage(psStats,psProj->player);
-		debug(LOG_NEVER, "Burn damage of %d per second to object %d, player %d\n", damageRate, psCurr->id, psCurr->player);
 
-		int relativeDamage = objectDamage(psCurr, damageRate, psStats->weaponClass, psStats->weaponSubClass, gameTime - deltaGameTime/2 + 1, true);
-		proj_UpdateKills(psProj, relativeDamage);
+		if (psProj->burnVictims.empty())
+		{
+			psProj->burnVictims.push_front(psCurr);
+		} else {
+			for (std::list<BASE_OBJECT *>::iterator it = psProj->burnVictims.begin(); it != psProj->burnVictims.end(); it++)
+			{
+				if (psCurr == *it)
+				{
+					break;
+				} else if (*it == psProj->burnVictims.back()) {
+					psProj->burnVictims.push_back(psCurr);
+					break;
+				}
+			}
+		}
+	}
+	unsigned damageRate = weaponIncenDamage(psStats,psProj->player);
+
+	int relativeDamage;
+	
+	if (!psProj->burnVictims.empty())
+	{
+		for (std::list<BASE_OBJECT *>::iterator it = psProj->burnVictims.begin(); it != psProj->burnVictims.end(); it++)
+		{
+			psCurr = *it;
+			relativeDamage = objectDamage(psCurr, damageRate, psStats->weaponClass, psStats->weaponSubClass, gameTime - deltaGameTime/2 + 1, true);
+			proj_UpdateKills(psProj, relativeDamage);
+		}
 	}
 }
 
unchanged:
--- a/src/projectile.h
+++ b/src/projectile.h
@@ -38,8 +38,6 @@ extern	BASE_OBJECT	*g_pProjLastAttacker;	///< The last unit that did damage - us
 #define PROJ_MAX_PITCH  45
 #define PROJ_ULTIMATE_PITCH  80
 
-#define BURN_TIME	10000	///< How long an object burns for after leaving a fire.
-#define BURN_DAMAGE	15	///< How much damaga a second an object takes when it is burning.
 #define ACC_GRAVITY	1000	///< Downward force against projectiles.
 
 /** How long to display a single electronic warfare shimmmer. */
unchanged:
--- a/src/projectiledef.h
+++ b/src/projectiledef.h
@@ -28,6 +28,7 @@
 #include "lib/gamelib/gtime.h"
 
 #include <vector>
+#include <list>
 
 
 enum PROJ_STATE
@@ -52,6 +53,7 @@ struct PROJECTILE : public SIMPLE_OBJECT
 	BASE_OBJECT*    psSource;               ///< what fired the projectile
 	BASE_OBJECT*    psDest;                 ///< target of this projectile
 	std::vector<BASE_OBJECT *> psDamaged;   ///< the targets that have already been dealt damage to (don't damage the same target twice)
+	std::list<BASE_OBJECT *> burnVictims; ///< CPP linked list with the projectile's burn victims
 
 	Vector3i        src;                    ///< Where projectile started
 	Vector3i        dst;                    ///< The target coordinates
unchanged:
--- b/src/move.cpp
+++ b/src/move.cpp
@@ -116,7 +116,7 @@
 // How fast a wheeled droid decelerates
 #define WHEELED_SKID_DECEL		350
 // How fast a hover droid decelerates
-#define HOVER_SKID_DECEL		120
+#define HOVER_SKID_DECEL		200
 
 /************************************************************************************/
 /*             Person model defines                                                 */
@@ -147,7 +147,7 @@
 // How fast vtols decelerate
 #define VTOL_DECEL				200
 // How fast vtols 'skid'
-#define VTOL_SKID_DECEL			600
+#define VTOL_SKID_DECEL			1500
 
 /// Extra precision added to movement calculations.
 #define EXTRA_BITS                              8
diff -u b/src/combat.cpp b/src/combat.cpp
--- b/src/combat.cpp
+++ b/src/combat.cpp
@@ -28,6 +28,7 @@
 #include "lib/netplay/netplay.h"
 
 #include "action.h"
+#include "ai.h"
 #include "cluster.h"
 #include "combat.h"
 #include "difficulty.h"
@@ -147,6 +148,12 @@
 		}
 	}
 
+	if(psStats->targeting == 1) {
+		if(!targetInSensorRange(psTarget, psAttacker)) {
+			return false;
+		}
+	}
+
 	Vector3i deltaPos = psTarget->pos - psAttacker->pos;
 
 	// if the turret doesn't turn, check if the attacker is in alignment with the target
@@ -429,7 +436,7 @@
  */
 int32_t objDamage(BASE_OBJECT *psObj, unsigned damage, unsigned originalhp, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, bool isDamagePerSecond)
 {
-	int	actualDamage, armour, level = 1;
+	int	actualDamage, armour, level = 0;
 
 	// If the previous hit was by an EMP cannon and this one is not:
 	// don't reset the weapon class and hit time
@@ -522,7 +529,7 @@
 unsigned int objGuessFutureDamage(WEAPON_STATS *psStats, unsigned int player, BASE_OBJECT *psTarget)
 {
 	unsigned int damage;
-	int	actualDamage, armour = 0, level = 1;
+	int	actualDamage, armour = 0, level = 0;
 
 	if (psTarget == NULL)
 		return 0;  // Hard to destroy the ground. The armour on the mud is very strong and blocks all damage.
unchanged:
--- a/src/droid.cpp
+++ b/src/droid.cpp
@@ -834,7 +834,7 @@ void droidUpdate(DROID *psDroid)
 	// -----------------
 
 	// See if we can and need to self repair.
-	if (!isVtolDroid(psDroid) && psDroid->body < psDroid->originalBody && psDroid->asBits[COMP_REPAIRUNIT].nStat != 0 && selfRepairEnabled(psDroid->player))
+	if (psDroid->body < psDroid->originalBody && psDroid->asBits[COMP_REPAIRUNIT].nStat != 0 && selfRepairEnabled(psDroid->player))
 	{
 		droidUpdateDroidSelfRepair(psDroid);
 	}
unchanged:
--- a/src/move.cpp
+++ b/src/move.cpp
@@ -60,9 +60,9 @@
 #include "drive.h"
 
 /* max and min vtol heights above terrain */
-#define	VTOL_HEIGHT_MIN				250
-#define	VTOL_HEIGHT_LEVEL			300
-#define	VTOL_HEIGHT_MAX				350
+#define	VTOL_HEIGHT_MIN				400
+#define	VTOL_HEIGHT_LEVEL			450
+#define	VTOL_HEIGHT_MAX				500
 
 /* minimum distance for cyborgs to jump */
 #define	CYBORG_MIN_JUMP_DISTANCE	500
only in patch2:
unchanged:
--- b/src/action.cpp
+++ b/src/action.cpp
@@ -43,6 +43,8 @@
 #include "scripttabs.h"
 #include "transporter.h"
 #include "mapgrid.h"
+#include <math.h>
+#include "console.h"
 
 /* attack run distance */
 #define	VTOL_ATTACK_LENGTH		1000
@@ -157,7 +159,7 @@
 /* Check if a target is at correct range to attack */
 static bool actionInAttackRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_slot)
 {
-	SDWORD			dx, dy, radSq, rangeSq, longRange;
+	SDWORD			dx, dy, dz, radSq, rangeSq, longRange, angle, minEle, maxEle;
 	WEAPON_STATS	*psStats;
 	int compIndex;
 
@@ -177,7 +179,7 @@
 	psStats = asWeaponStats + compIndex;
 
 	if (psDroid->order.type == DORDER_ATTACKTARGET
-		&& secondaryGetState(psDroid, DSO_HALTTYPE) == DSS_HALT_HOLD)
+			&& secondaryGetState(psDroid, DSO_HALTTYPE) == DSS_HALT_HOLD)
 	{
 		longRange = proj_GetLongRange(psStats);
 		rangeSq = longRange * longRange;
@@ -220,10 +222,19 @@
 		rangeSq = psStats->minRange * psStats->minRange;
 		if ( radSq >= rangeSq || !proj_Direct( psStats ) )
 		{
-			return true;
+			/*check angle */
+			dz = (SDWORD)psObj->pos.z - (SDWORD)psDroid->pos.z;
+			dz = dz*2;
+			angle = atan(dz/sqrt(radSq)) * 180 / M_PI;
+			minEle = psStats->minElevation;
+			maxEle = psStats->maxElevation;
+			if(minEle <= angle && angle <= maxEle) {
+				if(psStats->movementModel != MM_INDIRECT && psStats->movementModel != MM_HOMINGINDIRECT) {
+					return true;
+				}
+			}
 		}
 	}
-
 	return false;
 }
 
@@ -231,7 +242,7 @@
 // check if a target is within weapon range
 bool actionInRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_slot)
 {
-	SDWORD			dx, dy, radSq, rangeSq, longRange;
+	SDWORD			dx, dy, dz, radSq, rangeSq, longRange, angle, minEle, maxEle;
 	WEAPON_STATS	*psStats;
 	int compIndex;
 
@@ -261,10 +272,19 @@
 		rangeSq = psStats->minRange * psStats->minRange;
 		if ( radSq >= rangeSq || !proj_Direct( psStats ) )
 		{
-			return true;
+			/*check angle */
+			dz = (SDWORD)psObj->pos.z - (SDWORD)psDroid->pos.z;
+			dz = dz*2;
+			angle = atan(dz/sqrt(radSq)) * 180 / M_PI;
+			minEle = psStats->minElevation;
+			maxEle = psStats->maxElevation;
+			if(minEle <= angle && angle <= maxEle) {
+				if(psStats->movementModel != MM_INDIRECT && psStats->movementModel != MM_HOMINGINDIRECT) {
+					return true;
+				}
+			}
 		}
 	}
-
 	return false;
 }
 
@@ -1042,7 +1062,7 @@
 					{
 						BASE_OBJECT* psActionTarget = psDroid->psActionTarget[i];
 						// is the turret aligned with the target?
-						if (actionTargetTurret(psDroid, psActionTarget, &psDroid->asWeaps[i]))
+						if (actionTargetTurret(psDroid, psActionTarget, &psDroid->asWeaps[i]) && actionInAttackRange(psDroid, psActionTarget, i))
 						{
 							// In range - fire !!!
 							combFire(&psDroid->asWeaps[i], psDroid, psActionTarget, i);
only in patch2:
unchanged:
--- b/src/ai.cpp
+++ b/src/ai.cpp
@@ -33,6 +33,8 @@
 #include "mapgrid.h"
 #include "map.h"
 #include "projectile.h"
+#include <math.h>
+#include "console.h"
 
 /* Weights used for target selection code,
  * target distance is used as 'common currency'
@@ -107,12 +109,37 @@
 	WEAPON_STATS *psWStats = psStruct->asWeaps[weapon_slot].nStat + asWeaponStats;
 
 	int longRange = proj_GetLongRange(psWStats);
+	/*check angle */
+	SDWORD dz, angle, minEle, maxEle;
+	dz = (SDWORD)psTarget->pos.z - (SDWORD)psStruct->pos.z;
+	dz = dz*2;
+	angle = atan(dz/sqrt(objPosDiffSq(psStruct, psTarget))) * 180 / M_PI;
+	minEle = psWStats->minElevation;
+	maxEle = psWStats->maxElevation;
+	if(minEle > angle || angle > maxEle) {
+		if(psWStats->movementModel != MM_INDIRECT && psWStats->movementModel != MM_HOMINGINDIRECT) {
+			return false;
+		}
+	}
 	return objPosDiffSq(psStruct, psTarget) < longRange*longRange && lineOfFire(psStruct, psTarget, weapon_slot, true);
 }
 
 static bool aiDroidHasRange(DROID *psDroid, BASE_OBJECT *psTarget, int weapon_slot)
 {
+	WEAPON_STATS *psWStats = psDroid->asWeaps[weapon_slot].nStat + asWeaponStats;
 	int32_t longRange = aiObjRange(psDroid, weapon_slot);
+	/*check angle */
+	SDWORD dz, angle, minEle, maxEle;
+	dz = (SDWORD)psTarget->pos.z - (SDWORD)psDroid->pos.z;
+	dz = dz*2;
+	angle = atan(dz/sqrt(objPosDiffSq(psDroid, psTarget))) * 180 / M_PI;
+	minEle = psWStats->minElevation;
+	maxEle = psWStats->maxElevation;
+	if(minEle > angle || angle > maxEle) {
+		if(psWStats->movementModel != MM_INDIRECT && psWStats->movementModel != MM_HOMINGINDIRECT) {
+			return false;
+		}
+	}
 
 	return objPosDiffSq(psDroid, psTarget) < longRange*longRange;
 }
@@ -181,6 +208,9 @@
 		{
 			continue;
 		}
+		if(objSurveillanceSensor(psSensor)) {
+			continue;
+		}
 		else if (psSensor->type == OBJ_DROID)
 		{
 			DROID		*psDroid = (DROID *)psSensor;
@@ -194,6 +224,7 @@
 			psTemp = psDroid->psActionTarget[0];
 			isCB = cbSensorDroid(psDroid);
 			isRD = objRadarDetector((BASE_OBJECT *)psDroid);
+			SENSOR_STATS *psSensorStats = getSensorStats(psDroid);
 		}
 		else if (psSensor->type == OBJ_STRUCTURE)
 		{
@@ -929,6 +960,12 @@
 		ASSERT(false, "Only to be used for sensor turrets!");
 		return false;
 	}
+	DROID *psDroid = (DROID *)psObj;
+	SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+	if(psSensor->type == SURVEILLANCE_SENSOR) {
+		return false;
+	}
 
 	/* See if there is something in range */
 	if (psObj->type == OBJ_DROID)
@@ -1281,0 +1319,55 @@
+bool targetInSensorRange(BASE_OBJECT *psTarget, BASE_OBJECT *psOrigin) {
+	BASE_OBJECT	*psSensor;
+	for (psSensor = apsSensorList[0]; psSensor; psSensor = psSensor->psNextFunc) {
+		if(psSensor->player != psOrigin->player) continue;
+		if (objSurveillanceSensor(psSensor) || objVTOLSensor(psSensor) || objVTOLCBSensor(psSensor)) {
+			continue;
+		}
+		else if (objRadarDetector(psSensor)) {
+			if (objActiveRadar(psTarget) != NULL) {
+				SDWORD dx, dy, radSq, rangeSq;
+				dx = (SDWORD)psSensor->pos.x - (SDWORD)psTarget->pos.x;
+				dy = (SDWORD)psSensor->pos.y - (SDWORD)psTarget->pos.y;
+
+				radSq = dx*dx + dy*dy;
+				rangeSq = psSensor->sensorRange * psSensor->sensorRange;
+				if (radSq <= rangeSq) {
+					return true;
+				}
+
+				return false;
+			}
+		}
+		else if (objCBSensor(psSensor)) {
+			if (psSensor->type == OBJ_STRUCTURE) {
+				STRUCTURE *psStruct = (STRUCTURE *)psSensor;
+				if (psStruct->psTarget[0] == psTarget) {
+					return true;
+				}
+			}
+			else if (psSensor->type == OBJ_DROID) //untested
+			{
+				DROID *psDroid = (DROID *)psSensor;
+				if (psDroid->psActionTarget[0] == psTarget) {
+					return true;
+				}
+			}
+		}
+		else if (objStandardSensor(psSensor) && visibleObject(psSensor, psTarget, true)) {
+			SDWORD dx, dy, radSq, rangeSq;
+			dx = (SDWORD)psSensor->pos.x - (SDWORD)psTarget->pos.x;
+			dy = (SDWORD)psSensor->pos.y - (SDWORD)psTarget->pos.y;
+
+			radSq = dx*dx + dy*dy;
+			rangeSq = psSensor->sensorRange * psSensor->sensorRange;
+			if (radSq <= rangeSq) {
+				return true;
+			}
+
+		}
+
+	}
+	return false;
+
+}
+
only in patch2:
unchanged:
--- a/src/ai.h
+++ b/src/ai.h
@@ -83,3 +83,4 @@ bool validTarget(BASE_OBJECT *psObject, BASE_OBJECT *psTarget, int weapon_slot);
 // Check if any of the weapons can target the target
 bool checkAnyWeaponsTarget(BASE_OBJECT *psObject, BASE_OBJECT *psTarget);
 #endif // __INCLUDED_SRC_AI_H__
+bool targetInSensorRange(BASE_OBJECT *psTarget, BASE_OBJECT *psOrigin);
only in patch2:
unchanged:
--- a/src/stats.h
+++ b/src/stats.h
@@ -364,4 +364,14 @@ SENSOR_STATS *objActiveRadar(const BASE_OBJECT *psObj);
 /** Returns whether object has a radar detector sensor. */
 bool objRadarDetector(const BASE_OBJECT *psObj);
 
+bool objSurveillanceSensor(const BASE_OBJECT *psObj);
+
+bool objVTOLSensor(const BASE_OBJECT *psObj);
+
+bool objVTOLCBSensor(const BASE_OBJECT *psObj);
+
+bool objCBSensor(const BASE_OBJECT *psObj);
+
+bool objStandardSensor(const BASE_OBJECT *psObj);
+
 #endif // __INCLUDED_SRC_STATS_H__
only in patch2:
unchanged:
--- a/src/action.cpp
+++ b/src/action.cpp
@@ -229,6 +229,8 @@ static bool actionInAttackRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_s
 			minEle = psStats->minElevation;
 			maxEle = psStats->maxElevation;
 			if(minEle <= angle && angle <= maxEle) {
+				return true;
+			} else {
 				if(psStats->movementModel != MM_INDIRECT && psStats->movementModel != MM_HOMINGINDIRECT) {
 					return true;
 				}
@@ -279,6 +281,8 @@ bool actionInRange(DROID *psDroid, BASE_OBJECT *psObj, int weapon_slot)
 			minEle = psStats->minElevation;
 			maxEle = psStats->maxElevation;
 			if(minEle <= angle && angle <= maxEle) {
+				return true;
+			} else {
 				if(psStats->movementModel != MM_INDIRECT && psStats->movementModel != MM_HOMINGINDIRECT) {
 					return true;
 				}
only in patch2:
unchanged:
--- a/src/ai.cpp
+++ b/src/ai.cpp
@@ -1334,8 +1334,6 @@ bool targetInSensorRange(BASE_OBJECT *psTarget, BASE_OBJECT *psOrigin) {
 				if (radSq <= rangeSq) {
 					return true;
 				}
-
-				return false;
 			}
 		}
 		else if (objCBSensor(psSensor)) {
@@ -1367,6 +1365,14 @@ bool targetInSensorRange(BASE_OBJECT *psTarget, BASE_OBJECT *psOrigin) {
 		}
 
 	}
+	DROID *psCommander = cmdDroidGetDesignator(psOrigin->player);
+	if(psCommander != NULL) {
+		if(psCommander->psActionTarget[0] == psTarget)
+		{
+			return true;
+		}
+	}
+
 	return false;
 
 }
