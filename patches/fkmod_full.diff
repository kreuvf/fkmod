diff --git a/src/action.cpp b/src/action.cpp
index 0af50c0..6fae9ab 100644
--- a/src/action.cpp
+++ b/src/action.cpp
@@ -46,6 +46,8 @@
 #include "order.h"
 #include "objmem.h"
 #include "move.h"
+#include <math.h>
+#include "console.h"
 
 /* attack run distance */
 #define	VTOL_ATTACK_LENGTH		1000
@@ -182,10 +184,21 @@ bool actionInRange(const DROID *psDroid, const BASE_OBJECT *psObj, int weapon_sl
 		const int minrange = psStats->upgrade[psDroid->player].minRange;
 		if (radSq >= minrange * minrange || !proj_Direct(psStats))
 		{
-			return true;
+			/*check angle */
+			int dz = (SDWORD)psObj->pos.z - (SDWORD)psDroid->pos.z;
+			dz = dz*2;
+			int angle = atan(dz/sqrt(radSq)) * 180 / M_PI;
+			int minEle = psStats->minElevation;
+			int maxEle = psStats->maxElevation;
+			if(minEle <= angle && angle <= maxEle) {
+				return true;
+			} else {
+				if(psStats->movementModel == MM_INDIRECT || psStats->movementModel == MM_HOMINGINDIRECT) {
+					return true;
+				}
+			}
 		}
 	}
-
 	return false;
 }
 
@@ -897,7 +910,7 @@ void actionUpdateDroid(DROID *psDroid)
 					{
 						BASE_OBJECT *psActionTarget = psDroid->psActionTarget[i];
 						// is the turret aligned with the target?
-						if (actionTargetTurret(psDroid, psActionTarget, &psDroid->asWeaps[i]))
+						if (actionTargetTurret(psDroid, psActionTarget, &psDroid->asWeaps[i]) && actionInRange(psDroid, psActionTarget, i))
 						{
 							// In range - fire !!!
 							combFire(&psDroid->asWeaps[i], psDroid, psActionTarget, i);
diff --git a/src/ai.cpp b/src/ai.cpp
index 54dc7c7..04475ed 100644
--- a/src/ai.cpp
+++ b/src/ai.cpp
@@ -36,6 +36,8 @@
 #include "projectile.h"
 #include "objmem.h"
 #include "order.h"
+#include <math.h>
+#include "console.h"
 
 /* Weights used for target selection code,
  * target distance is used as 'common currency'
@@ -113,12 +115,37 @@ static bool aiStructHasRange(STRUCTURE *psStruct, BASE_OBJECT *psTarget, int wea
 	WEAPON_STATS *psWStats = psStruct->asWeaps[weapon_slot].nStat + asWeaponStats;
 
 	int longRange = proj_GetLongRange(psWStats, psStruct->player);
+	/*check angle */
+	SDWORD dz, angle, minEle, maxEle;
+	dz = (SDWORD)psTarget->pos.z - (SDWORD)psStruct->pos.z;
+	dz = dz*2;
+	angle = atan(dz/sqrt(objPosDiffSq(psStruct, psTarget))) * 180 / M_PI;
+	minEle = psWStats->minElevation;
+	maxEle = psWStats->maxElevation;
+	if(minEle > angle || angle > maxEle) {
+		if(psWStats->movementModel != MM_INDIRECT && psWStats->movementModel != MM_HOMINGINDIRECT) {
+			return false;
+		}
+	}
 	return objPosDiffSq(psStruct, psTarget) < longRange * longRange && lineOfFire(psStruct, psTarget, weapon_slot, true);
 }
 
 static bool aiDroidHasRange(DROID *psDroid, BASE_OBJECT *psTarget, int weapon_slot)
 {
+	WEAPON_STATS *psWStats = psDroid->asWeaps[weapon_slot].nStat + asWeaponStats;
 	int32_t longRange = aiDroidRange(psDroid, weapon_slot);
+	/*check angle */
+	SDWORD dz, angle, minEle, maxEle;
+	dz = (SDWORD)psTarget->pos.z - (SDWORD)psDroid->pos.z;
+	dz = dz*2;
+	angle = atan(dz/sqrt(objPosDiffSq(psDroid, psTarget))) * 180 / M_PI;
+	minEle = psWStats->minElevation;
+	maxEle = psWStats->maxElevation;
+	if(minEle > angle || angle > maxEle) {
+		if(psWStats->movementModel != MM_INDIRECT && psWStats->movementModel != MM_HOMINGINDIRECT) {
+			return false;
+		}
+	}
 
 	return objPosDiffSq(psDroid, psTarget) < longRange * longRange;
 }
@@ -187,6 +214,9 @@ static BASE_OBJECT *aiSearchSensorTargets(BASE_OBJECT *psObj, int weapon_slot, W
 		{
 			continue;
 		}
+		if(objSurveillanceSensor(psSensor)) {
+			continue;
+		}
 		else if (psSensor->type == OBJ_DROID)
 		{
 			DROID		*psDroid = (DROID *)psSensor;
@@ -958,6 +988,12 @@ bool aiChooseSensorTarget(BASE_OBJECT *psObj, BASE_OBJECT **ppsTarget)
 		ASSERT(false, "Only to be used for sensor turrets!");
 		return false;
 	}
+	DROID *psDroid = (DROID *)psObj;
+	SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+	if(psSensor->type == SURVEILLANCE_SENSOR) {
+		return false;
+	}
 
 	/* See if there is something in range */
 	if (psObj->type == OBJ_DROID)
@@ -1292,3 +1328,65 @@ bool validTarget(BASE_OBJECT *psObject, BASE_OBJECT *psTarget, int weapon_slot)
 
 	return bValidTarget;
 }
+
+bool targetInSensorRange(BASE_OBJECT *psTarget, BASE_OBJECT *psOrigin) {
+	BASE_OBJECT	*psSensor;
+	for (psSensor = apsSensorList[0]; psSensor; psSensor = psSensor->psNextFunc) {
+		if(psSensor->player != psOrigin->player) continue;
+		if (objSurveillanceSensor(psSensor) || objVTOLSensor(psSensor) || objVTOLCBSensor(psSensor)) {
+			continue;
+		}
+		else if (objRadarDetector(psSensor)) {
+			if (objActiveRadar(psTarget) != NULL) {
+				int dx, dy, radSq, range, rangeSq;
+				dx = (SDWORD)psSensor->pos.x - (SDWORD)psTarget->pos.x;
+				dy = (SDWORD)psSensor->pos.y - (SDWORD)psTarget->pos.y;
+
+				radSq = dx*dx + dy*dy;
+				range = objSensorRange(psSensor);
+				rangeSq = range * range;
+				if (radSq <= rangeSq) {
+					return true;
+				}
+			}
+		}
+		else if (objCBSensor(psSensor)) {
+			if (psSensor->type == OBJ_STRUCTURE) {
+				STRUCTURE *psStruct = (STRUCTURE *)psSensor;
+				if (psStruct->psTarget[0] == psTarget) {
+					return true;
+				}
+			}
+			else if (psSensor->type == OBJ_DROID) //untested
+			{
+				DROID *psDroid = (DROID *)psSensor;
+				if (psDroid->psActionTarget[0] == psTarget) {
+					return true;
+				}
+			}
+		}
+		else if (objStandardSensor(psSensor) && visibleObject(psSensor, psTarget, true)) {
+			int dx, dy, radSq, range, rangeSq;
+			dx = (SDWORD)psSensor->pos.x - (SDWORD)psTarget->pos.x;
+			dy = (SDWORD)psSensor->pos.y - (SDWORD)psTarget->pos.y;
+
+			radSq = dx*dx + dy*dy;
+			range = objSensorRange(psSensor);
+			rangeSq = range * range;
+			if (radSq <= rangeSq) {
+				return true;
+			}
+
+		}
+
+	}
+	DROID *psCommander = cmdDroidGetDesignator(psOrigin->player);
+	if(psCommander != NULL) {
+		if(psCommander->psActionTarget[0] == psTarget)
+		{
+			return true;
+		}
+	}
+	return false;
+
+}
diff --git a/src/ai.h b/src/ai.h
index d668825..0a201c6 100644
--- a/src/ai.h
+++ b/src/ai.h
@@ -113,5 +113,6 @@ static inline bool alliancesCanGiveAnything(int t)
 {
 	return t != NO_ALLIANCES;
 }
+bool targetInSensorRange(BASE_OBJECT *psTarget, BASE_OBJECT *psOrigin);
 
 #endif // __INCLUDED_SRC_AI_H__
diff --git a/src/combat.cpp b/src/combat.cpp
index df5b98a..7b59e28 100644
--- a/src/combat.cpp
+++ b/src/combat.cpp
@@ -29,6 +29,7 @@
 #include "lib/netplay/netplay.h"
 
 #include "action.h"
+#include "ai.h"
 #include "cluster.h"
 #include "combat.h"
 #include "difficulty.h"
@@ -122,6 +123,13 @@ bool combFire(WEAPON *psWeap, BASE_OBJECT *psAttacker, BASE_OBJECT *psTarget, in
 		return false;
 	}
 
+	//if weapon needs sensor support, check if target is in sensor range
+	if(psStats->targeting == 1) {
+		if(!targetInSensorRange(psTarget, psAttacker)) {
+			return false;
+		}
+	}
+
 	Vector3i deltaPos = psTarget->pos - psAttacker->pos;
 
 	// if the turret doesn't turn, check if the attacker is in alignment with the target
@@ -367,13 +375,14 @@ int objArmour(BASE_OBJECT *psObj, WEAPON_CLASS weaponClass)
 /* Deals damage to an object
  * \param psObj object to deal damage to
  * \param damage amount of damage to deal
- * \param weaponClass the class of the weapon that deals the damage
- * \param weaponSubClass the subclass of the weapon that deals the damage
+ * \param psStats the stats of the weapon
  * \return < 0 when the dealt damage destroys the object, > 0 when the object survives
  */
-int32_t objDamage(BASE_OBJECT *psObj, unsigned damage, unsigned originalhp, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, bool isDamagePerSecond, int minDamage)
+int32_t objDamage(BASE_OBJECT *psObj, unsigned damage, unsigned originalhp, WEAPON_STATS *psStats, bool isDamagePerSecond, int minDamage)
 {
-	int	actualDamage, level = 1, lastHit = psObj->timeLastHit;
+	int	actualDamage, level = 0, lastHit = psObj->timeLastHit;
+	const WEAPON_CLASS weaponClass = psStats->weaponClass;
+	const WEAPON_SUBCLASS weaponSubClass = psStats->weaponSubClass;
 	int armour = objArmour(psObj, weaponClass);
 
 	// If the previous hit was by an EMP cannon and this one is not:
@@ -418,21 +427,12 @@ int32_t objDamage(BASE_OBJECT *psObj, unsigned damage, unsigned originalhp, WEAP
 	// Reduce damage taken by EXP_REDUCE_DAMAGE % for each experience level
 	actualDamage = (damage * (100 - EXP_REDUCE_DAMAGE * level)) / 100;
 
-	// Apply at least the minimum damage amount
-	actualDamage = MAX(actualDamage - armour, actualDamage * minDamage / 100);
-
 	// And at least MIN_WEAPON_DAMAGE points
 	actualDamage = MAX(actualDamage, MIN_WEAPON_DAMAGE);
 
 	if (isDamagePerSecond)
 	{
-		int deltaDamageRate = actualDamage - psObj->periodicalDamage;
-		if (deltaDamageRate <= 0)
-		{
-			return 0;  // Did this much damage already, this tick, so don't do more.
-		}
-		actualDamage = gameTimeAdjustedAverage(deltaDamageRate);
-		psObj->periodicalDamage += deltaDamageRate;
+		actualDamage = gameTimeAdjustedAverage(actualDamage);
 	}
 
 	objTrace(psObj->id, "objDamage: Penetrated %d", actualDamage);
@@ -460,23 +460,21 @@ int32_t objDamage(BASE_OBJECT *psObj, unsigned damage, unsigned originalhp, WEAP
 }
 
 /* Guesses how damage a shot might do.
- * \param psObj object that might be hit
- * \param damage amount of damage to deal
- * \param weaponClass the class of the weapon that deals the damage
- * \param weaponSubClass the subclass of the weapon that deals the damage
+ * \param player Player of the target
+ * \param psStats the stats of the weapon
+ * \param psTarget object that might be hit
  * \return guess at amount of damage
  */
 unsigned int objGuessFutureDamage(WEAPON_STATS *psStats, unsigned int player, BASE_OBJECT *psTarget)
 {
 	unsigned int damage;
-	int actualDamage, armour, level = 1;
+	int	actualDamage, level = 0;
 
 	if (psTarget == NULL)
 	{
 		return 0;    // Hard to destroy the ground. The armour on the mud is very strong and blocks all damage.
 	}
-
-	damage = calcDamage(weaponDamage(psStats, player), psStats->weaponEffect, psTarget);
+	damage = calcDamage(weaponDamage(psStats, player), psStats, psTarget);
 
 	// EMP cannons do no damage, if we are one return now
 	if (psStats->weaponSubClass == WSC_EMP)
@@ -486,8 +484,6 @@ unsigned int objGuessFutureDamage(WEAPON_STATS *psStats, unsigned int player, BA
 
 	// apply game difficulty setting
 	damage = modifyForDifficultyLevel(damage, psTarget->player != selectedPlayer);
-	armour = objArmour(psTarget, psStats->weaponClass);
-
 	if (psTarget->type == OBJ_DROID)
 	{
 		DROID *psDroid = (DROID *)psTarget;
@@ -500,9 +496,6 @@ unsigned int objGuessFutureDamage(WEAPON_STATS *psStats, unsigned int player, BA
 	// Reduce damage taken by EXP_REDUCE_DAMAGE % for each experience level
 	actualDamage = (damage * (100 - EXP_REDUCE_DAMAGE * level)) / 100;
 
-	// You always do at least a third of the experience modified damage
-	actualDamage = MAX(actualDamage - armour, actualDamage * psStats->upgrade[player].minimumDamage / 100);
-
 	// And at least MIN_WEAPON_DAMAGE points
 	actualDamage = MAX(actualDamage, MIN_WEAPON_DAMAGE);
 
diff --git a/src/combat.h b/src/combat.h
index 9dc51bc..9ad28d6 100644
--- a/src/combat.h
+++ b/src/combat.h
@@ -33,7 +33,7 @@ bool combFire(WEAPON *psWeap, BASE_OBJECT *psAttacker, BASE_OBJECT *psTarget, in
 if any support a counter battery sensor*/
 void counterBatteryFire(BASE_OBJECT *psAttacker, BASE_OBJECT *psTarget);
 
-int32_t objDamage(BASE_OBJECT *psObj, unsigned damage, unsigned originalhp, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, bool isDamagePerSecond, int minDamage);
+int32_t objDamage(BASE_OBJECT *psObj, unsigned damage, unsigned originalhp, WEAPON_STATS *psStats, bool isDamagePerSecond, int minDamage);
 
 unsigned int objGuessFutureDamage(WEAPON_STATS *psStats, unsigned int player, BASE_OBJECT *psTarget);
 
diff --git a/src/component.cpp b/src/component.cpp
index cb067cb..13e3af6 100644
--- a/src/component.cpp
+++ b/src/component.cpp
@@ -109,6 +109,9 @@ UDWORD getComponentRadius(BASE_STATS *psComponent)
 	/* VTOL bombs are only stats allowed to have NULL ComponentIMD */
 	if (StatIsComponent(psComponent) != COMP_WEAPON
 	    || (((WEAPON_STATS *)psComponent)->weaponSubClass != WSC_BOMB
+			&& ((WEAPON_STATS *)psComponent)->weaponSubClass != WSC_CLUSTERBOMB
+			&& ((WEAPON_STATS *)psComponent)->weaponSubClass != WSC_HEAVYBOMB
+			&& ((WEAPON_STATS *)psComponent)->weaponSubClass != WSC_HOTBOMB
 	        && ((WEAPON_STATS *)psComponent)->weaponSubClass != WSC_EMP))
 	{
 		ASSERT(ComponentIMD, "No ComponentIMD!");
@@ -278,6 +281,9 @@ void displayComponentButton(BASE_STATS *Stat, const Vector3i *Rotation, const Ve
 	/* VTOL bombs are only stats allowed to have NULL ComponentIMD */
 	if (StatIsComponent(Stat) != COMP_WEAPON
 	    || (((WEAPON_STATS *)Stat)->weaponSubClass != WSC_BOMB
+			&& ((WEAPON_STATS *)Stat)->weaponSubClass != WSC_CLUSTERBOMB
+			&& ((WEAPON_STATS *)Stat)->weaponSubClass != WSC_HEAVYBOMB
+			&& ((WEAPON_STATS *)Stat)->weaponSubClass != WSC_HOTBOMB
 	        && ((WEAPON_STATS *)Stat)->weaponSubClass != WSC_EMP))
 	{
 		ASSERT(ComponentIMD, "No ComponentIMD");
diff --git a/src/droid.cpp b/src/droid.cpp
index cc59c49..1880fb3 100644
--- a/src/droid.cpp
+++ b/src/droid.cpp
@@ -202,26 +202,23 @@ int droidReloadBar(BASE_OBJECT *psObj, WEAPON *psWeap, int weapon_slot)
 /* Deals damage to a droid
  * \param psDroid droid to deal damage to
  * \param damage amount of damage to deal
- * \param weaponClass the class of the weapon that deals the damage
- * \param weaponSubClass the subclass of the weapon that deals the damage
+ * \param psStats stats of the weapon
  * \param angle angle of impact (from the damage dealing projectile in relation to this droid)
  * \return > 0 when the dealt damage destroys the droid, < 0 when the droid survives
  *
  * NOTE: This function will damage but _never_ destroy transports when in single player (campaign) mode
  */
-int32_t droidDamage(DROID *psDroid, unsigned damage, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, unsigned impactTime, bool isDamagePerSecond, int minDamage)
+int32_t droidDamage(DROID *psDroid, unsigned damage, WEAPON_STATS *psStats, unsigned impactTime, bool isDamagePerSecond, int minDamage)
 {
 	int32_t relativeDamage;
+	const WEAPON_CLASS weaponClass = psStats->weaponClass;
 
 	CHECK_DROID(psDroid);
 
 	// VTOLs (and transporters in MP) on the ground take triple damage
-	if ((isVtolDroid(psDroid) || (isTransporter(psDroid) && bMultiPlayer)) && (psDroid->sMove.Status == MOVEINACTIVE))
-	{
-		damage *= 3;
-	}
+	// NOT
 
-	relativeDamage = objDamage(psDroid, damage, psDroid->originalBody, weaponClass, weaponSubClass, isDamagePerSecond, minDamage);
+	relativeDamage = objDamage(psDroid, damage, psDroid->originalBody, psStats, isDamagePerSecond, minDamage);
 
 	if (relativeDamage > 0)
 	{
@@ -801,28 +798,11 @@ void droidUpdate(DROID *psDroid)
 	// -----------------
 
 	// See if we can and need to self repair.
-	if (!isVtolDroid(psDroid) && psDroid->body < psDroid->originalBody && psDroid->asBits[COMP_REPAIRUNIT] != 0 && selfRepairEnabled(psDroid->player))
+	if (psDroid->body < psDroid->originalBody && psDroid->asBits[COMP_REPAIRUNIT] != 0 && selfRepairEnabled(psDroid->player))
 	{
 		droidUpdateDroidSelfRepair(psDroid);
 	}
 
-	/* Update the fire damage data */
-	if (psDroid->periodicalDamageStart != 0 && psDroid->periodicalDamageStart != gameTime - deltaGameTime)  // -deltaGameTime, since projectiles are updated after droids.
-	{
-		// The periodicalDamageStart has been set, but is not from the previous tick, so we must be out of the fire.
-		psDroid->periodicalDamage = 0;  // Reset periodical damage done this tick.
-		if (psDroid->periodicalDamageStart + BURN_TIME < gameTime)
-		{
-			// Finished periodical damaging.
-			psDroid->periodicalDamageStart = 0;
-		}
-		else
-		{
-			// do hardcoded burn damage (this damage automatically applied after periodical damage finished)
-			droidDamage(psDroid, BURN_DAMAGE, WC_HEAT, WSC_FLAME, gameTime - deltaGameTime / 2 + 1, true, BURN_MIN_DAMAGE);
-		}
-	}
-
 	// At this point, the droid may be dead due to periodical damage or hardcoded burn damage.
 	if (isDead((BASE_OBJECT *)psDroid))
 	{
@@ -1167,7 +1147,7 @@ bool droidUpdateRestore(DROID *psDroid)
 	ASSERT_OR_RETURN(false, psStats->weaponSubClass == WSC_ELECTRONIC, "unit's weapon is not EW");
 
 	restorePoints = calcDamage(weaponDamage(psStats, psDroid->player),
-	                           psStats->weaponEffect, (BASE_OBJECT *)psStruct);
+	                           psStats,(BASE_OBJECT *)psStruct);
 
 	pointsToAdd = restorePoints * (gameTime - psDroid->actionStarted) /
 	              GAME_TICKS_PER_SEC;
diff --git a/src/droid.h b/src/droid.h
index ce41168..06cfd88 100644
--- a/src/droid.h
+++ b/src/droid.h
@@ -110,7 +110,7 @@ extern UDWORD	calcTemplatePower(DROID_TEMPLATE *psTemplate);
 bool idfDroid(DROID *psDroid);
 
 /* Do damage to a droid */
-int32_t droidDamage(DROID *psDroid, unsigned damage, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, unsigned impactTime, bool isDamagePerSecond, int minDamage);
+int32_t droidDamage(DROID *psDroid, unsigned damage, WEAPON_STATS *psStats, unsigned impactTime, bool isDamagePerSecond, int minDamage);
 
 /* The main update routine for all droids */
 extern void droidUpdate(DROID *psDroid);
diff --git a/src/feature.cpp b/src/feature.cpp
index 7b5b81c..9d22eac 100644
--- a/src/feature.cpp
+++ b/src/feature.cpp
@@ -155,7 +155,7 @@ void featureStatsShutDown(void)
  *  \param weaponClass,weaponSubClass the class and subclass of the weapon that deals the damage
  *  \return < 0 never, >= 0 always
  */
-int32_t featureDamage(FEATURE *psFeature, unsigned damage, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, unsigned impactTime, bool isDamagePerSecond, int minDamage)
+int32_t featureDamage(FEATURE *psFeature, unsigned damage, WEAPON_STATS *psStats, unsigned impactTime, bool isDamagePerSecond, int minDamage)
 {
 	int32_t relativeDamage;
 
@@ -164,7 +164,7 @@ int32_t featureDamage(FEATURE *psFeature, unsigned damage, WEAPON_CLASS weaponCl
 	debug(LOG_ATTACK, "feature (id %d): body %d armour %d damage: %d",
 	      psFeature->id, psFeature->body, psFeature->psStats->armourValue, damage);
 
-	relativeDamage = objDamage(psFeature, damage, psFeature->psStats->body, weaponClass, weaponSubClass, isDamagePerSecond, minDamage);
+	relativeDamage = objDamage(psFeature, damage, psFeature->psStats->body, psStats, isDamagePerSecond, minDamage);
 
 	// If the shell did sufficient damage to destroy the feature
 	if (relativeDamage < 0)
diff --git a/src/feature.h b/src/feature.h
index 9818eda..ef7071a 100644
--- a/src/feature.h
+++ b/src/feature.h
@@ -54,7 +54,7 @@ bool destroyFeature(FEATURE *psDel, unsigned impactTime);
 /* get a feature stat id from its name */
 extern SDWORD getFeatureStatFromName(const char *pName);
 
-int32_t featureDamage(FEATURE *psFeature, unsigned damage, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, unsigned impactTime, bool isDamagePerSecond, int minDamage);
+int32_t featureDamage(FEATURE *psFeature, unsigned damage, WEAPON_STATS *psStats, unsigned impactTime, bool isDamagePerSecond, int minDamage);
 
 extern void     featureInitVars(void);
 
diff --git a/src/move.cpp b/src/move.cpp
index 27def0e..b08a3e1 100644
--- a/src/move.cpp
+++ b/src/move.cpp
@@ -57,9 +57,9 @@
 #include "qtscript.h"
 
 /* max and min vtol heights above terrain */
-#define	VTOL_HEIGHT_MIN				250
-#define	VTOL_HEIGHT_LEVEL			300
-#define	VTOL_HEIGHT_MAX				350
+#define	VTOL_HEIGHT_MIN				400
+#define	VTOL_HEIGHT_LEVEL			450
+#define	VTOL_HEIGHT_MAX				500
 
 // Maximum size of an object for collision
 #define OBJ_MAXRADIUS	(TILE_UNITS * 4)
diff --git a/src/oprint.cpp b/src/oprint.cpp
index ee3e6d6..24d6ec7 100644
--- a/src/oprint.cpp
+++ b/src/oprint.cpp
@@ -137,6 +137,56 @@ static void printWeaponInfo(const WEAPON_STATS *psStats)
 	case WSC_EMP:
 		pWSC = "WSC_EMP";
 		break;
+	/* New weapon subclasses for FK mod and some generic subclasses for other projects */
+	/* Added by Kreuvf 2012-06-03 */
+	case WSC_AACANNON:
+		pWSC = "WSC_AACANNON";
+		break;
+	case WSC_CLUSTERBOMB:
+		pWSC = "WSC_CLUSTERBOMB";
+		break;
+	case WSC_HEAVYBOMB:
+		pWSC = "WSC_HEAVYBOMB";
+		break;
+	case WSC_HOTBOMB:
+		pWSC = "WSC_HOTBOMB";
+		break;
+	case WSC_HOTHOWITZER:
+		pWSC = "WSC_HOTHOWITZER";
+		break;
+	case WSC_LASER:
+		pWSC = "WSC_LASER";
+		break;
+	case WSC_AALASER:
+		pWSC = "WSC_AALASER";
+		break;
+	case WSC_GEN0:
+		pWSC = "WSC_GEN0";
+		break;
+	case WSC_GEN1:
+		pWSC = "WSC_GEN1";
+		break;
+	case WSC_GEN2:
+		pWSC = "WSC_GEN2";
+		break;
+	case WSC_GEN3:
+		pWSC = "WSC_GEN3";
+		break;
+	case WSC_GEN4:
+		pWSC = "WSC_GEN4";
+		break;
+	case WSC_GEN5:
+		pWSC = "WSC_GEN5";
+		break;
+	case WSC_GEN6:
+		pWSC = "WSC_GEN6";
+		break;
+	case WSC_GEN7:
+		pWSC = "WSC_GEN7";
+		break;
+	case WSC_GEN8:
+		pWSC = "WSC_GEN8";
+		break;
 	default:
 		pWSC = "UNKNOWN SUB CLASS";
 		break;
diff --git a/src/projectile.cpp b/src/projectile.cpp
index 024148f..7fa9786 100644
--- a/src/projectile.cpp
+++ b/src/projectile.cpp
@@ -112,8 +112,7 @@ static void	proj_ImpactFunc(PROJECTILE *psObj);
 static void	proj_PostImpactFunc(PROJECTILE *psObj);
 static void proj_checkPeriodicalDamage(PROJECTILE *psProj);
 
-static int32_t objectDamage(BASE_OBJECT *psObj, unsigned damage, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, unsigned impactTime, bool isDamagePerSecond, int minDamage);
-
+static int32_t objectDamage(BASE_OBJECT *psObj, unsigned damage, WEAPON_STATS *psStats, unsigned impactTime, bool isDamagePerSecond, int minDamage);
 
 static inline void setProjectileDestination(PROJECTILE *psProj, BASE_OBJECT *psObj)
 {
@@ -552,7 +551,8 @@ bool proj_SendProjectileAngled(WEAPON *psWeap, SIMPLE_OBJECT *psAttacker, int pl
 				/* firing sound emitted from source */
 				audio_PlayObjDynamicTrack(psProj->psSource, psStats->iAudioFireID, NULL);
 				/* GJ HACK: move howitzer sound with shell */
-				if (psStats->weaponSubClass == WSC_HOWITZERS)
+				/* Kreuvf: Added HOTHOWITZER */
+				if ( (psStats->weaponSubClass == WSC_HOWITZERS) || (psStats->weaponSubClass == WSC_HOTHOWITZER) )
 				{
 					audio_PlayObjDynamicTrack(psProj, ID_SOUND_HOWITZ_FLIGHT, NULL);
 				}
@@ -1087,7 +1087,7 @@ static void proj_ImpactFunc(PROJECTILE *psObj)
 		{
 			// If we did enough `damage' to capture the target
 			if (electronicDamage(psObj->psDest,
-			                     calcDamage(weaponDamage(psStats, psObj->player), psStats->weaponEffect, psObj->psDest),
+			                     calcDamage(weaponDamage(psStats, psObj->player), psStats, psObj->psDest),
 			                     psObj->player))
 			{
 				switch (psObj->psSource->type)
@@ -1112,7 +1112,7 @@ static void proj_ImpactFunc(PROJECTILE *psObj)
 		else
 		{
 			// Calculate the damage the weapon does to its target
-			unsigned int damage = calcDamage(weaponDamage(psStats, psObj->player), psStats->weaponEffect, psObj->psDest);
+			unsigned int damage = calcDamage(weaponDamage(psStats, psObj->player), psStats, psObj->psDest);
 
 			// If we are in a multi-player game and the attacker is our responsibility
 			if (bMultiPlayer && psObj->psSource)
@@ -1124,8 +1124,8 @@ static void proj_ImpactFunc(PROJECTILE *psObj)
 			      psObj->psDest->id, psObj->psDest->player);
 
 			// Damage the object
-			relativeDamage = objectDamage(psObj->psDest, damage, psStats->weaponClass, psStats->weaponSubClass,
-			                              psObj->time, false, psStats->upgrade[psObj->player].minimumDamage);
+			relativeDamage = objectDamage(psObj->psDest, damage, psStats, psObj->time, false,
+			                              psStats->upgrade[psObj->player].minimumDamage);
 
 			proj_UpdateKills(psObj, relativeDamage);
 
@@ -1203,14 +1203,14 @@ static void proj_ImpactFunc(PROJECTILE *psObj)
 				continue;  // Target out of range.
 			}
 			// The psCurr will get damaged, at this point.
-			unsigned damage = calcDamage(weaponRadDamage(psStats, psObj->player), psStats->weaponEffect, psCurr);
+			unsigned damage = calcDamage(weaponRadDamage(psStats, psObj->player), psStats, psCurr);
 			debug(LOG_ATTACK, "Damage to object %d, player %d : %u", psCurr->id, psCurr->player, damage);
 			if (bMultiPlayer && psObj->psSource != NULL && psCurr->type != OBJ_FEATURE)
 			{
 				updateMultiStatsDamage(psObj->psSource->player, psCurr->player, damage);
 			}
-			int relativeDamage = objectDamage(psCurr, damage, psStats->weaponClass, psStats->weaponSubClass,
-			                                  psObj->time, false, psStats->upgrade[psObj->player].minimumDamage);
+			int relativeDamage = objectDamage(psCurr, damage, psStats, psObj->time, false,
+			                                  psStats->upgrade[psObj->player].minimumDamage);
 			proj_UpdateKills(psObj, relativeDamage);
 		}
 	}
@@ -1239,7 +1239,7 @@ static void proj_PostImpactFunc(PROJECTILE *psObj)
 	int age = gameTime - psObj->born;
 
 	/* Time to finish postimpact effect? */
-	if (age > psStats->radiusLife && age > psStats->upgrade[psObj->player].periodicalDamageTime)
+	if (age >= psStats->radiusLife && age >= psStats->upgrade[psObj->player].periodicalDamageTime)
 	{
 		psObj->state = PROJ_INACTIVE;
 		return;
@@ -1308,6 +1308,13 @@ void PROJECTILE::update()
 
 	case PROJ_INACTIVE:
 		psObj->died = psObj->time;
+		if (!psObj->burnVictims.empty())
+		{
+			for(std::list<BASE_OBJECT *>::iterator it = psObj->burnVictims.begin(); it != psObj->burnVictims.end(); it++)
+			{
+				(*it)->periodicalDamageStart = 0;
+			}
+		}
 		break;
 	}
 
@@ -1339,11 +1346,32 @@ static void proj_checkPeriodicalDamage(PROJECTILE *psProj)
 
 	WEAPON_STATS *psStats = psProj->psWStats;
 
+	BASE_OBJECT* psCurr;
+
+	if (!psProj->burnVictims.empty())
+	{
+		for (std::list<BASE_OBJECT *>::iterator it = psProj->burnVictims.begin(); it != psProj->burnVictims.end(); it++)
+		{
+			psCurr = *it;
+			if(isDead(psCurr))
+			{
+				it = psProj->burnVictims.erase(it);
+			}
+		}
+	}
+
 	static GridList gridList;  // static to avoid allocations.
-	gridList = gridStartIterate(psProj->pos.x, psProj->pos.y, psStats->upgrade[psProj->player].periodicalDamageRadius);
+	/*
+		HACK
+		Problem: 3x3 buildings can only be hit by burn damage if the radius touches the centre of the structure
+		Solution: Include more targets in the gridList by raising the fire radius by the maximum distance from the corner of a building to its centre
+	*/
+	gridList = gridStartIterate(psProj->pos.x,
+	                            psProj->pos.y,
+	                            psStats->upgrade[psProj->player].periodicalDamageRadius + 2.2 * TILE_UNITS);
 	for (GridIterator gi = gridList.begin(); gi != gridList.end(); ++gi)
 	{
-		BASE_OBJECT *psCurr = *gi;
+		psCurr = *gi;
 		if (psCurr->died)
 		{
 			continue;  // Do not damage dead objects further.
@@ -1366,18 +1394,96 @@ static void proj_checkPeriodicalDamage(PROJECTILE *psProj)
 			continue;  // Can't destroy oil wells.
 		}
 
+		if (psCurr->type == OBJ_DROID)
+		{
+			/* Distance between projectile centre and unit centre must <= burn radius + hitbox radius */
+			int squareDistance =
+				(psProj->pos.x - psCurr->pos.x) * (psProj->pos.x - psCurr->pos.x)
+				+ (psProj->pos.y - psCurr->pos.y) * (psProj->pos.y - psCurr->pos.y);
+			int squareRadii =
+				(establishTargetShape(psCurr).radius() + psStats->upgrade[psProj->player].periodicalDamageRadius)
+				* (establishTargetShape(psCurr).radius() + psStats->upgrade[psProj->player].periodicalDamageRadius);
+			if (squareDistance > squareRadii)
+			{
+				continue;
+			}
+			/*debug(LOG_WZ, "Proj x,y,r: %i,%i,%i  Target x,y,r: %i,%i,%i",
+				psProj->pos.x,
+				psProj->pos.y,
+				psStats->upgrade[psProj->player].periodicalDamageRadius,
+				psCurr->pos.x,
+				psCurr->pos.y,
+				establishTargetShape(psCurr).radius());
+			debug(LOG_WZ, "Distance²: %i  Radius sum²: %i", (psProj->pos.x - psCurr->pos.x) * (psProj->pos.x - psCurr->pos.x) + (psProj->pos.y - psCurr->pos.y) * (psProj->pos.y - psCurr->pos.y), (establishTargetShape(psCurr).radius() + psStats->upgrade[psProj->player].periodicalDamageRadius) * (establishTargetShape(psCurr).radius() + psStats->upgrade[psProj->player].periodicalDamageRadius));*/
+		}
+
+		if (psCurr->type == OBJ_STRUCTURE)
+		{
+			ObjectShape hitbox = establishTargetShape(psCurr);
+			Vector2i circle, rect, distance;
+			int32_t width, height, radius, cornerDistance_sq;
+			width = hitbox.size.x;
+			height = hitbox.size.y;
+			radius = psStats->upgrade[psProj->player].periodicalDamageRadius;
+			circle.x = psProj->pos.x;
+			circle.y = psProj->pos.y;
+			rect.x = psCurr->pos.x;
+			rect.y = psCurr->pos.y;
+			distance.x = abs(circle.x - rect.x);
+			distance.y = abs(circle.y - rect.y);
+			//debug(LOG_WZ, "Proj: %i,%i Target: %i, %i Width %i Height %i Radius %i ", circle.x, circle.y, rect.x, rect.y, width, height, radius);
+
+			bool intersects;
+			if (distance.x > (width + radius) || distance.y > (height + radius)) {
+				intersects = false;
+			} else	if (distance.x <= (width) || distance.y <= (height)) {
+				intersects = true;
+			} else {
+				cornerDistance_sq = (distance.x - width)  * (distance.x - width) +
+				                    (distance.y - height) * (distance.y - height/2);
+
+				intersects = cornerDistance_sq <= (radius * radius);
+			}
+			//debug(LOG_WZ, "Intersects: %s", intersects ? "true" : "false");
+
+			if (!intersects) continue;
+		}
+
 		if (psCurr->periodicalDamageStart != gameTime)
 		{
 			psCurr->periodicalDamageStart = gameTime;
 			psCurr->periodicalDamage = 0;  // Reset periodical damage done this tick.
 		}
-		unsigned damageRate = calcDamage(weaponPeriodicalDamage(psStats, psProj->player), psStats->periodicalDamageWeaponEffect, psCurr);
-		debug(LOG_NEVER, "Periodical damage of %d per second to object %d, player %d\n", damageRate, psCurr->id, psCurr->player);
 
-		int relativeDamage = objectDamage(psCurr, damageRate, psStats->periodicalDamageWeaponClass,
-		                                  psStats->periodicalDamageWeaponSubClass, gameTime - deltaGameTime / 2 + 1, true,
-		                                  psStats->upgrade[psProj->player].minimumDamage);
-		proj_UpdateKills(psProj, relativeDamage);
+		if (psProj->burnVictims.empty())
+		{
+			psProj->burnVictims.push_front(psCurr);
+		} else {
+			for (std::list<BASE_OBJECT *>::iterator it = psProj->burnVictims.begin(); it != psProj->burnVictims.end(); it++)
+			{
+				if (psCurr == *it)
+				{
+					break;
+				} else if (*it == psProj->burnVictims.back()) {
+					psProj->burnVictims.push_back(psCurr);
+					break;
+				}
+			}
+		}
+	}
+	unsigned damageRate;
+
+	int relativeDamage;
+	
+	if (!psProj->burnVictims.empty())
+	{
+		for (std::list<BASE_OBJECT *>::iterator it = psProj->burnVictims.begin(); it != psProj->burnVictims.end(); it++)
+		{
+			psCurr = *it;
+			damageRate = weaponPeriodicalDamage(psCurr, psStats, psProj->player);
+			relativeDamage = objectDamage(psCurr, damageRate, psStats, gameTime - deltaGameTime/2 + 1, true, psStats->upgrade[psProj->player].minimumDamage);
+			proj_UpdateKills(psProj, relativeDamage);
+		}
 	}
 }
 
@@ -1432,7 +1538,7 @@ static ObjectShape establishTargetShape(BASE_OBJECT *psTarget)
 		case DROID_CYBORG_REPAIR:
 		case DROID_CYBORG_SUPER:
 			//Watermelon:'hitbox' size is now based on imd size
-			return abs(psTarget->sDisplay.imd->radius) * 2;
+                        return abs(psTarget->sDisplay.imd->radius);
 		case DROID_DEFAULT:
 		case DROID_TRANSPORTER:
 		case DROID_SUPERTRANSPORTER:
@@ -1457,29 +1563,42 @@ static ObjectShape establishTargetShape(BASE_OBJECT *psTarget)
 
 /*the damage depends on the weapon effect and the target propulsion type or
 structure strength*/
-UDWORD	calcDamage(UDWORD baseDamage, WEAPON_EFFECT weaponEffect, BASE_OBJECT *psTarget)
+UDWORD calcDamage(UDWORD baseDamage, WEAPON_STATS *psStats, BASE_OBJECT *psTarget)
 {
-	UDWORD	damage = baseDamage * 100;
-
+	double damage = (double) baseDamage;
+	const WEAPON_EFFECT weaponEffect = psStats->weaponEffect;
+	const WEAPON_CLASS weaponClass = psStats->weaponClass;
+	
 	if (psTarget->type == OBJ_STRUCTURE)
-	{
-		damage += baseDamage * (asStructStrengthModifier[weaponEffect][((STRUCTURE *)psTarget)->pStructureType->strength] - 100);
+	{		
+		STRUCTURE *target = (STRUCTURE *)psTarget;
+		const UDWORD armour = objArmour(target, weaponClass);
+		const STRUCTSTRENGTH_MODIFIER structMod = target->pStructureType->strength;
+		const double modifier = asStructStrengthModifier[weaponEffect][structMod]/100.0;
+		
+		/* Step 1: Reduce damage by armour */
+		damage < armour ? 0 : damage -= armour;
+		
+		/* Step 2: Reduce damage by target type modifier */
+		damage = floor(damage * modifier);
 	}
 	else if (psTarget->type == OBJ_DROID)
 	{
+		DROID *target = (DROID *)psTarget;
+		const UDWORD armour = objArmour(target, weaponClass);
 		const int propulsion = (asPropulsionStats + ((DROID *)psTarget)->asBits[COMP_PROPULSION])->propulsionType;
-		const int body = (asBodyStats + ((DROID *)psTarget)->asBits[COMP_BODY])->size;
-		damage += baseDamage * (asWeaponModifier[weaponEffect][propulsion] - 100);
-		damage += baseDamage * (asWeaponModifierBody[weaponEffect][body] - 100);
-	}
-
-	// A little fail safe!
-	if (damage == 0 && baseDamage != 0)
-	{
-		return 1;
-	}
-
-	return damage / 100;
+		const double modifier = asWeaponModifier[weaponEffect][propulsion]/100.0;
+		/* Hint: Do not care about asWeaponModifierBody[weaponEffect][body] as
+		probably zarel killed the correct parsing of these modifiers in 2009-05
+		and they were just a constant factor of 1 anyway! */
+		
+		/* Step 1: Reduce damage by armour */
+		damage < armour ? 0 : damage -= armour;
+		
+		/* Step 2: Reduce damage by propulsion type modifier */
+		damage = floor(damage * modifier);
+	}
+	return (int) round(damage);
 }
 
 /*
@@ -1497,20 +1616,20 @@ UDWORD	calcDamage(UDWORD baseDamage, WEAPON_EFFECT weaponEffect, BASE_OBJECT *ps
  *    multiplied by -1, resulting in a negative number. Killed features do not
  *    result in negative numbers.
  */
-static int32_t objectDamage(BASE_OBJECT *psObj, unsigned damage, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, unsigned impactTime, bool isDamagePerSecond, int minDamage)
+static int32_t objectDamage(BASE_OBJECT *psObj, unsigned damage, WEAPON_STATS *psStats, unsigned impactTime, bool isDamagePerSecond, int minDamage)
 {
 	switch (psObj->type)
 	{
 	case OBJ_DROID:
-		return droidDamage((DROID *)psObj, damage, weaponClass, weaponSubClass, impactTime, isDamagePerSecond, minDamage);
+		return droidDamage((DROID *)psObj, damage, psStats, impactTime, isDamagePerSecond, minDamage);
 		break;
 
 	case OBJ_STRUCTURE:
-		return structureDamage((STRUCTURE *)psObj, damage, weaponClass, weaponSubClass, impactTime, isDamagePerSecond, minDamage);
+		return structureDamage((STRUCTURE *)psObj, damage, psStats, impactTime, isDamagePerSecond, minDamage);
 		break;
 
 	case OBJ_FEATURE:
-		return featureDamage((FEATURE *)psObj, damage, weaponClass, weaponSubClass, impactTime, isDamagePerSecond, minDamage);
+		return featureDamage((FEATURE *)psObj, damage, psStats, impactTime, isDamagePerSecond, minDamage);
 		break;
 
 	case OBJ_PROJECTILE:
diff --git a/src/projectile.h b/src/projectile.h
index d2d9975..636375c 100644
--- a/src/projectile.h
+++ b/src/projectile.h
@@ -38,9 +38,6 @@ extern	BASE_OBJECT	*g_pProjLastAttacker;	///< The last unit that did damage - us
 #define PROJ_MAX_PITCH  45
 #define PROJ_ULTIMATE_PITCH  80
 
-#define BURN_TIME	10000	///< How long an object burns for after leaving a fire.
-#define BURN_DAMAGE	15	///< How much damage per second an object takes when it is burning.
-#define BURN_MIN_DAMAGE	30	///< Least percentage of damage an object takes when burning.
 #define ACC_GRAVITY	1000	///< Downward force against projectiles.
 
 /** How long to display a single electronic warfare shimmmer. */
@@ -74,7 +71,7 @@ bool proj_Direct(const WEAPON_STATS *psStats);
 /** Return the maximum range for a weapon. */
 int proj_GetLongRange(const WEAPON_STATS *psStats, int player);
 
-extern UDWORD calcDamage(UDWORD baseDamage, WEAPON_EFFECT weaponEffect, BASE_OBJECT *psTarget);
+extern UDWORD calcDamage(UDWORD baseDamage, WEAPON_STATS *psStats, BASE_OBJECT *psTarget);
 extern bool gfxVisible(PROJECTILE *psObj);
 
 /***************************************************************************/
diff --git a/src/projectiledef.h b/src/projectiledef.h
index d2a9477..61dbece 100644
--- a/src/projectiledef.h
+++ b/src/projectiledef.h
@@ -28,6 +28,7 @@
 #include "lib/gamelib/gtime.h"
 
 #include <vector>
+#include <list>
 
 
 enum PROJ_STATE
@@ -59,6 +60,7 @@ struct PROJECTILE : public SIMPLE_OBJECT
 	BASE_OBJECT    *psSource;               ///< what fired the projectile
 	BASE_OBJECT    *psDest;                 ///< target of this projectile
 	std::vector<BASE_OBJECT *> psDamaged;   ///< the targets that have already been dealt damage to (don't damage the same target twice)
+	std::list<BASE_OBJECT *> burnVictims; ///< CPP linked list with the projectile's burn victims
 
 	Vector3i        src;                    ///< Where projectile started
 	Vector3i        dst;                    ///< The target coordinates
diff --git a/src/stats.cpp b/src/stats.cpp
index 02cd789..1d4cb4b 100644
--- a/src/stats.cpp
+++ b/src/stats.cpp
@@ -40,6 +40,7 @@
 #include "lib/sound/audio_id.h"
 #include "projectile.h"
 #include "text.h"
+#include "combat.h"
 
 #define WEAPON_TIME		100
 
@@ -353,6 +354,7 @@ bool loadWeaponStats(const char *pFileName)
 		flags = ini.value("flags", 0).toStringList();
 		psStats->vtolAttackRuns = ini.value("numAttackRuns", 0).toUInt();
 		psStats->penetrate = ini.value("penetrate", false).toBool();
+		psStats->targeting = ini.value("targeting", false).toBool();
 		// weapon size limitation
 		int weaponSize = ini.value("weaponSize", WEAPON_SIZE_ANY).toInt();
 		ASSERT(weaponSize <= WEAPON_SIZE_ANY, "Bad weapon size for %s", list[i].toUtf8().constData());
@@ -394,7 +396,7 @@ bool loadWeaponStats(const char *pFileName)
 		{
 			psStats->distanceExtensionFactor = 120;
 		}
-		else if (psStats->weaponSubClass == WSC_AAGUN)
+		else if (psStats->weaponSubClass == WSC_AAGUN || psStats->weaponSubClass == WSC_AACANNON)
 		{
 			psStats->distanceExtensionFactor = 100;
 		}
@@ -856,6 +858,10 @@ bool loadSensorStats(const char *pFileName)
 		{
 			psStats->type = RADAR_DETECTOR_SENSOR;
 		}
+		else if (type.compare("SURVEILLANCE") == 0)
+		{
+			psStats->type = SURVEILLANCE_SENSOR;
+		}
 		else
 		{
 			ASSERT(false, "Invalid Sensor type");
@@ -1494,6 +1500,71 @@ bool getWeaponSubClass(const char *subClass, WEAPON_SUBCLASS *wclass)
 	{
 		*wclass = WSC_EMP;
 	}
+	/* New weapon subclasses for FK mod and some generic subclasses for other projects */
+	else if (strcmp(subClass, "A-A CANNON") == 0)
+	{
+		*wclass = WSC_AACANNON;
+	}
+	else if (strcmp(subClass, "CLUSTER BOMB") == 0)
+	{
+		*wclass = WSC_CLUSTERBOMB;
+	}
+	else if (strcmp(subClass, "HEAVY BOMB") == 0)
+	{
+		*wclass = WSC_HEAVYBOMB;
+	}
+	else if (strcmp(subClass, "HOT BOMB") == 0)
+	{
+		*wclass = WSC_HOTBOMB;
+	}
+	else if (strcmp(subClass, "HOT HOWITZER") == 0)
+	{
+		*wclass = WSC_HOTHOWITZER;
+	}
+	else if (strcmp(subClass, "LASER") == 0)
+	{
+		*wclass = WSC_LASER;
+	}
+	else if (strcmp(subClass, "A-A LASER") == 0)
+	{
+		*wclass = WSC_AALASER;
+	}
+	else if (strcmp(subClass, "GENERIC 0") == 0)
+	{
+		*wclass = WSC_GEN0;
+	}
+	else if (strcmp(subClass, "GENERIC 1") == 0)
+	{
+		*wclass = WSC_GEN1;
+	}
+	else if (strcmp(subClass, "GENERIC 2") == 0)
+	{
+		*wclass = WSC_GEN2;
+	}
+	else if (strcmp(subClass, "GENERIC 3") == 0)
+	{
+		*wclass = WSC_GEN3;
+	}
+	else if (strcmp(subClass, "GENERIC 4") == 0)
+	{
+		*wclass = WSC_GEN4;
+	}
+	else if (strcmp(subClass, "GENERIC 5") == 0)
+	{
+		*wclass = WSC_GEN5;
+	}
+	else if (strcmp(subClass, "GENERIC 6") == 0)
+	{
+		*wclass = WSC_GEN6;
+	}
+	else if (strcmp(subClass, "GENERIC 7") == 0)
+	{
+		*wclass = WSC_GEN7;
+	}
+	else if (strcmp(subClass, "GENERIC 8") == 0)
+	{
+		*wclass = WSC_GEN8;
+	}
 	else
 	{
 		ASSERT(!"Invalid weapon sub class", "Invalid weapon sub class: %s", subClass);
@@ -1525,6 +1596,22 @@ const char *getWeaponSubClass(WEAPON_SUBCLASS wclass)
 	case WSC_BOMB: return "BOMB";
 	case WSC_COMMAND: return "COMMAND";
 	case WSC_EMP: return "EMP";
+	case WSC_AACANNON: return "A-A CANNON";
+	case WSC_CLUSTERBOMB: return "CLUSTER BOMB";
+	case WSC_HEAVYBOMB: return "HEAVY BOMB";
+	case WSC_HOTBOMB: return "HOT BOMB";
+	case WSC_HOTHOWITZER: return "HOT HOWITZER";
+	case WSC_LASER: return "LASER";
+	case WSC_AALASER: return "A-A LASER";
+	case WSC_GEN0: return "GENERIC 0";
+	case WSC_GEN1: return "GENERIC 1";
+	case WSC_GEN2: return "GENERIC 2";
+	case WSC_GEN3: return "GENERIC 3";
+	case WSC_GEN4: return "GENERIC 4";
+	case WSC_GEN5: return "GENERIC 5";
+	case WSC_GEN6: return "GENERIC 6";
+	case WSC_GEN7: return "GENERIC 7";
+	case WSC_GEN8: return "GENERIC 8";
 	case WSC_NUM_WEAPON_SUBCLASSES: break;
 	}
 	ASSERT(false, "No such weapon subclass");
@@ -1652,9 +1739,14 @@ int weaponRadDamage(const WEAPON_STATS *psStats, int player)
 	return psStats->upgrade[player].radiusDamage;
 }
 
-int weaponPeriodicalDamage(const WEAPON_STATS *psStats, int player)
+int weaponPeriodicalDamage(BASE_OBJECT *psObj, const WEAPON_STATS *psStats, int player)
 {
-	return psStats->upgrade[player].periodicalDamage;
+	const WEAPON_CLASS weaponClass = psStats->weaponClass;
+	DROID *target = (DROID *)psObj;
+	const int armour = objArmour(target, weaponClass);
+	unsigned int damage = psStats->upgrade[player].periodicalDamage;
+	damage < armour ? 0 : damage -= armour;
+	return (int) round(damage);
 }
 
 int sensorRange(const SENSOR_STATS *psStats, int player)
@@ -2072,3 +2164,88 @@ bool objRadarDetector(const BASE_OBJECT *psObj)
 	}
 	return false;
 }
+
+bool objSurveillanceSensor(const BASE_OBJECT *psObj) {
+	if (psObj->type == OBJ_STRUCTURE)
+	{
+		STRUCTURE *psStruct = (STRUCTURE *)psObj;
+
+		return (psStruct->status == SS_BUILT && psStruct->pStructureType->pSensor && psStruct->pStructureType->pSensor->type == SURVEILLANCE_SENSOR);
+	}
+	else if (psObj->type == OBJ_DROID)
+	{
+		DROID *psDroid = (DROID *)psObj;
+		SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+		return (psSensor && psSensor->type == SURVEILLANCE_SENSOR);
+	}
+	return false;
+}
+
+bool objVTOLSensor(const BASE_OBJECT *psObj) {
+	if (psObj->type == OBJ_STRUCTURE)
+	{
+		STRUCTURE *psStruct = (STRUCTURE *)psObj;
+
+		return (psStruct->status == SS_BUILT && psStruct->pStructureType->pSensor && psStruct->pStructureType->pSensor->type == VTOL_INTERCEPT_SENSOR);
+	}
+	else if (psObj->type == OBJ_DROID)
+	{
+		DROID *psDroid = (DROID *)psObj;
+		SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+		return (psSensor && psSensor->type == VTOL_INTERCEPT_SENSOR);
+	}
+	return false;
+}
+
+bool objVTOLCBSensor(const BASE_OBJECT *psObj) {
+	if (psObj->type == OBJ_STRUCTURE)
+	{
+		STRUCTURE *psStruct = (STRUCTURE *)psObj;
+
+		return (psStruct->status == SS_BUILT && psStruct->pStructureType->pSensor && psStruct->pStructureType->pSensor->type == VTOL_CB_SENSOR);
+	}
+	else if (psObj->type == OBJ_DROID)
+	{
+		DROID *psDroid = (DROID *)psObj;
+		SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+		return (psSensor && psSensor->type == VTOL_CB_SENSOR);
+	}
+	return false;
+}
+
+bool objCBSensor(const BASE_OBJECT *psObj) {
+	if (psObj->type == OBJ_STRUCTURE)
+	{
+		STRUCTURE *psStruct = (STRUCTURE *)psObj;
+
+		return (psStruct->status == SS_BUILT && psStruct->pStructureType->pSensor && psStruct->pStructureType->pSensor->type == INDIRECT_CB_SENSOR);
+	}
+	else if (psObj->type == OBJ_DROID)
+	{
+		DROID *psDroid = (DROID *)psObj;
+		SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+		return (psSensor && psSensor->type == INDIRECT_CB_SENSOR);
+	}
+	return false;
+}
+
+bool objStandardSensor(const BASE_OBJECT *psObj) {
+	if (psObj->type == OBJ_STRUCTURE)
+	{
+		STRUCTURE *psStruct = (STRUCTURE *)psObj;
+
+		return (psStruct->status == SS_BUILT && psStruct->pStructureType->pSensor && psStruct->pStructureType->pSensor->type == STANDARD_SENSOR);
+	}
+	else if (psObj->type == OBJ_DROID)
+	{
+		DROID *psDroid = (DROID *)psObj;
+		SENSOR_STATS *psSensor = getSensorStats(psDroid);
+
+		return (psSensor && psSensor->type == STANDARD_SENSOR);
+	}
+	return false;
+}
diff --git a/src/stats.h b/src/stats.h
index 789804b..cd39c8f 100644
--- a/src/stats.h
+++ b/src/stats.h
@@ -233,7 +233,7 @@ WZ_DECL_PURE int weaponShortHit(const WEAPON_STATS *psStats, int player);
 WZ_DECL_PURE int weaponLongHit(const WEAPON_STATS *psStats, int player);
 WZ_DECL_PURE int weaponDamage(const WEAPON_STATS *psStats, int player);
 WZ_DECL_PURE int weaponRadDamage(const WEAPON_STATS *psStats, int player);
-WZ_DECL_PURE int weaponPeriodicalDamage(const WEAPON_STATS *psStats, int player);
+WZ_DECL_PURE int weaponPeriodicalDamage(BASE_OBJECT *psObj, const WEAPON_STATS *psStats, int player);
 WZ_DECL_PURE int sensorRange(const SENSOR_STATS *psStats, int player);
 WZ_DECL_PURE int ecmRange(const ECM_STATS *psStats, int player);
 WZ_DECL_PURE int repairPoints(const REPAIR_STATS *psStats, int player);
@@ -272,4 +272,14 @@ WZ_DECL_PURE SENSOR_STATS *objActiveRadar(const BASE_OBJECT *psObj);
 /** Returns whether object has a radar detector sensor. */
 WZ_DECL_PURE bool objRadarDetector(const BASE_OBJECT *psObj);
 
+WZ_DECL_PURE bool objSurveillanceSensor(const BASE_OBJECT *psObj);
+
+WZ_DECL_PURE bool objVTOLSensor(const BASE_OBJECT *psObj);
+
+WZ_DECL_PURE bool objVTOLCBSensor(const BASE_OBJECT *psObj);
+
+WZ_DECL_PURE bool objCBSensor(const BASE_OBJECT *psObj);
+
+WZ_DECL_PURE bool objStandardSensor(const BASE_OBJECT *psObj);
+
 #endif // __INCLUDED_SRC_STATS_H__
diff --git a/src/statsdef.h b/src/statsdef.h
index 4027ec9..e0dccf9 100644
--- a/src/statsdef.h
+++ b/src/statsdef.h
@@ -169,6 +169,23 @@ enum WEAPON_SUBCLASS
 	WSC_BOMB,
 	WSC_COMMAND,
 	WSC_EMP,
+	/* New weapon subclasses for FK mod and some generic subclasses for other projects */
+	WSC_AACANNON,
+	WSC_CLUSTERBOMB,
+	WSC_HEAVYBOMB,
+	WSC_HOTBOMB,
+	WSC_HOTHOWITZER,
+	WSC_LASER,
+	WSC_AALASER,
+	WSC_GEN0,
+	WSC_GEN1,
+	WSC_GEN2,
+	WSC_GEN3,
+	WSC_GEN4,
+	WSC_GEN5,
+	WSC_GEN6,
+	WSC_GEN7,
+	WSC_GEN8,
 	WSC_NUM_WEAPON_SUBCLASSES,	/** The number of enumerators in this enum.	 */
 };
 
@@ -228,6 +245,7 @@ enum SENSOR_TYPE
 	VTOL_INTERCEPT_SENSOR,
 	SUPER_SENSOR,			///< works as all of the above together! - new for updates
 	RADAR_DETECTOR_SENSOR,
+	SURVEILLANCE_SENSOR,
 };
 
 enum TRAVEL_MEDIUM
@@ -389,6 +407,7 @@ struct WEAPON_STATS : public COMPONENT_STATS
 	short			vtolAttackRuns;			///< number of attack runs a VTOL droid can	do with this weapon
 	bool			penetrate;				///< flag to indicate whether pentrate droid or not
 	int			distanceExtensionFactor;	///< max extra distance a projectile can travel if misses target
+	bool		targeting;				///< indicates if weapon needs sensor for targeting
 
 	/* Graphics control stats */
 	UDWORD			radiusLife;				///< How long a blast radius is visible
diff --git a/src/structure.cpp b/src/structure.cpp
index 4092a3f..96fca2c 100644
--- a/src/structure.cpp
+++ b/src/structure.cpp
@@ -724,16 +724,17 @@ void handleAbandonedStructures()
  * \param weaponSubClass the subclass of the weapon that deals the damage
  * \return < 0 when the dealt damage destroys the structure, > 0 when the structure survives
  */
-int32_t structureDamage(STRUCTURE *psStructure, unsigned damage, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, unsigned impactTime, bool isDamagePerSecond, int minDamage)
+int32_t structureDamage(STRUCTURE *psStructure, unsigned damage, WEAPON_STATS *psStats, unsigned impactTime, bool isDamagePerSecond, int minDamage)
 {
 	int32_t relativeDamage;
+	const WEAPON_CLASS weaponClass = psStats->weaponClass;
 
 	CHECK_STRUCTURE(psStructure);
 
 	debug(LOG_ATTACK, "structure id %d, body %d, armour %d, damage: %d",
 	      psStructure->id, psStructure->body, objArmour(psStructure, weaponClass), damage);
 
-	relativeDamage = objDamage(psStructure, damage, structureBody(psStructure), weaponClass, weaponSubClass, isDamagePerSecond, minDamage);
+	relativeDamage = objDamage(psStructure, damage, structureBody(psStructure), psStats, isDamagePerSecond, minDamage);
 
 	// If the shell did sufficient damage to destroy the structure
 	if (relativeDamage < 0)
diff --git a/src/structure.h b/src/structure.h
index 35bc869..052e1a5 100644
--- a/src/structure.h
+++ b/src/structure.h
@@ -90,7 +90,7 @@ extern bool	structureStatsShutDown(void);
 int requestOpenGate(STRUCTURE *psStructure);
 int gateCurrentOpenHeight(STRUCTURE const *psStructure, uint32_t time, int minimumStub);  ///< Returns how far open the gate is, or 0 if the structure is not a gate.
 
-int32_t structureDamage(STRUCTURE *psStructure, unsigned damage, WEAPON_CLASS weaponClass, WEAPON_SUBCLASS weaponSubClass, unsigned impactTime, bool isDamagePerSecond, int minDamage);
+int32_t structureDamage(STRUCTURE *psStructure, unsigned damage, WEAPON_STATS *psStats, unsigned impactTime, bool isDamagePerSecond, int minDamage);
 extern void structureBuild(STRUCTURE *psStructure, DROID *psDroid, int buildPoints, int buildRate = 1);
 extern void structureDemolish(STRUCTURE *psStructure, DROID *psDroid, int buildPoints);
 void structureRepair(STRUCTURE *psStruct, DROID *psDroid, int buildRate);
